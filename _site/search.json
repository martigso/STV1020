[
  {
    "objectID": "workbench.html",
    "href": "workbench.html",
    "title": "STV1020",
    "section": "",
    "text": "Åpne nettleseren din og gå til https://rstudio-workbench.uio.no/\nVelg Universitetet i Oslo/University of Oslo under tilknytning/affiliation.\n\n\n\nLogg inn med brukernavn og passord fra UiO.\n\n\n\nTrykk på “+ New Session”.\n\n\n\nVelg STV1020-varianten under “Image” og trykk “Start session”. Du kan også velge å gi sesjonen et eget navn under “Session Name”.\n\n\n\nDen nye sesjonen skal nå dukke opp under “Session”. Trykk på “RStudio Session”. Dersom du har gitt sesjonen et eget navn så må du trykke på den sesjonen med navnet du brukte.\n\n\n\nNå skal du få opp Rstudio i nettleseren din."
  },
  {
    "objectID": "rogrstudio.html",
    "href": "rogrstudio.html",
    "title": "STV1020",
    "section": "",
    "text": "R er et gratisprogram som er spesielt egnet for statistikk og dataanalyse. RStudio er en IDE (integrated development environment), et gratisprogram som gjør det lettere å bruke R. Derfor skal vi lære R med RStudio i seminarene.\nFørste gang du åpner RStudio er alt fremmed, du blir du møtt av en rekke vinduer, menyer og knapper. Dette dokumentet gir deg en kort forklaring av det aller mest grunnleggende i R og RStudio gjennom 10 bilder. Dersom du tar deg 5 minutter til å lese dokumentet, og forsøke koden, kommer det første seminaret til å gå som en lek. Dersom første seminar ikke gikk som en lek, og du er usikker på hva som foregår i RStudio, kan det også være nyttig å lese dette dokumentet.\n\n\nDu kan installere R og RStudio ved å følge denne guiden\n\n\n\nNå er du klar til å åpne RStudio (du trenger ikke åpne R!). Når du åpner RStudio, vil denne skjermen dukke opp:\n\nPå bildet ser du tre paneler. Til venstre er Console, øverst til høyre er Environment, og nederst til høyre er Files. Fra hvert av disse panelene er det mulig å trykke seg til andre paneler som Terminal, Plots, History og Help. I denne gjennomgangen forklarer jeg imidlertid bare de fire panelene du trenger for å skrive, kjøre, og lagre kode. Disse panelene er:\n\nScript Her skrives koden din\nConsole - Her produseres output fra koden din\nEnvironment - Her er en oversikt over data du kan kjøre kode på.\nFiles - Her vises filer i mappen du jobber fra, som for eksempel data og kode. Dersom du lagrer scriptet ditt i mappen du jobber fra, dukker det opp her.\n\n\n\n\nLa oss starte med Script. Første gang du åpner RStudio må du åpne dette panelet selv. Det gjør du ved å trykke på arket med grønn sirkel og hvitt plusstegn øverst i høyre hjørne. Jeg har merket dette arket på bildet under. Trykk deretter på “R Script”. Alternativt kan du bruke hurtigtasten ctrl/cmd + shift + N.\n\nNår du har åpnet et nytt R-script vil denne skjermen med fire paneler dukker opp:\n\nI R-scriptet, det øverste panelet til venstre, kan du nå skrive R-koder. La oss prøve å skrive to gyldige R-koder, \"Hello world!\" og 1+1. R-scriptet ditt skal se slik ut:\n\nDu har nå skrevet to linjer med R-kode!\n\n\n\nI forrige bilde merket jeg den nederste linjen i Console, som begynner med >. Den er tom, men når vi kjører koden vi har skrevet, vil RStudio evaluere/kjøre koden i Console. Dersom koden produserer output, vil denne også printes i Console. Vi kjører koden ved å merke koden i scriptet, og trykke på ctrl/cmd + enter (ctrl på pc, cmd på mac). La oss se på resultatet av å kjøre koden vi har skrevet i scriptet:\n\nPå linjen med > vises kode som R har kjørt. På linjen under kode som er kjørt, vises output fra koden. Koden \"Hello world!\"ble lest og evaluert som tekst - resultatet er tekst-outputen “Hello world!”. Koden 1+1 ble lest som et mattestykke, og RStudio produserte outputen 2, løsningen på mattestykket vi ba RStudio om å kjøre/evaluere for oss. RStudio kan tydeligvis både lese og regne.\n\n\n\nDet er ikke all kode som gir output i Console. Noen ganger skriver vi kode som gir input til RStudio i form av informasjon/data som vi ber RStudio huske på for oss. RStudio kan huske på informasjon, uten av vi trenger å lagre den på datamaskinen. Data som RStudio husker, vises i Environment. Vi kaller slike data for objekter. Jeg har merket Environment-panelet, øverst til høyre. Vi bruker som regel objekter, gjerne datasett i kodingen vi gjør.\nLa oss skrive en kode som gir RStudio informasjon å huske på. Til dette bruker vi funksjonen (mer presist: assignment operatoren) <-, som brukes til å oprette objekter. Objekter inneholder ulike samlinger av informasjon/data som RStudio husker på for oss. Vi kan selv velge navnet på objektene våre. Navnet kommer før <-, jeg velger å kalle objektet mitt velkommen. Etter pilen forteller vi hva objektet skal inneholde. Under har jeg brukt funksjonen c() for å fortelle RStudio at jeg ønsker å opprette en vektor (en ordnet liste av verdier) bestående av fire elementer, \"Velkommen\" , \"til\", \"R-seminar\" og \"!\". Når jeg bruker hermetegn, \" \", behandler R disse elementene som tekst.\n\nLa oss se hva som skjer når vi kjører koden (med ctrl + enter på pc og cmd + enter på mac).\n\nVi ser at objektet velkommen har dukket opp i Environment panelet øverst til høyre. Vi får også informasjon om hva objektet inneholder. Først kommer navnet på objektet, chr referer til at objektet består av tekst. Deretter referer [1:4] til at objektet består av fire elementer, som vises til slutt.\nLegg for øvrig merke til at når vi kjørte koden, ble den evaluert i Console, men vi fikk ikke output på en ny linje i Console. Dersom vi evaluerer objektet vi laget, velkommen, får vi imidlertid en egen linje med output, i dette tilfellet innholdet i objektet. Som oftest får vi output i Console, men noen typer kode, som opprettelse av objekter med <- gir output i andre paneler, som Environment\n\nVi har nå sett på 3 deler av arbeidsflyten i RStudio:\n\nFørst skriver vi kode i et script.\nDeretter kjører/evaluerer vi koden i Console med ctrl/cmd + enter.\nResultatet av at koden ble evaluert dukker som regel opp i Console. Når koden produserer objekter med informasjon som RStudio skal huske på, dukker imidlertid objektet opp i Environment.\n\n\n\n\nNår vi er ferdig med de 3 stegene over, vil vi som regel lagre arbeidet vårt, slik at vi ikke trenger å gjøre arbeidet på nytt senere. Dersom det går fort å kjøre gjennom R-scriptet, er scriptet alt vi trenger å lagre. Det er også mulig å lagre datasett, figurer, tabeller og bilder, men dette skal vi lære senere. For å forstå hvordan vi kan lagre ulike filer i RStudio, og hvor R leter etter filer (som datasett) som vi ber R finne, må vi kjenne til mappesystemet på datamaskinen vi jobber fra.\nEt eksempel på en mappe som finnes på de fleste pcer er Mine dokumenter eller Documents. RStudio velger en mappe av denne typen på datamaskinen som working directory. RStudio forventer at filnavn som refereres til ligger i working directory. RStudio vil også sette som default option at filer lagres i working directory.\nPanelet Files nederst til høyre viser filer i ditt nåværende working directory. På bildet under, ser du at mappen jeg har som working directory, data, er tom.\n\nHva skjer dersom jeg lagrer R-scriptet i denne mappen? La oss lagre og sjekke. Trykk på file øverst til venstre i RStudio, trykk deretter på save as. Du kan eventuelt bruke hurtigtastene ctrl/cmd + s. Da vil dette vinduet dukke opp:\n\nJeg velger filnavnet test. Vi trenger ikke å skrive hvilken filtype vi lagrer, RStudio gjør dette for oss. Trykk på lagre uten å skifte mappe du lagrer filen i bor fra default option. Du vil få følgende resultat:\n\nScriptet vårt, test.R dukket nå opp under Files. Dette betyr at RStudio har registrert at filen er i working directory. Filer som slutter med .R er lagret som R-script, vi har dermed lyktes med å lagre R-scriptet riktig.\n\n\n\nOfte ligger mapper inne i andre mapper, under en harddisk (for eksempel C:). Mappene vi må klikke oss gjennom for å komme fra harddisken til en bestemt mappe, f.eks. STV4020A, utgjør filstien til mappen STV4020A. Ved å spesifisere filstien til en mappe, kan du kan bytte working directory med funksjonen setwd(). Dersom vi skriver navnet på en fil som ligger i en annen mappe enn working directory, vil ikke R klare å finne denne, med mindre vi spesifiserer filstien. Vi kan lese filstien til nåværende working directory på toppen av Files-panelet. Fra bildet over, ser vi at mitt working directory er satt til C:/Users/erlenlan/OneDrive/STV4020A/data (Bruk / for å skille mellom mapper når du skriver filstier). Du kan også finne nåværende working directory ved å kjøre koden getwd(). Den beste og letteste måten å unngå frustrasjon pga. working directory er å opprette et prosjekt gjennom menyen i R-studio. Les mer her."
  },
  {
    "objectID": "laste_data.html",
    "href": "laste_data.html",
    "title": "STV1020",
    "section": "",
    "text": "Når du skal laste inn et datasett til RStudio, og det oppstår problemer, kan du sjekke tipsene under. Her er eksemplene fra en Mac, men de samme løsningene vil finnes også på Windows og Linux.\n\n\nPass på at du enten åpner prosjektfilen din eller setter working directory til en mappe du finner igjen. For eksempel kan du lage en mappe som heter “R-seminar” på skrivebordet, og så lage undermapper for hvert seminar. Dere kan sette working directory som vist under, eller bruke koden setwd(). Hvis dere vil dobbeltsjekke, bruk funksjonen getwd().\n\nDet aller viktigste er å finne en god måte å strukturere prosjektene sine på. Eksempelvis “R Best Practices”. Ta gjerne også en titt på RStudios/posit egen side for hvordan man bruker prosjekter.\n\n\n\nPass på at datasettfilen ligger i mappen du prøver å hente den fra. For eksempel er det lurt å ha datasett i en egen datamappe der prosjektfilen din er lagret. På bildet under ser dere hvordan det er gjort i dette eksempelet.\n\nDu kan også sjekke hvilke filer som ligger i mappen du jobber fra i R med funksjonen list.files()\n\n\n\nDobbeltsjekk koden du skriver i RStudio, sjekk for skrivefeil, parenteser og hermetegn, og at filnavnet er det samme som du har lagret filen som.\nBruk gjerne tab for å finne frem filen din for å unngå problemer med skrivefeil. Still markøren i hermetegnene i koden for å laste inn data og trykk på tab-knappen (hvilken knapp det er kan du google) for å liste opp mapper og filer i working directory/prosjektmappen din. Om datafilen er lagret i working directory/prosjektmappen så kommer den opp i en liste som vist på bildet under.\n\n\n\n\n\nHer er de ulike kodene for å laste inn filtyper. Der det står “navn” er navnet dere gir objektet, dette finner dere på selv. Der det står “file” skal dere sette inn filnavnet. Altså det filen heter i mappen dere lagret den i.\n\n\n\ninstall.packages(\"readxl\")\nlibrary(readxl)\n\nnavn <- read_excel(\"file\")\n\n\n\n\n\nnavn <- read.csv(\"file\")  \nnavn <- read.csv2(\"file\")\n\n\n\n\n\nload(\"file\")\n# Merk at her gir du ikke datasettet et eget navn\n\n\n\n\n\ninstall.packages(\"haven\")\nlibrary(haven)\n\nnavn <- read_dta(\"file\")\n\n\n\n\n\ninstall.packages(\"haven\")\nlibrary(haven)\n\nnavn <- read_sav(\"file\")\n\nVær obs på at variabler som egentlig er faktorer kan bli lest som numeriske ved bruk av haven. Derfor er det ekstra viktig å sjekke kodebok og/eller labels.\nHvis dere har fulgt stegene over, men likevel ikke får lastet inn datasettet:\n\nSjekk om pakkene du har installert er oppdatert.\n\nFor å undersøke om noen av pakkene trenger en oppdatering, kan dere trykke på ‘tools’ og ‘check for package updates’.\nEller kjøre funksjonen update.packages(ask = FALSE)\n\nHvis du har Mac, sjekk at maskinen din er oppdatert.\n\nEr du usikker på hvordan så se på Apple sine support-sider\n\nSjekk at du har riktig versjon av R og Rstudio for maskinen din\n\nEr du usikker så sjekk installasjonsveiledningen\n\n\nHvis dere har gått gjennom alle stegene, og likevel ikke får lastet inn datasettene så er neste steg å gå innom kodekafé for å få hjelp.\n\n\n\n\nFor å undersøke om tidyverse er installert kan dere kjøre koden under. Du skal få opp et plot nederst til høyre i RStudio når du kjører koden:\n\n# Install.packages er ikke nødvendig å kjøre om du allerede har installert pakken\ninstall.packages(\"tidyverse\") \nlibrary(tidyverse)\ndata <- data.frame(x = c(1,1,1,2,2,3,4,4,5))\nggplot(data = data, aes(x = x)) +\n  geom_bar()\n\nPlottet skal se omtrent slik ut:"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STV1020",
    "section": "",
    "text": "👋 Velkommen til R-seminarer i STV1020! 👋\nI denne lille notatboka finner du litt informasjon om praktisk ting og tang. Det kan være lurt å se over de forskjellige sidene i venstremargen:\n\nIntroduksjon (det er der du er nå)\nInstallasjonsguide for R\nGuide for å laste inn datasett i R\nGuide for RStudio Workbench\nInformasjon om R-prøven\n\n\n\nHer kommer litt informasjon om R-seminarene. I STV1020 har vi 6 seminarer der vi går gjennom grunnleggende funksjoner og måter å jobbe med R på. Tema for seminarene er:\n\nGrunnleggende R – kalkulator, indeksering, objekter, osv\nData – laste inn, lage deskriptiv statistikk og visualisering\nDatamanipulering – omkoding, tabeller, visualisering\nBivariate sammenhenger – korrelasjon, krysstabulering og visualisering\nBivariat regresjon – OLS\nMultivariat regresjon – OLS\n\nDet er mye å sette seg inn i når man starter helt fra bunn, men å bruke litt innsats på R nå, kan gi gevinster senere. Mange ender opp med å skrive kvantitative oppgaver i andre kurs eller bacheloroppgave, mens andre kan få bruk for kunnskapen i jobbsammenheng. På kort sikt har vi sett at å jobbe godt med R i STV1020 også gjør læringen i resten av kurset noe mer lettfattelig.\nR-seminarene blir etterfulgt av en digital prøve [[DATO ikke satt]] som du må bestå for å kunne gå opp til eksamen i STV1020. Dersom du ikke består på første forsøk så får du et nytt forsøk [[DATO ikke satt]]. Man kan enten bruke egen laptop (anbefalt om mulig) eller en stasjonær UiO-PC (alle maskiner på Eilert Sundt skal ha R og RStudio installert) når man skal bruke R.\n\n\n\nFør første seminar så forventer vi:\n\n💾 At du har lastet ned og installert R og Rstudio før første seminar. Følg gjerne installasjonsguiden på denne siden. 💻\n📈 At du har lest gjennom guide for innlasting av datasett 📉\n\nUnder seminarrekka forventer vi:\n\n👩‍🎓 At du møter opp på seminar. 👨‍🎓\n📚 At du jobber med å løse oppgaver mellom seminarene. 📚\n\nDette er viktig for at seminarene skal gå så smidig som mulig og for at dere skal få læringsutbytte av å delta. For noen kan R virke skummelt ved første øyekast, men erfaringsmessig så går dette veldig fint så lenge du legger ned litt innsats underveis 🎉 🥳 🎉\n\n\n\n\nCoffee & Coding\nØve deg på R direkte relatert til STV1020 i denne tutorialen.\nBli med i facebookgruppen R for statsvitenskap ved UiO.\nDiscord server for STV\nR-workbench for UiO-brukere\nRStudio Keyboard Shortcuts for Windows, Linux and Mac hjelper deg å kode raskere.\nStack overflow er et forum hvor folk stiller spørsmål og får hjelp til ulike utfordringer med R. Om du lurer på noe så vil du som regel finne svar her.\nRstudio community forum er litt i samme gate som Stack overflow.\nUsing projects gir en introduksjon til hvordan dere kan bruke prosjekter i Rstudio.\nSe et forslag til mappestruktur.\nThe tidyverse style guide for R inneholder mange tips for å skrive forståelig og god kode.\nR for Data Science er en veldig god bok for dere som vil fordype dere videre.\nRStudio Cheatsheets oppsummerer pakker eller oppgaver i R som for eksempel ggplot2. Gevinsten i disse juksearkene er størst når en har litt forståelse for hva pakken gjør.\nOslo UseR! group og R-Ladies Oslo arrangerer jevnlig interessante foredrag og workshops om R."
  },
  {
    "objectID": "installasjon.html",
    "href": "installasjon.html",
    "title": "STV1020",
    "section": "",
    "text": "Du må installere R og Rstudio før første seminar. Dersom du allerede har installert R og Rstudio så er det fint om du oppdaterer til siste versjon før seminar. Om alle har samme versjon så vil seminarene gå mye smidigere.\nDersom du trenger hjelp eller har problemer med installasjon/oppdatering så kan du komme på ☕ kodekafé ☕.\nHar du R og Rstudio installert?\n\nJa - følg instruksjonene under “Hvordan oppdatere R og Rstudio”.\nNei - følg instruksjonene under “Hvordan installere R og Rstudio”.\n\n\n\n\n💻 Windows 💻\n\nÅpne en nettleser og gå til www.r-project.org.\nKlikk på “download R” lenken. Den er i første avsnitt under “Getting started”.\nVelg CRAN location. Her burde du gå for Norway. Klikk på lenken.\n\nKlikk på “Download R for Windows” på toppen av siden.\nKlikk på “install R for the first time”.\nKlikk på “Download R for Windows” og lagre filen på maskinen din. Når nedlastningen er ferdig så åpner du .exe-filen og følger installasjonsveiledningen.\nNå kan du laste ned Rstudio.\n\n🍎 Mac 🍎\n\nÅpne en nettleser og gå til www.r-project.org.\nKlikk på “download R” lenken. Den finner du i første avsnitt under “Getting started”.\nVelg CRAN location. Her burde du gå for Norway. Klikk på lenken.\nKlikk på “Download R for (Mac) OS X” på toppen av siden. Du må lese det som står på siden du kommer til nå nøye dersom du har Mac.\nVelg den R-versjonen som passer den operativsystemversjonen du har. Om du har en eldre MacBook så er det viktig at du klikker på riktig lenke. Er du usikker på hvilken macOS-versjon du har så kan du klikke på eplet i venstre hjørne og velge “about this mac”. Der skal det stå macOS etterfulgt av navnet på versjonen.\nKlikk på lenken som matcher din versjon og lagre filen på maskinen. Når nedlastningen er ferdig så åpner du filen og følger installasjonsveiledningen.\nNå kan du laste ned Rstudio.\n\n🐧 Linux (Ubuntu 20.04+) 🐧\n\nInstallere dependencies:\n\nsudo apt install dirmngr gnupg apt-transport-https ca-certificates software-properties-common\n\nLegge til CRAN i listen over repositories:\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9`\nsudo add-apt-repository 'deb https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/'\n\nInstallere R:\n\nsudo apt install r-base r-base-dev\n\nSjekk om det virker:\n\nR --version\n\n\n\n\n\n\nGå til www.rstudio.com.\nTrykk på “Download”.\nTrykk “Download” knappen under gratisversjonen av Rstudio Desktop.\nFinn den versjonen som er anbefalt for operativsystemet ditt. Klikk på lenken i kolonnen “Download” for å laste ned installasjonsfilen.\nKjør filen og følg installasjonsveiledning.\n\nNå er du klar for første R-seminar!\n\n\n\nSeminarene går smidigere om alle bruker samme versjon av R. Dersom du har R og Rstudio installert fra før så kan du følge denne oppskriften for å sjekke hvilken versjon du har og eventuelt oppdatere dersom nødvendig.\n\n\n\nÅpne Rstudio. Øverst i konsoll så vil du se “session info”. Den første linjen forteller deg hvilken R versjon du bruker. Alternativt så kan du kjøre koden R.version.string for å printe R versjonen.\nHar du R versjon 4.2.2 installert?\n\nNei - følg instruksjonene for å “Oppdatere R og Rstudio”\nJa - supert! Du er klar for første R-seminar!\n\n\n\n\n💻 Windows 💻\nFor å oppdatere R på en Windows maskin så kan du prøve å bruke pakken installr.\n\nInstaller og last inn installr: skriv inn og kjør kodene install.packages(\"installr\") og library(installr)\nSkriv updateR() og kjør koden. Dette vil starte oppdateringsveilederen til R.\nFor å oppdatere Rstudio så åpner du Rstudio, velger Help > Check for Updates. Dette vil sende deg til Rstudios nettside hvor du kan laste ned den nyeste versjonen.\n\nNå er du klar for første R-seminar!\n🍎 Mac 🍎\nPå Mac så laster du selv ned og installerer den nyeste versjonen av R. Når du restarter Rstudio så vil den oppdaterte versjonen av R automatisk bli tatt i bruk. NB! Her er det snakk om den nyeste versjonen av R som er kompatibel med din Mac.\n\nFølg installasjonsveiledningen for MAC.\nFor å oppdatere Rstudio så åpner du Rstudio, velger Help > Check for Updates. Dette vil sende deg til Rstudios nettside hvor du kan laste ned den nyeste versjonen.\n\n🐧 Linux (Ubuntu 20.04+) 🐧\nR oppdateres som alt annet på Ubuntu: 1. sudo apt update 2. sudo apt upgrade\nRstudio oppdateres ved å følge veiledningen for installasjon av Rstudio over.\nNå er du klar for første R-seminar!"
  },
  {
    "objectID": "seminar/seminar1.html",
    "href": "seminar/seminar1.html",
    "title": "STV1020",
    "section": "",
    "text": "Gjennom 6 seminarganger skal vi nå gå igjennom alt fra hva R og Rstudio er og hvordan det fungerer, til å kjøre våre helt egne regresjonsanalyser. Vi gleder oss!\nFør hvert seminar kommer jeg til å legge ut lenke til fire ting på Canvas:\n\nR-script\nEn fil som forklarer litt mer av scriptet\nOppgavesett\nDatasett\n\nI denne boken vil dere finne noe tekst, noen figurer og tabeller, og noe kode. Innholdet reflekterer det vi har planlagt å gå gjennom på seminarene. Eksempelkoden i boka blir markert i blokker som har en egen mørk bakgrunn som her:\n\n# Dette er en kodeblokk.\n\nMens output av koden, der det er relevant, vil ha en lysegrå bakgrunn, som her:\n\n\n[1] \"Dette er output\"\n\n\nAlt som er skrevet i de mørke boksene kan dere kopiere inn i et R-script og kjøre for å se hva som skjer. Når det er en # (hash) foran en tekstlinje så betyr det at vi skriver en kommentar i scriptet. Når vi setter en # foran teksten så skjønner R at dette ikke er vanlig kode, men en kommentar. Resultatene av faktisk kode vil komme i et eget felt med grå bakgrunn under. Se for eksempel her:\n\n# Dette er en kommentar.  Nå skal vi gjøre et lite forsøk med noe\n# enkel matte!  For å kjøre koden setter dere musepekeren ved siden\n# av, og trykker ctrl+enter (cmd+return på Mac).\n100/2 + 4\n\n[1] 54"
  },
  {
    "objectID": "seminar/seminar1.html#hjelpefiler",
    "href": "seminar/seminar1.html#hjelpefiler",
    "title": "STV1020",
    "section": "Hjelpefiler",
    "text": "Hjelpefiler\nOfte når vi bruker R er vi usikre på hvordan forskjellige funksjoner fungerer. Da kan det være nyttig å lese hjelpefilene som forteller hva en funksjon gjør, og hvordan en skal bruke den. For å gjøre dette skriver du et spørsmålstegn før navnet på funksjonen.\n\n# La oss prøve dette med 'mean()' funksjonen, som logisk nok finner\n# gjennomsnitt:\n?mean\n\nDersom du får et svar som under her så tyder det på at du ikke har installert pakken funksjonen ligger i. Da kan du legge til et spørsmålstegn til og kjøre kode ??vif.\n\n?vif\n\nNo documentation for 'vif' in specified packages and libraries:\nyou could try '??vif'\n\n\nI hjelpefilen får vi en del informasjon om funksjonen. Funksjoner hjelper oss å hente ut informasjon fra data. Et eksempel på data kan være en tallrekke fra 1 til 10. Informasjonen vi ønsker å hente ut kan for eksempel være gjennomsnittet eller standardavviket. Vi kan bruke funksjoner til å få R til å hente ut denne informasjonen for oss. Alle funksjoner har til felles at de tar noe data, f.eks. tall, og skaper et resultat. I tilegg har noen argumenter som gjør at vi kan endre på hvordan funksjonen lager resultatet, hva vi får opp i consol og liknende.\nLeser vi hjelpefilen til funksjonen mean() så ser vi at den øverst gir en beskrivelse, hvor det står at den returnerer gjennomsnittet. Under der kommer argumentene den godtar; et argument (x) som definerer hvilke data vi vil hente ut informasjonen fra, et argument for å trimme dataene, altså fjerne noe, og na.rm argumentet som forteller R hvordan de skal håndtere missingverdier i beregningen. Under Value får vi en beskrivelse av hva funksjonen “produserer”, før til slutt et eksempel av hvordan den brukes i bunn.\nHjelpefilene er en flott måte å finne ut hva en funksjon gjør, og hvordan vi kan bruke den. Samtidig kan den ofte være litt kronglete å lese. Da hjelper det ofte å se på eksemplene som alltid er i bunn av teksten. Ellers beskriver også Healy hvordan man kan lese hjelpefilene i Appendix. Skulle det fortsatt være vanskelig er det viktig å huske at det finnes et stort miljø rundt R, og ofte er det mange som har opplevd samme problem som deg! Litt googling, og et søk på https://stackoverflow.com/ vil fort gi gode svar! Det er også mulig å spørre i facebookgruppen R for statsvitenskap ved UiO.\nUnder er et eksempel på hjelpefil for funksjonen head():\n\n\n\nHjelpefileksempel"
  },
  {
    "objectID": "seminar/seminar1.html#syntax-feil",
    "href": "seminar/seminar1.html#syntax-feil",
    "title": "STV1020",
    "section": "Syntax-feil",
    "text": "Syntax-feil\nNår vi skriver kode vil vi fort gjøre en del feil. Det er helt vanlig og noe som er helt uungåelig! Dere vil nok fort merke at jeg gjør en hel del feil når jeg skal vise dere i seminaret. En type feil kan likevel være grei å merke seg med en gang - mest fordi jeg gjør den hver gang jeg skal skrive noe kode. “Syntax-feil” er skrivefeil vi gjør når vi skriver kode. F.eks. kan det være å skrive men() istedenfor mean(), glemme å lukke en parantes sånn at vi skriver mean( og liknende. Noe av det fine med RStudio er at den markere sånne feil for oss!\n\n\n\nEksempler på feil kode og feilmeldinger\n\n\nBildet over viser eksempler på feilskrevet kode samt hvordan Rstudio markerer dette og hvilke feilmeldinger vi får når vi prøver å kjøre koden. Dere kan se at R har markert tre av fire linjenummer med en rød X. Dette er steder hvor RStudio mener jeg har gjort feil. Hvis jeg holder musepekeren over kryssene får jeg opp forslag til hva som kan være feilen. “Unexpected token ‘)’” betyr at RStudio mener det er en parantes der som ikke skulle vært der. I tilegg er det røde streker under de delene av koden som RStudio mener er feil. Jeg vil hevde, i hvertfall etter min egen erfaring, at 90 % av feilene vi gjør i R er enkle skrivefeil/syntax-feil som dette. Derfor er det veldig nyttig at RStudio viser det på denne måten!"
  },
  {
    "objectID": "seminar/seminar1.html#klasser",
    "href": "seminar/seminar1.html#klasser",
    "title": "STV1020",
    "section": "Klasser",
    "text": "Klasser\nSå langt har vi kun jobbet med tallverdier. Ofte har vi variabler som ikke er tall, men f.eks. tekst eller ordinalverdier. I R vil vi også se at visse funksjoner krever at dataene er i visse klasser. Hovedklassene vi kommer til å bruke er; numeric, character, logical og factor. Numeric er tall (logisk nok). De fleste mattefunksjoner krever at dataene er numeric. For å sjekke om noe er numeric kan vi bruke funksjonen is.numeric().\n\nis.numeric(en_til_hundre)\n\n[1] TRUE\n\n# Her ser vi at vi får opp 'TRUE' som betyr at en_til_hundre er et\n# numerisk objekt\n\nVi kan også bruke funksjonen class() til å hente ut informasjon om klassen:\n\nclass(en_til_hundre)\n\n[1] \"integer\"\n\n\nDere vil noen ganger se at det skilles mellom “numeric” og “integer”. Forskjellen er at integer kun kan inneholde heltall, mens numeric kan ha desimaler. Dette er svært sjeldent interessant for vår del.\nNår vi vil skrive tekst bruker vi klassen “character”. En tekststring må alltid ha hermetegn (““) rundt seg, men ellers definerer vi den som vanlig:\n\nTekst <- \"Hei, jeg elsker R! <3\"\n# Denne klassen kan inneholde tekst, men vil f.eks. ikke kunne brukes\n# til matte.\nmean(Tekst)\n\nWarning in mean.default(Tekst): argument is not numeric or logical: returning NA\n\n\n[1] NA\n\n\nHer ser dere at vi får en feilmelding, som sier at argumentet ikke er numerisk eller logisk. Funksjonen gir oss derfor resultatet NA, som betyr missing, altså at det ikke eksisterer et resultat.\nVi kan også kreve at et objekt skal ha en viss klasse. Det gjør vi med funksjonen as.\"klassenavn\" (bytt ut “klassenavn” med for eksempel numeric eller character). Det kan føre til noen uforventede resultater. La oss gjøre om objektet tall til character:\n\ntall_ch <- as.character(tall)\nmean(tall_ch)\n\nWarning in mean.default(tall_ch): argument is not numeric or logical: returning\nNA\n\n\n[1] NA\n\n\nGrunnen til at vi får en feilmelding her er fordi vi ikke kan ta gjenomsnittet av tekst. Om dere ser i environment står det også nå at tall er chr (charater) og det “” rundt alle tegnene.\nDen siste klassen vi kommer til å bruke ofte (men det finnes flere) er “factor.” En faktor er en variabel som kan ha flere forhåndsdefinerte nivåer og brukes ofte når vi skal kjøre statistiske modeller. En lett måte å forstå faktorer på er å tenke på dem som ordinale variabler, hvor vi kan vite rekkefølgen på nivåene men ikke avstanden, som for eksempel utdanningsnivåene barneskole, ungdomskole, videregående skole.\nFor å lage en faktor bruker vi funksjonen factor(). La oss først lage en faktor med ulike utdanningsnivåer:\n\n# Lager en faktorvariabel uten å sette nivåer\nskolenivaer <- factor(c(\"Barneskole\", \"Ungdomskole\", \"Videregaende\", \"Videregaende\",\n    \"Universitet\", \"Ungdomskole\", \"Universitet\"))\n\n# Printer alle verdiene\nskolenivaer\n\n[1] Barneskole   Ungdomskole  Videregaende Videregaende Universitet \n[6] Ungdomskole  Universitet \nLevels: Barneskole Ungdomskole Universitet Videregaende\n\n# Printer alle nivåene\nlevels(skolenivaer)\n\n[1] \"Barneskole\"   \"Ungdomskole\"  \"Universitet\"  \"Videregaende\"\n\n# Er det noe som skurrer her?\n\nI eksempelet her kan vi se at vi først definerer de forskjellige verdiene som er i variabelen. Vi har ikke spesifisert hvilken rekkefølge nivåene har. Når vi ikke gjør det så baserer R rekkefølgen på alfabetet. Derfor få vi rekkefølgen “Barneskole” “Ungdomskole” “Universitet” “Videregaende”. For å unngå dette så kan vi spesifisere faktornivåene:\n\n# Endrer faktornivåene\nskolenivaer <- factor(skolenivaer, levels = c(\"Barneskole\", \"Ungdomskole\",\n    \"Videregaende\", \"Universitet\"))\nskolenivaer\n\n[1] Barneskole   Ungdomskole  Videregaende Videregaende Universitet \n[6] Ungdomskole  Universitet \nLevels: Barneskole Ungdomskole Videregaende Universitet\n\nlevels(skolenivaer)\n\n[1] \"Barneskole\"   \"Ungdomskole\"  \"Videregaende\" \"Universitet\" \n\n\nI toppen her sa jeg at en vektor var et objekt som inneholdt elementer av samme klasse. Så langt har vi også holdt oss til det gjennom å kunne lage objekter med tekst eller tall. Hva skjer da om vi prøver å blande? Vi kan lage et objekt som inneholder både tekst og tall:\n\nteksttall <- c(1, 4, 0, 4, \"Bamse\", \"R\", \"R Seminarer er de BESTE seminarer\",\n    42, \"the answer\")\n\nclass(teksttall)\n\n[1] \"character\"\n\nmean(teksttall[1:4])\n\nWarning in mean.default(teksttall[1:4]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\nSom vi kan se er her klassen blitt character, også for tallene! Det er fordi at når vi definerer en vektor som inneholder flere klasser, blir det slått sammen til den klassen som har minst informasjon. Dette kalles “implicit coercion”, og rekkefølgen går: logical -> integer -> numeric -> complex -> character."
  },
  {
    "objectID": "seminar/seminar1.html#ulike-typer-vektorer-i-r",
    "href": "seminar/seminar1.html#ulike-typer-vektorer-i-r",
    "title": "STV1020",
    "section": "Ulike typer vektorer i R",
    "text": "Ulike typer vektorer i R\nDet finnes flere ulike objekter i R. Til nå har vi blitt introdusert for to av dem: datasett og vektorer. Hva slags objekt det er har noe å si for hva du kan gjøre med det. I tillegg finnes det ulike typer, eller klasser som vi kaller det, av vektorer. I tabellen under finner dere en grov inndeling av ulike typer vektorer i R (se også s. 42-47 i Lær deg R):\n\n\n\n\n\n\nAtomic vector\nList\n\n\n\n\nnumeric\nblanding\n\n\ninteger\n\n\n\ncharacter\n\n\n\nfactor\n\n\n\nlogical\n\n\n\n\nEn hyppig årsak til at en funksjon ikke fungerer, er at en vektor/variabel ikke er i det formatet vi forventet. Tabellen gir en oversikt over variabeltypene vi skal jobbe med. Atomic vector har kun verdier av en type, mens lister kan ha flere typer verdier, samt bestå av flere variabler.\nHvilket format tror du navn, antall og by har?\nDet kan vi sjekke med funksjonen class().\n\nclass(navnestat$navn)\n\n[1] \"character\"\n\nclass(navnestat$antall)\n\n[1] \"numeric\"\n\nclass(navnestat$by)\n\n[1] \"character\"\n\n\nSom dere ser er antall numeric, mens navn og by er character. Her er det hva objektet er lagret som som teller, ikke hvordan det ser ut i datasettet. Selv om noe ser ut som tall i datasettet så er det ikke sikkert det er registrert som tall av R. Heldigvis kan dette ofte løses ved hjelp av en funksjoner som as.numeric(), as.character() og as.factor().\n\n# Her lager vi en ny variabel antall2 der vi ber R lagre alder som\n# character\nnavnestat$antall2 <- as.character(navnestat$antall)\n\nOm vi ser på datasettet etter at vi har laget den nye variabelen så ser vi at alder og alder2 ser helt like ut. Begge fremstår som tall vi kan gjøre regneoperasjoner på, men bare en av dem er det. Prøv gjerne selv å kjøre funksjonen mean() som regner ut gjennomsnittet på alder2.\nHva skjer om du først omkoder alder til en faktor ved hjelp av as.factor() og så omkoder faktorvariabelen til en numerisk variabel med as.numeric()?"
  },
  {
    "objectID": "seminar/seminar1.html#logiske-tester",
    "href": "seminar/seminar1.html#logiske-tester",
    "title": "STV1020",
    "section": "Logiske tester",
    "text": "Logiske tester\nR kan evaluere logiske utsdagn og bedømme om de er ´TRUE´ eller ´FALSE´.\n\n1 == 2  # tester om 1 er lik 2\n\n[1] FALSE\n\n2 == 2  # tester om 2 er lik 2\n\n[1] TRUE\n\n\"Statsvitenskap\" == \"statsvitenskap\"  # Logiske tester kan også brukes på tekst\n\n[1] FALSE\n\n\"statsvitenskap\" == \"statsvitenskap\"  # R er imidlertid sensitivt til store og små bokstaver\n\n[1] TRUE\n\n1 <= 2  # Tester om 1 er mindre enn eller lik 2\n\n[1] TRUE\n\n1 >= 2  # Tester om 1 er større enn eller lik 2\n\n[1] FALSE\n\n1 != 2  # Tester om 1 er ulik 2\n\n[1] TRUE\n\n1 == 2 | 1 == 1  # Tester om en av de to påstandene 1 er lik 2 eller 1 er lik 1 er sanne\n\n[1] TRUE\n\n1 == 2 & 1 == 1  # Tester om begge de to påstandene 1 er lik 2 og 1 er lik 1 er sanne\n\n[1] FALSE\n\n\nOversikt over logiske operatorer:\n\n\n\nOperator\nBetydning\n\n\n\n\n==\ner lik\n\n\n<\nmindre enn\n\n\n>\nstørre enn\n\n\n<=\nmindre eller lik\n\n\n>=\nstørre eller lik\n\n\n!=\nikke lik\n\n\n!x\nikke x\n\n\n|\neller\n\n\n&\nog\n\n\n\nVi kommer til å bruke disse opearterne mye, spesielt når vi gjør endringer i datasett som å lage nye variabler. Det er derfor viktig at dere forstår hvordan disse fungerer. Den beste måten å få denne foreståelse på er å øve."
  },
  {
    "objectID": "seminar/seminar2.html",
    "href": "seminar/seminar2.html",
    "title": "STV1020",
    "section": "",
    "text": "På seminar to skal vi se på det følgende:\n\nOrganisering av arbeidet\nPakker\nLaste inn data\nOrganisering av data\nKlasser og målenivå\nDeskriptiv statistikk\nPlotting"
  },
  {
    "objectID": "seminar/seminar2.html#overskrifter-og-tekst",
    "href": "seminar/seminar2.html#overskrifter-og-tekst",
    "title": "STV1020",
    "section": "Overskrifter og tekst",
    "text": "Overskrifter og tekst\nHvordan man organiserer et R-script kommer an på hva man selv synes er mest oversiktlig, men det er viktig at man klarer å holde oversikt over hva man har kodet og forstår hva man har gjort når man kommer tilbake til et script.\nDet er lurt å lage overskrifter for å huske hva du tenker at koden din skal gjøre. Dersom du velger overskriftformatet “# Overskrift —-” så vil R automatisk gi deg muligheten til å gjemme koden under overskriften. Om du trykker på “Show document outline” i menylinjen til høyre over scriptet ditt kan du også få opp en innholdsfortegnelse basert på overskriftene dine.\n\n\n\nRyddig kode gjør det enklere for deg selv og andre når du står fast. Tegneserie fra XKCD: https://xkcd.com/1513/\n\n\nDet kan også være lurt å inkludere kommentarer i scriptet ditt som forklarer hva du gjør. Tekst som ikke skal leses av R skriver man etter emneknagg (#). Vi glemmer fort så det er en god idé å tenke at du skal kunne se tilbake på dette scriptet om et år igjen og skjønne hva du har gjort.\nTil sist så er det lurt å ikke skrive for mange tegn før du bytter linje. The tidyverse style guide anbefaler at en begrenser antall tegn til 80 per linje. R teller for hvor mange tegn du har per linje til venstre nedenfor scriptet ditt. Tidyverse sin stilguide inneholder også flere tips til hvordan man kan skrive lettleselig kode."
  },
  {
    "objectID": "seminar/seminar2.html#kategorisk",
    "href": "seminar/seminar2.html#kategorisk",
    "title": "STV1020",
    "section": "Kategorisk",
    "text": "Kategorisk\nNår variabler er kategoriske så kan egenskapen deles i to eller flere gjensidig utelukkende kategorier. I ESS datasettet vårt er variabelen “vote” kategorisk; man har enten stemt, ikke stemt, eller så er man ikke berettiget til å stemme. Dette kan vi se i utklippet fra kodeboken.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen vote\n\n\nVi kan sjekke hvilken klasse variabelen har ved hjelp av class()\n\nclass(ess_subset$vote)\n\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n\n\nHer får vi opp klassene haven_labelled, vctrs_vctr og double. haven_labelled indikerer at datasettet også inneholder informasjon om verdilabels, mens double betyr at variabelen nå er lagret som en numerisk variabel. På variabler med kategorisk eller ordinalt målenivå såkan vi bruke funksjonen table() til å få oversikt over verdiene:\n\ntable(ess_subset$vote)\n\n\n   1    2    3 \n1156  124  125 \n\n\nSom vi ser her så fremstår variabelen som om den er kontinuerlig/numerisk med tallverdier, men vi har lest kodeboken og vet at den er kategorisk. Dersom vi vil endre klassen på variabelen til en faktor så det samsvarer bedre med målenivået så kan vi bruke funksjonen as_factor() for å opprette en ny variabel:\n\n# Lager en ny variabel i datasettet som heter vote_factor\ness_subset$vote_factor <- as_factor(ess_subset$vote)\n\nVi kan nå se nærmere på hvilke verdier den nye variabelen vote_factor tar ved hjelp av levels() og klassen ved hjelp av class():\n\n# Sjekker faktornivåene:\nlevels(ess_subset$vote_factor)\n\n[1] \"Yes\"                  \"No\"                   \"Not eligible to vote\"\n[4] \"Don't know\"           \"Refusal\"              \"No answer\"           \n\n# Sjekker klasse:\nclass(ess_subset$vote_factor)\n\n[1] \"factor\"\n\n\nNå samsvarer variabelens verdier (Yes, No, osv.) og klasse (factor) bedre med det faktiske målenivået til variabelen (kategorisk).\nMerk at bruken av as_factor() er forbehold datasett som inneholder labels sånn som ESS-datasettet vi jobber med i dag. Vi skal jobbe mer med omkoding av variabler senere."
  },
  {
    "objectID": "seminar/seminar2.html#ordinalnivå",
    "href": "seminar/seminar2.html#ordinalnivå",
    "title": "STV1020",
    "section": "Ordinalnivå",
    "text": "Ordinalnivå\nNår variabler er på ordinalnivå kan de deles i to eller flere gjensidig utelukkende kategorier som kan rangeres, men vi kan ikke si noe om avstanden mellom verdiene og en enhets økning har ikke samme betydning. I ESS datasettet vår så er variabelen interest et eksempel på en variabel på ordinalnivå; i utdraget fra kodeboken ser vi at man kan være ikke interessert, lite interessert, ganske interessert, eller veldig interessert i politikk.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen interest (opprinnelig navn polintr)\n\n\nVi kan sjekke klasse til denne variabelen også:\n\nclass(ess_subset$interest)\n\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n\n\nSom vi ser er også denne variabelen også registrert som klassene haven_labelled, vctrs_vctr og double av R. Dersom vi vil bruke denne variabelen som en kategorisk variabel så kan vi igjen bruke as_factor for å få variabelens klasse til å samsvare med målenivået:\n\ness_subset$interest_factor <- as_factor(ess_subset$interest)\n\nVi sjekker faktornivåer og klasse igjen:\n\n# Sjekker faktornivåene:\nlevels(ess_subset$interest_factor)\n\n[1] \"Very interested\"       \"Quite interested\"      \"Hardly interested\"    \n[4] \"Not at all interested\" \"Don't know\"            \"Refusal\"              \n[7] \"No answer\"            \n\n# Sjekker klasse:\nclass(ess_subset$interest_factor)\n\n[1] \"factor\"\n\n\nDette ser også fint ut. Som dere vet fra forelesning så er behandler man ofte variabler på ordinalnivå som enten kategorisk eller kontinuerlig målenivå. Dersom vi ville beholdt denne som en kontinuerlig variabel så hadde vi ikke trengt å omkode den ved hjelp av as_factor()."
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlig",
    "href": "seminar/seminar2.html#kontinuerlig",
    "title": "STV1020",
    "section": "Kontinuerlig",
    "text": "Kontinuerlig\nKontinuerlige variabler kan rangeres, har samme avstand mellom alle verdier og en enhets økning betyr alltid det samme. Her er det altså snakk om variabler med faktiske tallverdier. I ESS datasettet vårt så er variabelen “news” kontinuerlig. Som vi kan se i utdraget fra kodeboken så måler variabelen hvor mange minutter man bruker på nyheter hver dag. Det er et minutts avstand mellom hver verdi, og en økning på en enhet vil alltid bety en økning på et minutt.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen news (opprinnelig navn nwspol)\n\n\nVi kan sjekke klassen her også:\n\nclass(ess_subset$news)\n\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n\nis.numeric(ess_subset$news)\n\n[1] TRUE\n\n\nDenne variabelen er double og skal være det så her er alt i orden.\nJeg vil oppfordre dere til å være obs og alltid sjekke at klassen på en variabel dere skal bruke stemmer overens med målenivået. I mange datasett får kategoriske og ordinale variabler ofte tall istedenfor kategorinavn som verdier og lastes inn som klassen numeric. Dette gjør at kategoriske variabler kan fremstå som at de har et høyere målenivå enn de faktisk har i R. Derfor er det alltid viktig å også sjekke kodeboken for å se hvilket målenivå variabelen faktisk har. Det kommer ikke til å stå “denne variabelen har kategorisk målenivå” så dere må gjøre en selvstendig vurdering basert på hvilke verdier variabelen har."
  },
  {
    "objectID": "seminar/seminar2.html#kategoriske-variabler",
    "href": "seminar/seminar2.html#kategoriske-variabler",
    "title": "STV1020",
    "section": "Kategoriske variabler",
    "text": "Kategoriske variabler\nR har ingen innebygd funksjon for å finne modusverdien. Ved å søke på internett så finner du fort mange ulike funksjoner du kan bruke, men for å gjøre det enkelt bruker vi bare table(). Funksjonen table() gir oss en frekvenstabell, mens prop.table gjør om frekvenstabellen til andeler. ESS datasettet mangler data for noen observasjoner. Ved å ta med useNA = \"always\" i table() så får vi også denne informasjonen i tabellen:\n\ntable(ess_subset$vote, useNA = \"always\")\n\n\n   1    2    3 <NA> \n1156  124  125    1 \n\nprop.table(table(ess_subset$vote))\n\n\n         1          2          3 \n0.82277580 0.08825623 0.08896797 \n\nprop.table(table(ess_subset$vote, useNA = \"always\"))\n\n\n           1            2            3         <NA> \n0.8221906117 0.0881934566 0.0889046942 0.0007112376"
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlige-variabler",
    "href": "seminar/seminar2.html#kontinuerlige-variabler",
    "title": "STV1020",
    "section": "Kontinuerlige variabler",
    "text": "Kontinuerlige variabler\n\n# Finner minimumsverdi (det laveste antall minutter brukt\n# på nyheter)\nmin(ess_subset$news, na.rm = TRUE)  # na.rm = TRUE sier at missing skal droppes i beregningen\n\n<labelled<double>[1]>: News about politics and current affairs, watching, reading or listening, in min\n[1] 0\n\nLabels:\n value      label\n NA(b)    Refusal\n NA(c) Don't know\n NA(d)  No answer\n\n# Finner maksimumsveriden (den høyeste antall minutter\n# brukt på nyheter)\nmax(ess_subset$news, na.rm = TRUE)\n\n<labelled<double>[1]>: News about politics and current affairs, watching, reading or listening, in min\n[1] 1109\n\nLabels:\n value      label\n NA(b)    Refusal\n NA(c) Don't know\n NA(d)  No answer\n\n# Finner gjennomsnittlig antall minutter\nmean(ess_subset$news, na.rm = TRUE)\n\n[1] 104.1006\n\n# Finner median\nmedian(ess_subset$news, na.rm = TRUE)\n\n[1] 60\n\n# Finner standardavviket\nsd(ess_subset$news, na.rm = TRUE)\n\n[1] 155.5571\n\n# Finner varians\nvar(ess_subset$news, na.rm = TRUE)\n\n[1] 24198.01\n\n# Finner kvantilverdiene\nquantile(ess_subset$news, na.rm = TRUE)\n\n  0%  25%  50%  75% 100% \n   0   30   60  120 1109 \n\n# Finner forskjellig deskriptiv statistikk for en variabel\nsummary(ess_subset$news)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    0.0    30.0    60.0   104.1   120.0  1109.0      34"
  },
  {
    "objectID": "seminar/seminar2.html#kategoriske-variabeler",
    "href": "seminar/seminar2.html#kategoriske-variabeler",
    "title": "STV1020",
    "section": "Kategoriske variabeler",
    "text": "Kategoriske variabeler\n\nSøylediagram og kakediagram med en variabel\nHvordan kan vi visualisere hvordan fordelingen av politisk interesse er? Her kan vi bruke geom_bar til å lage et søylediagram (bar chart). Et søylediagram viser antall observasjoner av hver verdi. Vi bruker her den variabelen vi lagde tidligere med “riktig” målenivå.\n\nggplot(data = ess_subset, aes(x = interest_factor)) + geom_bar() +\n    theme(axis.text.x = element_text(angle = 60, hjust = 1))\n\n\nDersom vi ikke ønsker å gi missingverdiene (NA) en egen søyle så kan vi bruke filter() til å fjerne disse:\n\nggplot(data = ess_subset %>%\n    filter(!is.na(interest_factor)), aes(x = interest_factor)) +\n    geom_bar() + theme(axis.text.x = element_text(angle = 60,\n    hjust = 1))\n\n\nEt alternativ til søylediagram er kakediagram (pie chart):\n\nggplot(ess_subset, aes(x = \"\", y = interest, fill = interest_factor)) +\n    geom_bar(stat = \"identity\", width = 1) + coord_polar(\"y\",\n    start = 0) + theme_void() + scale_fill_grey()\n\n\n\n\nSøylediagram med to variabler\nHvor mange innenfor hvert nivå av politisk interesse stemte? Vi kan bruke geom_bar() igjen, men vi sier at vi også vil se fordelingen av hvordan respondentene stemte innenfor hvert nivå av politisk interesse med (aes(fill = vote)). Så sier vi at vi vil at det skal være en søyle for de ulike alternativene for vote med position = \"dodge\".\n\nggplot(data = ess_subset, aes(x = interest_factor)) + geom_bar(aes(fill = vote_factor),\n    position = \"dodge\") + theme(axis.text.x = element_text(angle = 60,\n    hjust = 1))"
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlige-variabler-1",
    "href": "seminar/seminar2.html#kontinuerlige-variabler-1",
    "title": "STV1020",
    "section": "Kontinuerlige variabler",
    "text": "Kontinuerlige variabler\n\nHistogram\nHvordan fordeler respondentenes alder og tiden de bruker på nyheter seg? Disse variablene er kontinuerlige, så vi kan bruke geom_histogram for å lage et histogram. Her gjør jeg det med variabelen news.\n\nggplot(data = ess_subset, aes(x = news)) + geom_histogram(bins = 5) +\n    ggtitle(\"Histogram med fem søyler (bins) og frekvens\")\n\n\n\nggplot(data = ess_subset, aes(x = news)) + geom_histogram(binwidth = 10) +\n    ggtitle(\"Histogram med søylebredde (binwidth) på 10 og frekvens\")\n\n\nEt histogram viser hvor mange enheter det er i hver kategori. Vi kan enten spesifisere hvor mange søyler vi vil ha (bins) eller hvor stor hver søyle skal være (bindwidth). Vi kan også velge å plotte density fremfor count. Da får vi histogrammer tilsvarende figur 6.5 i Kellsted og Whitten:\n\nggplot(data = ess_subset, aes(x = news, y = ..density..)) + geom_histogram(bins = 5) +\n    ggtitle(\"Histogram med fem søyler (bins) og density\")\n\n\n\nggplot(data = ess_subset, aes(x = news, y = ..density..)) + geom_histogram(binwidth = 10) +\n    ggtitle(\"Histogram med søylebredde (binwidth) 10 og density\")\n\n\n\n\nBoksplott\nVi kan lage et boksplott med geom_boxplot. Et boksplott viser hvordan en kontinuerlig variabel er fordelt. Boksen representerer spennet til første (25 % ) og tredje (75 %) kvartil, mens streken midt i boksen viser andre (50 %) kvartil (også kjent som median). For å finne kvartilene så ordner vi observasjonene i stigende rekkefølge og deler dem inn i fire deler med like mange observasjoner i hver. Første kvartil angir grensen mellom første og andre fjerdedel. Det betyr at 25 % av observasjonene har en verdi som er lavere enn verdien til første kvartil, mens 75 % har en verdi som er høyere. Tilsvarende utgjøre tredje kvartil grensen mellom andre og tredje fjerdedel, og vi kan si at 75 % av observasjonene har en verdi som er lavere enn verdiene til tredje kvaritl, mens 25 % har en verdi som er høyere.\nPrikkene i grafen angir uteliggere. Uteliggere er observasjoner som har enten veldig høye eller veldig lave verdier relativt til de andre observasjonene. I R beregnes disse utfra kvartilbredden. Kvartilbredden er differansen mellom tredje og første kvartil. Alle observasjoner som er lavere enn første kvartil minus 1,5 ganger kvartilbredden eller høyere enn tredje kvartil pluss 1,5 ganger kvartilbredden regnes som uteliggere.\n\nggplot(data = ess_subset, aes(x = news)) + geom_boxplot() + theme_minimal()\n\n\nHvis dere vil utforske hvordan man kan tilpasse de ulike diagrammene vi har sett på og mange andre, kan denne siden være nyttig: https://www.r-graph-gallery.com/index.html"
  },
  {
    "objectID": "seminar/seminar3.html",
    "href": "seminar/seminar3.html",
    "title": "STV1020",
    "section": "",
    "text": "På dette seminaret skal vi gjennom: 1. Repetisjon: om laste inn data 2. Omkoding av variabler 4. Subsetting av datasett 5. Plotting: Intro til ggplot2 6. Ulike typer plott 7. Lagring av plott"
  },
  {
    "objectID": "seminar/seminar3.html#matematisk-omkoding",
    "href": "seminar/seminar3.html#matematisk-omkoding",
    "title": "STV1020",
    "section": "Matematisk omkoding",
    "text": "Matematisk omkoding\nFørst skal vi lære å kode om variablene ved å bruke matematiske omkoding. For å vise dette bruker jeg variabelem year. Ved hjelp av summary() så finner jeg ut at den laveste verdien på variabelen er året 1952. Det er året observasjonen ble gjort. Jeg vil gjøre dette året til år null, mens de andre verdiene på variablen skal bli hvor mange år etter år null ble observasjonen gjort.\n\n# Sjekker summary for opprinnelige variabel\nsummary(data$year)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1952    1966    1980    1980    1993    2007 \n\n# spennet er 2007-1952, dvs. 55 år\n2007 - 1952\n\n[1] 55\n\n# Legger til ny variabel i datasettet\ndata$year_1952 <- data$year - 1952\n\n# Sjekker summary for ny variabel\nsummary(data$year_1952)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   13.75   27.50   27.50   41.25   55.00 \n\n\nSå undersøker jeg om omkodingen er blitt gjort riktig ved å bruke funksjonen table(). Jeg gjør dette på to måter.\n\n# Lager en tabell med opprinnelig og ny variabel:\ntable(data$year_1952, data$year, useNA = \"always\")\n\n      \n       1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 <NA>\n  0     142    0    0    0    0    0    0    0    0    0    0    0    0\n  5       0  142    0    0    0    0    0    0    0    0    0    0    0\n  10      0    0  142    0    0    0    0    0    0    0    0    0    0\n  15      0    0    0  142    0    0    0    0    0    0    0    0    0\n  20      0    0    0    0  142    0    0    0    0    0    0    0    0\n  25      0    0    0    0    0  142    0    0    0    0    0    0    0\n  30      0    0    0    0    0    0  142    0    0    0    0    0    0\n  35      0    0    0    0    0    0    0  142    0    0    0    0    0\n  40      0    0    0    0    0    0    0    0  142    0    0    0    0\n  45      0    0    0    0    0    0    0    0    0  142    0    0    0\n  50      0    0    0    0    0    0    0    0    0    0  142    0    0\n  55      0    0    0    0    0    0    0    0    0    0    0  142    0\n  <NA>    0    0    0    0    0    0    0    0    0    0    0    0    0\n\n# Lager en tabell med en logisk test:\ntable((data$year_1952 + 1952) == data$year, useNA = \"always\")\n\n\nTRUE <NA> \n1704    0 \n\n\nJeg kan også endre retningen på verdienes ved matematisk omkoding. Da ganger jeg variablene med (-1) og plusser på antall verdier variablene har. Nå blir 2007 år null.\n\n# Endrer retning på variabelen:\ndata$year_2007 <- data$year_1952 * (-1) + 55\n\n# Sjekker at det ble riktig med table():\ntable(data$year_1952, data$year_2007, useNA = \"always\")\n\n      \n         0   5  10  15  20  25  30  35  40  45  50  55 <NA>\n  0      0   0   0   0   0   0   0   0   0   0   0 142    0\n  5      0   0   0   0   0   0   0   0   0   0 142   0    0\n  10     0   0   0   0   0   0   0   0   0 142   0   0    0\n  15     0   0   0   0   0   0   0   0 142   0   0   0    0\n  20     0   0   0   0   0   0   0 142   0   0   0   0    0\n  25     0   0   0   0   0   0 142   0   0   0   0   0    0\n  30     0   0   0   0   0 142   0   0   0   0   0   0    0\n  35     0   0   0   0 142   0   0   0   0   0   0   0    0\n  40     0   0   0 142   0   0   0   0   0   0   0   0    0\n  45     0   0 142   0   0   0   0   0   0   0   0   0    0\n  50     0 142   0   0   0   0   0   0   0   0   0   0    0\n  55   142   0   0   0   0   0   0   0   0   0   0   0    0\n  <NA>   0   0   0   0   0   0   0   0   0   0   0   0    0"
  },
  {
    "objectID": "seminar/seminar3.html#omkoding-med-ifelse",
    "href": "seminar/seminar3.html#omkoding-med-ifelse",
    "title": "STV1020",
    "section": "Omkoding med ifelse()",
    "text": "Omkoding med ifelse()\nDen funksjonen jeg bruker mest til omkoding, er ifelse(). Funksjonen kan brukes på numeriske og kategoriske variabler. Syntaksen til denne funksjonen kan forklares som følger:\n\ndata$nyvar <- ifelse(test = my_data$my.variabel == \"some logical condition\",\n    yes = \"what to return if 'some condition' is TRUE\", no = \"what to return if 'some condition' is FALSE\")\n\nifelse() kan for eksempel bruker til å lage en ny variabel som tar verdien 1 om observasjonen har en verdi som er større enn gjennomsnittet og null ellers. Gjennomsnittet finner du ved å bruke funksjonen mean(). Under fyller jeg inn betingelsen (condition), hvilken verdi ny variabel skal dersom betingelsen er oppfylt (yes) og hvilken verdi ny variabel skal ha dersom betingelsen ikke er oppfylt (no). Vanligvis vil vi ikke skrive test =, yes = og no =, men jeg har tatt det med her for å gjøre det lettere å koble de to:\n\ndata$lifeExp_2 <- ifelse(test = data$lifeExp > mean(data$lifeExp,\n    na.rm = TRUE), yes = 1, no = 0)\n\nJeg bruker en kombinasjon av en tabell og en logisk test (se forklaringer fra første seminar om logiske tester) for å sjekke at det ble riktig:\n\ntable(data$lifeExp_2, data$lifeExp > mean(data$lifeExp, na.rm = TRUE),\n    useNA = \"always\")\n\n      \n       FALSE TRUE <NA>\n  0      809    0    0\n  1        0  895    0\n  <NA>     0    0    0"
  },
  {
    "objectID": "seminar/seminar3.html#omkoding-med-recode",
    "href": "seminar/seminar3.html#omkoding-med-recode",
    "title": "STV1020",
    "section": "Omkoding med recode()",
    "text": "Omkoding med recode()\nDersom vi vil omkode en variabel med flere variabler så kan vi gjøre det med flere ifelse() nøstet i hverandre. Det kan imidlertid bli veldig mye kode. Et alternativ er å kombinere mutate() og recode(). mutate() er en funksjon i tidyverse vi bruker for å lage nye variabler. recode() er også en del av tidyverse og den brukes til å endre verdier på variabler. Syntaksen til kombinasjonen av mutate() og recode() er:\n\nmutate(nyvariabel = recode(gammelvariabel, verdi1 = nyverdi1,\n    verdi2 = nyverdi2))\n\nI dette eksempelet skal vi lage en ny variabel continent2 med tallverdier i steden for kontinentnavn. Ettersom funksjonen vi skal bruker ligger i pakken tidyverse så må vi aller først laste inn pakken med library()\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   1.0.1 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\ndata <- data %>%\n    mutate(continent2 = recode(continent, Africa = 1, Americas = 2,\n        Asia = 3, Europe = 4, Oceania = 5))\n\nVi sjekker med en tabell at det ble riktig:\n\ntable(data$continent, data$continent2, useNA = \"always\")\n\n          \n             1   2   3   4   5 <NA>\n  Africa   624   0   0   0   0    0\n  Americas   0 300   0   0   0    0\n  Asia       0   0 396   0   0    0\n  Europe     0   0   0 360   0    0\n  Oceania    0   0   0   0  24    0\n  <NA>       0   0   0   0   0    0"
  },
  {
    "objectID": "seminar/seminar3.html#steg-1-fortell-ggplot-hvor-vi-vil-hente-data-fra",
    "href": "seminar/seminar3.html#steg-1-fortell-ggplot-hvor-vi-vil-hente-data-fra",
    "title": "STV1020",
    "section": "Steg 1: Fortell ggplot() hvor vi vil hente data fra",
    "text": "Steg 1: Fortell ggplot() hvor vi vil hente data fra\nSteg 1 er å fortelle ggplot hvor den skal hente data fra. Det gjør vi ved å spesifisere data = argumentet i funksjonen ggplot(). I vårt tilfelle heter datasettet data og vi skriver:\n\nggplot(data = data)\n\n\nHva skjer når vi kjører koden nå? Vi får et helt tomt plott. Mer info må til!"
  },
  {
    "objectID": "seminar/seminar3.html#steg-2-fortell-ggplot-hvilken-sammenheng-vi-vil-plotte",
    "href": "seminar/seminar3.html#steg-2-fortell-ggplot-hvilken-sammenheng-vi-vil-plotte",
    "title": "STV1020",
    "section": "Steg 2: Fortell ggplot hvilken sammenheng vi vil plotte",
    "text": "Steg 2: Fortell ggplot hvilken sammenheng vi vil plotte\nDet neste vi gjør er å fortelle ggplot hva vi vil måle på x- og y-aksen. Nå skal vi starte med et stolpediagram, der vi vil se hvor mange observasjoner det er i datasettet fordelt på de fem kontinentene. Da trenger vi bare å gi ggplot beskjed om at vi vil ha continent på x-aksen. Y-aksen vår blir automatisk til antall (count). Senere i dette seminaret skal vi se på et eksempel hvor vi gir informasjon om begge aksene. Inne i ggplot() hvor vi har fortalt hvilket datasett vi vil bruke, så legger vi til en mapping. aes() står for aestethics, og det vi gjør ved bruk av aes() er å fortelle ggplot hvilke variabler vi vil visualisere. Vi forteller ggplot at vi vil at variabelen continent skal vises på x-aksen.\n\nggplot(data = data, mapping = aes(x = continent))\n\n\nDet vi skriver i aes() kobler variabler til ting du ser i plottet. Det kan for eksempel være x- og y-verdier (x = variabelnavn, y = variabelnavn), farger (color = variabelnavn), former (shape = variabelnavn) eller størrelse (size = variabelnavn)."
  },
  {
    "objectID": "seminar/seminar3.html#steg-3-fortell-ggplot-hvordan-du-vil-illustrere-sammenhengen",
    "href": "seminar/seminar3.html#steg-3-fortell-ggplot-hvordan-du-vil-illustrere-sammenhengen",
    "title": "STV1020",
    "section": "Steg 3: Fortell ggplot hvordan du vil illustrere sammenhengen",
    "text": "Steg 3: Fortell ggplot hvordan du vil illustrere sammenhengen\nNår vi kjører koden, så ser vi at kontinentene er på plass, men vi får likevel ikke noe særlig informasjon fra plottet. Hva mangler? Vi må skrive hva slags plott vi vil lage. Vi vil lage et stolpediagram, og velger geom_bar(). Hvis du prøver å skrive inn geom_ vil du se at du får en hel rekke forslag til ulike plott. Flere av disse skal vi komme tilbake til.\n\nggplot(data = data, aes(x = continent)) + geom_bar()\n\n\nDa har vi fått opp et plott som viser observasjonene i datasettet fordelt på kontinenter. Vi kan dobbeltsjekke at dette ser riktig ut ved å lage et summary av variabelen.\n\nsummary(data$continent)\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n\n\nDet ser fint ut. Vi kan også legge inn andre typer av aestetics i mappingen. Her er det flere muligheter, som dere vil bli kjent med etter hvert. Én av dem er å bruke ulike farger for å gi informasjon. Hvis vi vil at hvert kontinent skal få sin egen farge, så kan vi gjøre det slik:\n\nggplot(data = data, aes(x = continent, fill = continent)) + geom_bar()"
  },
  {
    "objectID": "seminar/seminar3.html#steg-4-legg-til-geom_-etter-behov-en-etter-en.",
    "href": "seminar/seminar3.html#steg-4-legg-til-geom_-etter-behov-en-etter-en.",
    "title": "STV1020",
    "section": "Steg 4: Legg til geom_ etter behov en etter en.",
    "text": "Steg 4: Legg til geom_ etter behov en etter en.\nVi kan legge til flere geom_-elementer i plottet vårt ved å bruke +. Jeg kan for eksempel legge til en linje som indikerer gjennomsnittlig antall observasjoner per land. Da legger vi først til en variabel som angir antall observasjoner per land i datasettet. Dette gjør vi ved hjelp av funksjonen add_count():\n\ndata <- data %>%\n    add_count(continent)\n\nVi kan se i datasettet vårt at vi har fått en ny variabel n. Denne angir antall observasjoner per kontinent i datasettet vårt. For å legge til en linje som indikerer gjenomsnittlig antall observasjoner bruker vi geom_hline() (h for horisontal linje). I aes() gir vi ggplot informasjon om hvor denne linjen skal krysse y-aksen:\n\nggplot(data = data, aes(x = continent, fill = continent)) + geom_bar() +\n    geom_hline(aes(yintercept = mean(n)))"
  },
  {
    "objectID": "seminar/seminar3.html#steg-5-bruk-funksjoner-til-å-justere-skala-etiketter-tittel-o.l..",
    "href": "seminar/seminar3.html#steg-5-bruk-funksjoner-til-å-justere-skala-etiketter-tittel-o.l..",
    "title": "STV1020",
    "section": "Steg 5: Bruk funksjoner til å justere skala, etiketter, tittel o.l..",
    "text": "Steg 5: Bruk funksjoner til å justere skala, etiketter, tittel o.l..\nVi kan også endre teksten på x- og y-aksen, og gi plottet en tittel ved å legge til labs(), fjerne boksen med informasjon om farger og navn på høyre side ved hjelp av theme(legend.position = \"none\") og gjøre bakgrunnen litt penere med theme_bw():\n\nggplot(data, aes(x = continent, fill = continent)) + geom_bar() +\n    geom_hline(aes(yintercept = mean(n))) + labs(x = \"\", y = \"Antall land-år-observasjoner\",\n    title = \"Antall observasjoner per kontinent\", caption = \"Gjennomsnittlig antall observasjoner er gitt ved den horisontale linjen\") +\n    theme_bw() + theme(legend.position = \"none\")\n\n\nDa har vi gått gjennom det helt grunnleggende i ggplot. Dette er en pakke med veldig mange ulike muligheter, og man blir bedre kjent med de for hver gang man bruker den. Jeg anbefaler dere å prøve dere fram, og sjekke ut noen av ressursene som jeg linker til i bunnen av dokumentet. Kjør gjerne deler av plottet for å se hva de ulike linjene gjør, google dere frem osv."
  },
  {
    "objectID": "seminar/seminar3.html#histogrammer",
    "href": "seminar/seminar3.html#histogrammer",
    "title": "STV1020",
    "section": "Histogrammer",
    "text": "Histogrammer\nNår vi undersøker ulike plot kan vi skrive plot_le + i stedet for ggplot(data, aes(lifeExp)) + fordi sistnevne informasjon er lagret i førstnevnte objekt. Dette sparer oss for en del kode. For en kontinuerlig variabel så kan det være mer nyttig med et histogram, som lager stolper for intervaller:\n\nplot_le + geom_histogram()\n\n\nHvis vi ikke sier noe annet, så kommer ggplot til å velge hvor stort hvert intervall skal være. Vi kan sette hver stolpe til å være ett år bred ved å skrive inn binwidth = 1:\n\nplot_le + geom_histogram(binwidth = 1)\n\n\nHvis vi vil se hvordan dette fordeler seg på hvert kontinent, så kan vi legge inn fill:\n\nplot_le + geom_histogram(aes(fill = continent), binwidth = 1,\n    alpha = 0.5) + theme_bw()\n\n\nDette gir oss en viss oversikt over hvordan forventet levealder varierer mellom kontinentene, men hvis vi vil se næremere på dette så kan et boxplot for forventet levealder per kontinent være et bedre alternativ."
  },
  {
    "objectID": "seminar/seminar3.html#boxplot",
    "href": "seminar/seminar3.html#boxplot",
    "title": "STV1020",
    "section": "Boxplot",
    "text": "Boxplot\nfor å lage et boxplot så spesifiserer vi y-aksen ved hjelp av aes(y = continent) i geom_boxplot:\n\nplot_le + geom_boxplot(aes(y = continent))\n\n\nHer er et eksempel på hvor mye finere plottet kan bli med litt flere kodelinjer:\n\nplot_le + geom_boxplot(aes(y = continent)) + theme_bw() + labs(title = \"Boxplot for forventet levealder per kontinent\",\n    x = \"Forventet levealder\", y = \"\") + theme(legend.position = \"none\")"
  },
  {
    "objectID": "seminar/seminar3.html#density-plottettshetsplot",
    "href": "seminar/seminar3.html#density-plottettshetsplot",
    "title": "STV1020",
    "section": "Density plot/tettshetsplot",
    "text": "Density plot/tettshetsplot\nEn annen metode kan være å bruke et density plot/tetthetsplott:\n\nplot_le + geom_density()\n\n\nInne i parentesen til plottypen kan vi legge til spesifikasjoner om tykkelse på linja, farge osv.\n\nplot_le + geom_density(size = 1.5, fill = \"pink\", alpha = 0.3)\n\n\nHva skjer hvis vi endrer 1) alpha til 1 og 2) size til 0.5?\n\nplot_le + geom_density(size = 0.5, fill = \"pink\", alpha = 1)\n\n\nHvis du ønsker å separere plottene, slik at de ulike kontinentene ikke ligger over hverandre, men får hvert sitt plott, så kan du legge til en facet_wrap:\n\nplot_le + geom_density(size = 0.5, fill = \"pink\", alpha = 1) +\n    facet_wrap(vars(continent)) + theme_bw()"
  },
  {
    "objectID": "seminar/seminar3.html#spredningsplot",
    "href": "seminar/seminar3.html#spredningsplot",
    "title": "STV1020",
    "section": "Spredningsplot",
    "text": "Spredningsplot\nMed et spredningsplot (scatterplot) kan vi vise sammenhengen mellom to kontinuerlige variabler. Her må vi gi ggplot informasjon om hvilken variabel som skal mappes på x-aksen og på y-aksen. For å lage scatterplottet bruker vi geom_point.\n\nggplot(data, aes(x = lifeExp, y = gdpPercap)) + geom_point()\n\n\nVi kan legge til en linje som viser gjennomsnittet i observasjonene ved å bruke geom_smooth:\n\nggplot(data, aes(x = lifeExp, y = gdpPercap)) + geom_point() +\n    geom_smooth()\n\n\nSkille kontinentene fra hverandre ved bruk av ulike farger:\n\nggplot(data, aes(x = lifeExp, y = gdpPercap, col = continent)) +\n    geom_point() + geom_smooth()\n\n\nVi kan legge inn en facet_wrap() for at det skal se litt ryddigere ut, og samtidig gi geom_smooth() en farge som vises bedre.\n\nggplot(data, aes(x = lifeExp, y = gdpPercap, col = continent)) +\n    geom_point() + geom_smooth(colour = \"black\") + facet_wrap(~continent) +\n    theme_bw() + theme(legend.position = \"none\")\n\n\nHer kan vi repetere hvordan vi legger til nye titler til x- og y-aksen, samt tittel for hele plottet:\n\nggplot(data, aes(x = lifeExp, y = gdpPercap, col = continent)) +\n    geom_point() + geom_smooth(colour = \"black\") + facet_wrap(vars(continent)) +\n    labs(x = \"Forventet levealder\", y = \"GDP per capita\", title = \"Et plot med Gapminderdata\") +\n    theme_bw() + theme(legend.position = \"none\")"
  },
  {
    "objectID": "proveinfo.html",
    "href": "proveinfo.html",
    "title": "STV1020",
    "section": "",
    "text": "Nei.\n\n\n\nNei.\n\n\n\n[TBD! Vi jobber med løsning på dette.]\n\n\n\n\n\n\n\n\n\n\n[TBD! Vi har ikke bestemt dette enda.]\n\n\n\nDu skal levere et R-script med koden din og kommentarer. Du skal ikke laste opp figurer og tabeller. Seminarleder kjører scriptet ditt og vil på den måten se om koden for en figur eller tabell er riktig.\n\n\n\nJa, du står fritt til å bruke alle hjelpemidler. Det inkluderer seminarmateriellet som er tilgjengelig på github, notater du har tatt i seminar og google. Det kan være lurt å gjøre seg kjent med beskrivelsene av de ulike seminarene i forkant av prøven så du vet hvor du skal slå opp.\n\n\n\nJa, dere har lov til å samarbeide og diskutere oppgavene med medstudenter, men alle må levere sitt eget script med egne kommentarer.\n\n\n\nNei. På prøven er det spesifisert hvor mange poeng du må få for å bestå.\n\n\n\nHvis du er syk så må du søke om utsatt obligatorisk aktivitet her: https://www.uio.no/studier/eksamen/obligatoriske-aktiviteter/sv-fraver-fra-obligatorisk-aktivitet.html\nDersom du får godkjent utsatt obligatorisk aktivitet så vil du få en ny prøvedato.\n\n\n\nHusk å laste inn de nødvendige pakkene ved hjelp av library(). Gjør det først i scriptet så er du ferdig med det. Om du ikke vet hvilken funksjon du skal bruke for å løse en oppgave så slå opp i materiale eller søk på nett.\nOm en kodesnutt ikke vil kjøre så:\n\nlast inn nødvendige pakker igjen.\nkjør all koden før kodesnutten på ny.\nprøv å forstå feilmeldingen. Får du f.eks. en feilmelding som sier “could not find function” så kan dette tyde på at du kanskje har skrevet funksjonsnavnet feil eller at du må laste inn pakken funksjonen ligger i med library() først. Får du en feilmelding om at “object x not found” så kan dette tyde på at du har en skrivefeil i navnet på f.eks. et datasett eller et modellnavn.\nom dette ikke virker så gå videre og kom tilbake til oppgaven senere dersom du har tid. Da kan du søke på nett e.l. etter en løsning."
  }
]
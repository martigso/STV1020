[
  {
    "objectID": "workbench.html",
    "href": "workbench.html",
    "title": "STV1020",
    "section": "",
    "text": "√Öpne nettleseren din og g√• til https://rstudio-workbench.uio.no/\nVelg Universitetet i Oslo/University of Oslo under tilknytning/affiliation.\n\n\n\nLogg inn med brukernavn og passord fra UiO.\n\n\n\nTrykk p√• ‚Äú+ New Session‚Äù.\n\n\n\nVelg STV1020-varianten under ‚ÄúImage‚Äù og trykk ‚ÄúStart session‚Äù. Du kan ogs√• velge √• gi sesjonen et eget navn under ‚ÄúSession Name‚Äù.\n\n\n\nDen nye sesjonen skal n√• dukke opp under ‚ÄúSession‚Äù. Trykk p√• ‚ÄúRStudio Session‚Äù. Dersom du har gitt sesjonen et eget navn s√• m√• du trykke p√• den sesjonen med navnet du brukte.\n\n\n\nN√• skal du f√• opp Rstudio i nettleseren din."
  },
  {
    "objectID": "rogrstudio.html",
    "href": "rogrstudio.html",
    "title": "STV1020",
    "section": "",
    "text": "R er et gratisprogram som er spesielt egnet for statistikk og dataanalyse. RStudio er en IDE (integrated development environment), et gratisprogram som gj√∏r det lettere √• bruke R. Derfor skal vi l√¶re R med RStudio i seminarene.\nF√∏rste gang du √•pner RStudio er alt fremmed, du blir du m√∏tt av en rekke vinduer, menyer og knapper. Dette dokumentet gir deg en kort forklaring av det aller mest grunnleggende i R og RStudio gjennom 10 bilder. Dersom du tar deg 5 minutter til √• lese dokumentet, og fors√∏ke koden, kommer det f√∏rste seminaret til √• g√• som en lek. Dersom f√∏rste seminar ikke gikk som en lek, og du er usikker p√• hva som foreg√•r i RStudio, kan det ogs√• v√¶re nyttig √• lese dette dokumentet.\n\n\nDu kan installere R og RStudio ved √• f√∏lge denne guiden\n\n\n\nN√• er du klar til √• √•pne RStudio (du trenger ikke √•pne R!). N√•r du √•pner RStudio, vil denne skjermen dukke opp:\n\nP√• bildet ser du tre paneler. Til venstre er Console, √∏verst til h√∏yre er Environment, og nederst til h√∏yre er Files. Fra hvert av disse panelene er det mulig √• trykke seg til andre paneler som Terminal, Plots, History og Help. I denne gjennomgangen forklarer jeg imidlertid bare de fire panelene du trenger for √• skrive, kj√∏re, og lagre kode. Disse panelene er:\n\nScript Her skrives koden din\nConsole - Her produseres output fra koden din\nEnvironment - Her er en oversikt over data du kan kj√∏re kode p√•.\nFiles - Her vises filer i mappen du jobber fra, som for eksempel data og kode. Dersom du lagrer scriptet ditt i mappen du jobber fra, dukker det opp her.\n\n\n\n\nLa oss starte med Script. F√∏rste gang du √•pner RStudio m√• du √•pne dette panelet selv. Det gj√∏r du ved √• trykke p√• arket med gr√∏nn sirkel og hvitt plusstegn √∏verst i h√∏yre hj√∏rne. Jeg har merket dette arket p√• bildet under. Trykk deretter p√• ‚ÄúR Script‚Äù. Alternativt kan du bruke hurtigtasten ctrl/cmd + shift + N.\n\nN√•r du har √•pnet et nytt R-script vil denne skjermen med fire paneler dukker opp:\n\nI R-scriptet, det √∏verste panelet til venstre, kan du n√• skrive R-koder. La oss pr√∏ve √• skrive to gyldige R-koder, \"Hello world!\" og 1+1. R-scriptet ditt skal se slik ut:\n\nDu har n√• skrevet to linjer med R-kode!\n\n\n\nI forrige bilde merket jeg den nederste linjen i Console, som begynner med >. Den er tom, men n√•r vi kj√∏rer koden vi har skrevet, vil RStudio evaluere/kj√∏re koden i Console. Dersom koden produserer output, vil denne ogs√• printes i Console. Vi kj√∏rer koden ved √• merke koden i scriptet, og trykke p√• ctrl/cmd + enter (ctrl p√• pc, cmd p√• mac). La oss se p√• resultatet av √• kj√∏re koden vi har skrevet i scriptet:\n\nP√• linjen med > vises kode som R har kj√∏rt. P√• linjen under kode som er kj√∏rt, vises output fra koden. Koden \"Hello world!\"ble lest og evaluert som tekst - resultatet er tekst-outputen ‚ÄúHello world!‚Äù. Koden 1+1 ble lest som et mattestykke, og RStudio produserte outputen 2, l√∏sningen p√• mattestykket vi ba RStudio om √• kj√∏re/evaluere for oss. RStudio kan tydeligvis b√•de lese og regne.\n\n\n\nDet er ikke all kode som gir output i Console. Noen ganger skriver vi kode som gir input til RStudio i form av informasjon/data som vi ber RStudio huske p√• for oss. RStudio kan huske p√• informasjon, uten av vi trenger √• lagre den p√• datamaskinen. Data som RStudio husker, vises i Environment. Vi kaller slike data for objekter. Jeg har merket Environment-panelet, √∏verst til h√∏yre. Vi bruker som regel objekter, gjerne datasett i kodingen vi gj√∏r.\nLa oss skrive en kode som gir RStudio informasjon √• huske p√•. Til dette bruker vi funksjonen (mer presist: assignment operatoren) <-, som brukes til √• oprette objekter. Objekter inneholder ulike samlinger av informasjon/data som RStudio husker p√• for oss. Vi kan selv velge navnet p√• objektene v√•re. Navnet kommer f√∏r <-, jeg velger √• kalle objektet mitt velkommen. Etter pilen forteller vi hva objektet skal inneholde. Under har jeg brukt funksjonen c() for √• fortelle RStudio at jeg √∏nsker √• opprette en vektor (en ordnet liste av verdier) best√•ende av fire elementer, \"Velkommen\" , \"til\", \"R-seminar\" og \"!\". N√•r jeg bruker hermetegn, \" \", behandler R disse elementene som tekst.\n\nLa oss se hva som skjer n√•r vi kj√∏rer koden (med ctrl + enter p√• pc og cmd + enter p√• mac).\n\nVi ser at objektet velkommen har dukket opp i Environment panelet √∏verst til h√∏yre. Vi f√•r ogs√• informasjon om hva objektet inneholder. F√∏rst kommer navnet p√• objektet, chr referer til at objektet best√•r av tekst. Deretter referer [1:4] til at objektet best√•r av fire elementer, som vises til slutt.\nLegg for √∏vrig merke til at n√•r vi kj√∏rte koden, ble den evaluert i Console, men vi fikk ikke output p√• en ny linje i Console. Dersom vi evaluerer objektet vi laget, velkommen, f√•r vi imidlertid en egen linje med output, i dette tilfellet innholdet i objektet. Som oftest f√•r vi output i Console, men noen typer kode, som opprettelse av objekter med <- gir output i andre paneler, som Environment\n\nVi har n√• sett p√• 3 deler av arbeidsflyten i RStudio:\n\nF√∏rst skriver vi kode i et script.\nDeretter kj√∏rer/evaluerer vi koden i Console med ctrl/cmd + enter.\nResultatet av at koden ble evaluert dukker som regel opp i Console. N√•r koden produserer objekter med informasjon som RStudio skal huske p√•, dukker imidlertid objektet opp i Environment.\n\n\n\n\nN√•r vi er ferdig med de 3 stegene over, vil vi som regel lagre arbeidet v√•rt, slik at vi ikke trenger √• gj√∏re arbeidet p√• nytt senere. Dersom det g√•r fort √• kj√∏re gjennom R-scriptet, er scriptet alt vi trenger √• lagre. Det er ogs√• mulig √• lagre datasett, figurer, tabeller og bilder, men dette skal vi l√¶re senere. For √• forst√• hvordan vi kan lagre ulike filer i RStudio, og hvor R leter etter filer (som datasett) som vi ber R finne, m√• vi kjenne til mappesystemet p√• datamaskinen vi jobber fra.\nEt eksempel p√• en mappe som finnes p√• de fleste pcer er Mine dokumenter eller Documents. RStudio velger en mappe av denne typen p√• datamaskinen som working directory. RStudio forventer at filnavn som refereres til ligger i working directory. RStudio vil ogs√• sette som default option at filer lagres i working directory.\nPanelet Files nederst til h√∏yre viser filer i ditt n√•v√¶rende working directory. P√• bildet under, ser du at mappen jeg har som working directory, data, er tom.\n\nHva skjer dersom jeg lagrer R-scriptet i denne mappen? La oss lagre og sjekke. Trykk p√• file √∏verst til venstre i RStudio, trykk deretter p√• save as. Du kan eventuelt bruke hurtigtastene ctrl/cmd + s. Da vil dette vinduet dukke opp:\n\nJeg velger filnavnet test. Vi trenger ikke √• skrive hvilken filtype vi lagrer, RStudio gj√∏r dette for oss. Trykk p√• lagre uten √• skifte mappe du lagrer filen i bor fra default option. Du vil f√• f√∏lgende resultat:\n\nScriptet v√•rt, test.R dukket n√• opp under Files. Dette betyr at RStudio har registrert at filen er i working directory. Filer som slutter med .R er lagret som R-script, vi har dermed lyktes med √• lagre R-scriptet riktig.\n\n\n\nOfte ligger mapper inne i andre mapper, under en harddisk (for eksempel C:). Mappene vi m√• klikke oss gjennom for √• komme fra harddisken til en bestemt mappe, f.eks. STV4020A, utgj√∏r filstien til mappen STV4020A. Ved √• spesifisere filstien til en mappe, kan du kan bytte working directory med funksjonen setwd(). Dersom vi skriver navnet p√• en fil som ligger i en annen mappe enn working directory, vil ikke R klare √• finne denne, med mindre vi spesifiserer filstien. Vi kan lese filstien til n√•v√¶rende working directory p√• toppen av Files-panelet. Fra bildet over, ser vi at mitt working directory er satt til C:/Users/erlenlan/OneDrive/STV4020A/data (Bruk / for √• skille mellom mapper n√•r du skriver filstier). Du kan ogs√• finne n√•v√¶rende working directory ved √• kj√∏re koden getwd(). Den beste og letteste m√•ten √• unng√• frustrasjon pga. working directory er √• opprette et prosjekt gjennom menyen i R-studio. Les mer her."
  },
  {
    "objectID": "oppgaver/oppgaver1.html",
    "href": "oppgaver/oppgaver1.html",
    "title": "Seminar 1 ‚Äì Oppgaver",
    "section": "",
    "text": "L√∏sningsforslag\nDu kan trykke p√• knappen under for √• se p√• l√∏sningsforslag\n\n\nCode\n# Oppgave 1\nfolk <- data.frame(navn = c(\"Eric\", \"Eli\", \"Amalie\", \"Martin\"),\n                   alder = c(25, 17, 72, 55),\n                   favorittfilm = c(\"Finding Nemo\", \"Scream 2\", \"Gruffalo\", \"Folk og r√∏vere i Kardemomme by\"),\n                   by = c(\"B√¶rum\", \"Dalen\", \"Senja\", \"Fr√∏yland\"))\n\n# Oppgave 2\nsummary(folk$alder)\nsd(folk$alder)\n## Gj.snitt = 42.25\n## Median = 40\n## Std.av = 25.7\n\n\n# Oppgave 3\n# Brukker sykkelavstand via google maps\nfolk$avstand <- c(22.1, 219, 1710, 438)\n\n# Oppgave 4\nmax(folk$avstand) # 1710 er lengst\n\n## Alternativ 1\nfolk %>% arrange(avstand) # Amalie har lengst avstand\n\n## Alternativ 2\nfolk$navn[which.max(folk$avstand)]\n\n\n# Oppgave 5\n\nlibrary(tidyverse) # laster inn tidyverse for √• f√• ggplot\n\nggplot(folk, aes(x = navn, y = alder)) +\n  geom_point() +\n  labs(x = \"Navn\", y = \"Alder\")"
  },
  {
    "objectID": "oppgaver/oppgaver3.html",
    "href": "oppgaver/oppgaver3.html",
    "title": "Seminar 3 ‚Äì Oppgaver",
    "section": "",
    "text": "L√∏sningsforslag\n\n\nCode\nlibrary(tidyverse)\n\n#### Oppgave 1 ####\ndata(\"gapminder\", package = \"gapminder\")\n\n#### Oppgave 2 ####\ntable(gapminder$continent)\n\ngapminder <- gapminder %>% \n  mutate(cont_num = case_match(continent,\n                               \"Asia\" ~ 1,\n                               \"Americas\" ~ 2,\n                               \"Oceania\" ~ 3,\n                               \"Europe\" ~ 4,\n                               \"Africa\" ~ 5))\ntable(gapminder$cont_num, gapminder$continent)\n\n#### Oppgave 3 ####\ngapminder$lifeExp_k <- gapminder$lifeExp * 1000\n\ntable(gapminder$lifeExp == gapminder$lifeExp_k/1000)\n\n#### Oppgave 4 ####\ngapminder_subset <- gapminder %>% \n  select(country, year, lifeExp) %>% \n  filter(year == 1977)\n\n#### Oppgave 5 ####\neuro_highle <- gapminder %>% \n  filter(continent == \"Europe\" & lifeExp >= 75)\n\n#### Oppgave 6 ####\nggplot(gapminder, aes(x = as.factor(year))) +\n  geom_bar()\n\n# Ja,det er like mange observasjoner pr √•r\n\n#### Oppgave 7 ####\nggplot(gapminder, aes(x = gdpPercap)) +\n  geom_histogram()\n\n#### Oppgave 8 ####\nggplot(gapminder, aes(x = gdpPercap)) +\n  geom_density(linewidth = 2, color = \"red\")\n\n#### Oppgave 9 #### +\n#### Oppgave 10 #### +\n#### Oppgave 11 ####\n\nggplot(gapminder, aes(x = pop, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~ continent)\n\n#### Oppgave 12 ####\n#### Oppgave 13 ####\n\nggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +\n  geom_smooth()\n\n\n#### Oppgave 14 ####\n\n# Her har jeg bare lekt litt\nggplot(gapminder, aes(x = year, y = lifeExp, color = continent, fill = continent)) +\n  geom_smooth(alpha = .2) +\n  labs(x = \"√Ör\", y = \"Forventet levealder\", color = \"\", fill = \"\",\n       title = \"Trend i forventet levealder p√• tvers av kontinent\") +\n  theme_classic() +\n  theme(legend.position = \"bottom\",\n        panel.grid.major.y = element_line(linetype = \"dashed\"))\nggsave(\"../bilder/oppgave3_14plot.png\")\n\n#### Ekstraoppgave ####\n\nafrica <- gapminder %>% \n  filter(continent == \"Africa\" & year == 1952) %>% \n  filter(lifeExp > mean(lifeExp)) # Siden denne kommer etter filteret over,\n                                  # vil den regne snitt bare p√• afrikanske land\n                                  # fra 1952. Rekkef√∏lge er viktig."
  },
  {
    "objectID": "oppgaver/oppgaver6.html",
    "href": "oppgaver/oppgaver6.html",
    "title": "Seminar 6 ‚Äì Oppgaver",
    "section": "",
    "text": "Kommer snart!"
  },
  {
    "objectID": "oppgaver/oppgaver5.html",
    "href": "oppgaver/oppgaver5.html",
    "title": "Seminar 5 ‚Äì Oppgaver",
    "section": "",
    "text": "Kommer snart!"
  },
  {
    "objectID": "oppgaver/oppgaver2.html",
    "href": "oppgaver/oppgaver2.html",
    "title": "Seminar 2 ‚Äì Oppgaver",
    "section": "",
    "text": "L√∏sningsforslag\n\n\nCode\n# Laster inn n√∏dvendige pakker\nlibrary(tidyverse)\nlibrary(haven)\n\n# Oppgave 1\ness <- read_dta(\"../data/ESS9NO.dta\")\n\n# Oppgave 2\ness <- ess %>% \n  rename(poltil = trstplt,\n         kjonn = gndr,\n         aar_fodt = yrbrn)\n\n# Oppgave 3\ness$alder <- 2018 - ess$aar_fodt\nsummary(ess$alder)\n\n# Oppgave 4\ness_sub <- ess %>% \n  select(poltil, kjonn, aar_fodt, vote, alder)\n\nhead(ess_sub)\n\n# Oppgave 5\nclass(ess_sub$poltil)\nclass(ess_sub$kjonn)\n\n# Oppgave 6\ntable(ess_sub$poltil)\nlabels(ess_sub$poltil)\n\n# Oppgave 7\n\nggplot(ess_sub, aes(x = poltil)) +\n  geom_bar()\n\n# Oppgave 8\ness_sub$kjonn <- factor(ess_sub$kjonn)\ness_sub$vote <- factor(ess_sub$vote)\n\nggplot(ess_sub, aes(x = kjonn, fill = vote)) +\n  geom_bar(position = position_dodge())\n\n# Oppgave 9\nggplot(ess_sub, aes(x = alder, y = kjonn)) +\n  geom_boxplot()\n\n# evt.\n\nggplot(ess_sub, aes(x = alder, fill = kjonn)) +\n  geom_density(alpha = .3)"
  },
  {
    "objectID": "oppgaver/oppgaver4.html",
    "href": "oppgaver/oppgaver4.html",
    "title": "Seminar 4 ‚Äì Oppgaver",
    "section": "",
    "text": "Du skal bruke datasettet wvs_us17.csv og line√¶r regresjon for √• unders√∏ke relasjonen mellom avhengig (AV) og uavhengig (UV) variabel. Datasettet er en survey gjennomf√∏rt i USA i 2017 for World Value Survey. Individer svarer p√• surveyen. Tilsvarende surveyer er gjort for mange andre land og √•r (se World Value survey sine nettsider for mer informasjon), men i dag bruker vi et datasett som bare inneholder observasjonene fra USA i 2017.\nDatasettet inneholder f√∏lgende variabler:"
  },
  {
    "objectID": "oppgaver/oppgaver4.html#oppgaver",
    "href": "oppgaver/oppgaver4.html#oppgaver",
    "title": "Seminar 4 ‚Äì Oppgaver",
    "section": "Oppgaver",
    "text": "Oppgaver\n\nLast inn datasettet wvs_us17.csv. Du kan finne det her. Oppgi antall enheter og variabler i datasettet.\nFinn navn p√• variablene i datasettet.\nOpprett en nytt datasett med kun variablene imp_democracy, age og income_group Sjekk at klassen til variablene er numeric.\nVis hvordan du fjerner enheter som mangler opplysninger fra datasettet. Oppgi antall enheter i datasettet etter at du har fjernet enhetene.\nLag et arealplot med age p√• x-aksen og lag ett panel pr verdi p√• imp_democracy (facet_wrap())\nKj√∏r en bivariat korrelasjon mellom imp_democracy og age.\nTolk korrelasjonen og sjekk om den er signifikant\nLag et plott med observerte verdier av imp_democracy p√• y-aksen og observerte verdier av age p√• x-aksen.\nLag en bivariat regresjon med imp_democracy som avhengig variabel og age som uavhengig variabel.\nVis resultatene fra modellen og tolk koeffisienten for age substansielt."
  },
  {
    "objectID": "oppgaver/oppgaver4.html#l√∏sningsforslag",
    "href": "oppgaver/oppgaver4.html#l√∏sningsforslag",
    "title": "Seminar 4 ‚Äì Oppgaver",
    "section": "L√∏sningsforslag",
    "text": "L√∏sningsforslag\n\n\nCode\n# Pakker \nlibrary(tidyverse)\n\n# Oppgave 1\nwvs <- read.csv(\"https://raw.githubusercontent.com/martigso/STV1020/gh-pages/data/wvs_us17.csv\")\n\n# Oppgave 2\nnames(wvs)\n\n# Oppgave 3\n\nwvs_sub <- wvs %>% \n  select(imp_democracy, age, income_group)\n\nglimpse(wvs_sub)\n# Alle er heltall (<int>)\n\n# Oppgave 4\nfoer <- nrow(wvs_sub)\n\nwvs_sub <- wvs_sub %>% drop_na()\n\netter <- nrow(wvs_sub)\n\nfoer - etter\n\n# 81 enheter ble fjernet\n\n\n# Oppgave 5\n\nggplot(wvs_sub, aes(x = age)) +\n  geom_density() +\n  facet_wrap(~ imp_democracy)\n\n# Det kan se ut som yngre gir lavere sk√•re p√• imp_democracy\n\n# Oppgave 6\n\ncor(wvs_sub$imp_democracy, wvs_sub$age)\n\n# Oppgave 7\n\ncor.test(wvs_sub$imp_democracy, wvs_sub$age)\n\n# Sammenhengen mellom de 2 variablene er relativt h√∏y og positiv\n# dvs at man kan forvente at dess eldre man er, dess mer viktig\n# mener man demokrati er.\n\n# Oppgave 8\n\nggplot(wvs_sub, aes(x = age, y = imp_democracy)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(0, 10, 1))\n# Her ser vi tydelig at imp_democracy er kategorisk\n\n# Oppgave 9\n\ndem_reg <- lm(imp_democracy ~ age, data = wvs_sub)\n\n# Oppgave 10\n\nsummary(dem_reg)\n\n# Konstantledd: forventet sk√•re p√• imp_democracy n√•r alder er 0, er 6.72\n# age: for hver enhets √∏kning p√• alder (1 √•r), forventer vi at sk√•ren til\n#      imp_democracy √∏ker med 0.03. Alts√• vil man forvente at en person p√•\n#      20 √•r svarer ca 7.32 p√• imp_democracy (6.72 + (0.03 * 20)), mens en\n#      person p√• 70 √•r vil ha en forventet sk√•re p√• 8.82 (6.72 + (0.03 * 70))\n# Sammenhengen er ogs√• signifikant p√• mindre enn 0.001-niv√•"
  },
  {
    "objectID": "laste_data.html",
    "href": "laste_data.html",
    "title": "STV1020",
    "section": "",
    "text": "N√•r du skal laste inn et datasett til RStudio, og det oppst√•r problemer, kan du sjekke tipsene under. Her er eksemplene fra en Mac, men de samme l√∏sningene vil finnes ogs√• p√• Windows og Linux.\n\n\nPass p√• at du enten √•pner prosjektfilen din eller setter working directory til en mappe du finner igjen. For eksempel kan du lage en mappe som heter ‚ÄúR-seminar‚Äù p√• skrivebordet, og s√• lage undermapper for hvert seminar. Dere kan sette working directory som vist under, eller bruke koden setwd(). Hvis dere vil dobbeltsjekke, bruk funksjonen getwd().\n\nDet aller viktigste er √• finne en god m√•te √• strukturere prosjektene sine p√•. Eksempelvis ‚ÄúR Best Practices‚Äù. Ta gjerne ogs√• en titt p√• RStudios/posit egen side for hvordan man bruker prosjekter.\n\n\n\nPass p√• at datasettfilen ligger i mappen du pr√∏ver √• hente den fra. For eksempel er det lurt √• ha datasett i en egen datamappe der prosjektfilen din er lagret. P√• bildet under ser dere hvordan det er gjort i dette eksempelet.\n\nDu kan ogs√• sjekke hvilke filer som ligger i mappen du jobber fra i R med funksjonen list.files()\n\n\n\nDobbeltsjekk koden du skriver i RStudio, sjekk for skrivefeil, parenteser og hermetegn, og at filnavnet er det samme som du har lagret filen som.\nBruk gjerne tab for √• finne frem filen din for √• unng√• problemer med skrivefeil. Still mark√∏ren i hermetegnene i koden for √• laste inn data og trykk p√• tab-knappen (hvilken knapp det er kan du google) for √• liste opp mapper og filer i working directory/prosjektmappen din. Om datafilen er lagret i working directory/prosjektmappen s√• kommer den opp i en liste som vist p√• bildet under.\n\n\n\n\n\nHer er de ulike kodene for √• laste inn filtyper. Der det st√•r ‚Äúnavn‚Äù er navnet dere gir objektet, dette finner dere p√• selv. Der det st√•r ‚Äúfile‚Äù skal dere sette inn filnavnet. Alts√• det filen heter i mappen dere lagret den i.\n\n\n\ninstall.packages(\"readxl\")\nlibrary(readxl)\n\nnavn <- read_excel(\"file\")\n\n\n\n\n\nnavn <- read.csv(\"file\")  \nnavn <- read.csv2(\"file\")\n\n\n\n\n\nload(\"file\")\n# Merk at her gir du ikke datasettet et eget navn\n\n\n\n\n\ninstall.packages(\"haven\")\nlibrary(haven)\n\nnavn <- read_dta(\"file\")\n\n\n\n\n\ninstall.packages(\"haven\")\nlibrary(haven)\n\nnavn <- read_sav(\"file\")\n\nV√¶r obs p√• at variabler som egentlig er faktorer kan bli lest som numeriske ved bruk av haven. Derfor er det ekstra viktig √• sjekke kodebok og/eller labels.\nHvis dere har fulgt stegene over, men likevel ikke f√•r lastet inn datasettet:\n\nSjekk om pakkene du har installert er oppdatert.\n\nFor √• unders√∏ke om noen av pakkene trenger en oppdatering, kan dere trykke p√• ‚Äòtools‚Äô og ‚Äòcheck for package updates‚Äô.\nEller kj√∏re funksjonen update.packages(ask = FALSE)\n\nHvis du har Mac, sjekk at maskinen din er oppdatert.\n\nEr du usikker p√• hvordan s√• se p√• Apple sine support-sider\n\nSjekk at du har riktig versjon av R og Rstudio for maskinen din\n\nEr du usikker s√• sjekk installasjonsveiledningen\n\n\nHvis dere har g√•tt gjennom alle stegene, og likevel ikke f√•r lastet inn datasettene s√• er neste steg √• g√• innom kodekaf√© for √• f√• hjelp.\n\n\n\n\nFor √• unders√∏ke om tidyverse er installert kan dere kj√∏re koden under. Du skal f√• opp et plot nederst til h√∏yre i RStudio n√•r du kj√∏rer koden:\n\n# Install.packages er ikke n√∏dvendig √• kj√∏re om du allerede har installert pakken\ninstall.packages(\"tidyverse\") \nlibrary(tidyverse)\ndata <- data.frame(x = c(1,1,1,2,2,3,4,4,5))\nggplot(data = data, aes(x = x)) +\n  geom_bar()\n\nPlottet skal se omtrent slik ut:"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduksjon",
    "section": "",
    "text": "üëã Velkommen til R-seminarer i STV1020! üëã\nI denne lille notatboka1 finner du litt informasjon om praktisk ting og tang. Det kan v√¶re lurt √• se over de forskjellige sidene i venstremargen:"
  },
  {
    "objectID": "index.html#om-r-seminarene",
    "href": "index.html#om-r-seminarene",
    "title": "Introduksjon",
    "section": "Om R-seminarene",
    "text": "Om R-seminarene\nBoka inneholder ogs√• fundamentet for det vi skal g√• gjennom i seminarene. I STV1020 har vi 6 seminarer der vi g√•r gjennom grunnleggende funksjoner og m√•ter √• jobbe med R p√•. Tema for seminarene er:\n\nGrunnleggende R ‚Äì kalkulator, indeksering, objekter, osv\nData ‚Äì laste inn, lage deskriptiv statistikk og visualisering\nDatamanipulering ‚Äì omkoding, tabeller, visualisering\nBivariate sammenhenger ‚Äì korrelasjon, krysstabulering og visualisering\nBivariat regresjon ‚Äì OLS\nMultivariat regresjon ‚Äì OLS\n\nDet er mye √• sette seg inn i n√•r man starter helt fra bunn, men √• bruke litt innsats p√• R n√•, kan gi gevinster senere. Mange ender opp med √• skrive kvantitative oppgaver i andre kurs eller bacheloroppgave, mens andre kan f√• bruk for kunnskapen i jobbsammenheng. P√• kort sikt har vi sett at √• jobbe godt med R i STV1020 ogs√• gj√∏r l√¶ringen i resten av kurset noe mer lettfattelig.\nR-seminarene blir etterfulgt av en digital pr√∏ve som du m√• best√• for √• kunne g√• opp til eksamen i STV1020 (se emneside for STV1020). Dersom du ikke best√•r p√• f√∏rste fors√∏k s√• f√•r du et nytt fors√∏k. Man kan enten bruke egen laptop (anbefalt) eller en stasjon√¶r UiO-PC (alle maskiner p√• Eilert Sundt skal ha R og RStudio installert) n√•r man skal bruke R. For de som har PCer som ikke kj√∏rer s√• godt, kan workbench v√¶re et godt alternativ."
  },
  {
    "objectID": "index.html#forventninger",
    "href": "index.html#forventninger",
    "title": "Introduksjon",
    "section": "Forventninger",
    "text": "Forventninger\nF√∏r f√∏rste seminar s√• forventer vi:\n\nüíæ At du har lastet ned og installert R og Rstudio f√∏r f√∏rste seminar. F√∏lg gjerne installasjonsguiden p√• denne siden. üíª\nüìà At du har lest gjennom guide for innlasting av datasett üìâ\n\nUnder seminarrekka forventer vi:\n\nüë©‚Äçüéì At du m√∏ter opp p√• seminar. üë®‚Äçüéì\nüìö At du jobber med √• l√∏se oppgaver mellom seminarene. üìö\n\nDette er viktig for at seminarene skal g√• s√• smidig som mulig og for at dere skal f√• l√¶ringsutbytte av √• delta. For noen kan R virke skummelt ved f√∏rste √∏yekast, men erfaringsmessig s√• g√•r dette veldig fint s√• lenge du legger ned litt innsats underveis üéâ ü•≥ üéâ"
  },
  {
    "objectID": "index.html#nyttige-lenker",
    "href": "index.html#nyttige-lenker",
    "title": "Introduksjon",
    "section": "Nyttige lenker",
    "text": "Nyttige lenker\n\nCoffee & Coding\n√òve deg p√• R direkte relatert til STV1020 i denne tutorialen.\nBli med i facebookgruppen R for statsvitenskap ved UiO.\nDiscord server for STV\nR-workbench for UiO-brukere\nRStudio Keyboard Shortcuts for Windows, Linux and Mac hjelper deg √• kode raskere.\nStack overflow er et forum hvor folk stiller sp√∏rsm√•l og f√•r hjelp til ulike utfordringer med R. Om du lurer p√• noe s√• vil du som regel finne svar her.\nRstudio community forum er litt i samme gate som Stack overflow.\nUsing projects gir en introduksjon til hvordan dere kan bruke prosjekter i Rstudio.\nSe et forslag til mappestruktur.\nThe tidyverse style guide for R inneholder mange tips for √• skrive forst√•elig og god kode.\nR for Data Science er en veldig god bok for dere som vil fordype dere videre.\nRStudio Cheatsheets oppsummerer pakker eller oppgaver i R som for eksempel ggplot2. Gevinsten i disse juksearkene er st√∏rst n√•r en har litt forst√•else for hva pakken gj√∏r.\nOslo UseR! group og R-Ladies Oslo arrangerer jevnlig interessante foredrag og workshops om R."
  },
  {
    "objectID": "installasjon.html",
    "href": "installasjon.html",
    "title": "STV1020",
    "section": "",
    "text": "Du m√• installere R og Rstudio f√∏r f√∏rste seminar. Dersom du allerede har installert R og Rstudio s√• er det fint om du oppdaterer til siste versjon f√∏r seminar. Om alle har samme versjon s√• vil seminarene g√• mye smidigere.\nDersom du trenger hjelp eller har problemer med installasjon/oppdatering s√• kan du komme p√• ‚òï kodekaf√© ‚òï.\nHar du R og Rstudio installert?\n\nJa - f√∏lg instruksjonene under ‚ÄúHvordan oppdatere R og Rstudio‚Äù.\nNei - f√∏lg instruksjonene under ‚ÄúHvordan installere R og Rstudio‚Äù.\n\n\n\n\nüíª Windows üíª\n\n√Öpne en nettleser og g√• til www.r-project.org.\nKlikk p√• ‚Äúdownload R‚Äù lenken. Den er i f√∏rste avsnitt under ‚ÄúGetting started‚Äù.\nVelg CRAN location. Her burde du g√• for Norway. Klikk p√• lenken.\n\nKlikk p√• ‚ÄúDownload R for Windows‚Äù p√• toppen av siden.\nKlikk p√• ‚Äúinstall R for the first time‚Äù.\nKlikk p√• ‚ÄúDownload R for Windows‚Äù og lagre filen p√• maskinen din. N√•r nedlastningen er ferdig s√• √•pner du .exe-filen og f√∏lger installasjonsveiledningen.\nN√• kan du laste ned Rstudio.\n\nüçé Mac üçé\n\n√Öpne en nettleser og g√• til www.r-project.org.\nKlikk p√• ‚Äúdownload R‚Äù lenken. Den finner du i f√∏rste avsnitt under ‚ÄúGetting started‚Äù.\nVelg CRAN location. Her burde du g√• for Norway. Klikk p√• lenken.\nKlikk p√• ‚ÄúDownload R for (Mac) OS X‚Äù p√• toppen av siden. Du m√• lese det som st√•r p√• siden du kommer til n√• n√∏ye dersom du har Mac.\nVelg den R-versjonen som passer den operativsystemversjonen du har. Om du har en eldre MacBook s√• er det viktig at du klikker p√• riktig lenke. Er du usikker p√• hvilken macOS-versjon du har s√• kan du klikke p√• eplet i venstre hj√∏rne og velge ‚Äúabout this mac‚Äù. Der skal det st√• macOS etterfulgt av navnet p√• versjonen.\nKlikk p√• lenken som matcher din versjon og lagre filen p√• maskinen. N√•r nedlastningen er ferdig s√• √•pner du filen og f√∏lger installasjonsveiledningen.\nN√• kan du laste ned Rstudio.\n\nüêß Linux (Ubuntu 20.04+) üêß\n\nInstallere dependencies:\n\nsudo apt install dirmngr gnupg apt-transport-https ca-certificates software-properties-common\n\nLegge til CRAN i listen over repositories:\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9`\nsudo add-apt-repository 'deb https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/'\n\nInstallere R:\n\nsudo apt install r-base r-base-dev\n\nSjekk om det virker:\n\nR --version\n\n\n\n\n\n\nG√• til www.rstudio.com.\nTrykk p√• ‚ÄúDownload‚Äù.\nTrykk ‚ÄúDownload‚Äù knappen under gratisversjonen av Rstudio Desktop.\nFinn den versjonen som er anbefalt for operativsystemet ditt. Klikk p√• lenken i kolonnen ‚ÄúDownload‚Äù for √• laste ned installasjonsfilen.\nKj√∏r filen og f√∏lg installasjonsveiledning.\n\nN√• er du klar for f√∏rste R-seminar!\n\n\n\nSeminarene g√•r smidigere om alle bruker samme versjon av R. Dersom du har R og Rstudio installert fra f√∏r s√• kan du f√∏lge denne oppskriften for √• sjekke hvilken versjon du har og eventuelt oppdatere dersom n√∏dvendig.\n\n\n\n√Öpne Rstudio. √òverst i konsoll s√• vil du se ‚Äúsession info‚Äù. Den f√∏rste linjen forteller deg hvilken R versjon du bruker. Alternativt s√• kan du kj√∏re koden R.version.string for √• printe R versjonen.\nHar du R versjon 4.2.2 installert?\n\nNei - f√∏lg instruksjonene for √• ‚ÄúOppdatere R og Rstudio‚Äù\nJa - supert! Du er klar for f√∏rste R-seminar!\n\n\n\n\nüíª Windows üíª\nFor √• oppdatere R p√• en Windows maskin s√• kan du pr√∏ve √• bruke pakken installr.\n\nInstaller og last inn installr: skriv inn og kj√∏r kodene install.packages(\"installr\") og library(installr)\nSkriv updateR() og kj√∏r koden. Dette vil starte oppdateringsveilederen til R.\nFor √• oppdatere Rstudio s√• √•pner du Rstudio, velger Help > Check for Updates. Dette vil sende deg til Rstudios nettside hvor du kan laste ned den nyeste versjonen.\n\nN√• er du klar for f√∏rste R-seminar!\nüçé Mac üçé\nP√• Mac s√• laster du selv ned og installerer den nyeste versjonen av R. N√•r du restarter Rstudio s√• vil den oppdaterte versjonen av R automatisk bli tatt i bruk. NB! Her er det snakk om den nyeste versjonen av R som er kompatibel med din Mac.\n\nF√∏lg installasjonsveiledningen for MAC.\nFor √• oppdatere Rstudio s√• √•pner du Rstudio, velger Help > Check for Updates. Dette vil sende deg til Rstudios nettside hvor du kan laste ned den nyeste versjonen.\n\nüêß Linux (Ubuntu 20.04+) üêß\nR oppdateres som alt annet p√• Ubuntu: 1. sudo apt update 2. sudo apt upgrade\nRstudio oppdateres ved √• f√∏lge veiledningen for installasjon av Rstudio over.\nN√• er du klar for f√∏rste R-seminar!"
  },
  {
    "objectID": "seminar/seminar1.html",
    "href": "seminar/seminar1.html",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "",
    "text": "Gjennom 6 seminarganger skal vi n√• g√• igjennom alt fra hva R og Rstudio er og hvordan det fungerer, til √• kj√∏re v√•re helt egne regresjonsanalyser. Vi gleder oss!\nF√∏r hvert seminar kommer vi til √• legge ut lenke til fire ting p√• Canvas:\nI denne boken vil dere finne noe tekst, noen figurer og tabeller, og noe kode. Innholdet reflekterer det vi har planlagt √• g√• gjennom p√• seminarene. Eksempelkoden i boka blir markert i blokker som har en egen m√∏rk bakgrunn som her:\nMens output av koden, der det er relevant, vil ha en lysegr√• bakgrunn, som her:\nAlt som er skrevet i de m√∏rke boksene kan dere kopiere inn i et R-script og kj√∏re for √• se hva som skjer. N√•r det er en # (hash) foran en tekstlinje s√• betyr det at vi skriver en kommentar i scriptet. N√•r vi setter en # foran teksten s√• skj√∏nner R at dette ikke er vanlig kode, men en kommentar. Resultatene av faktisk kode vil komme i et eget felt med gr√• bakgrunn under. Se for eksempel her:"
  },
  {
    "objectID": "seminar/seminar1.html#hjelpefiler",
    "href": "seminar/seminar1.html#hjelpefiler",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Hjelpefiler",
    "text": "Hjelpefiler\nOfte n√•r vi bruker R er vi usikre p√• hvordan forskjellige funksjoner fungerer. Da kan det v√¶re nyttig √• lese hjelpefilene som forteller hva en funksjon gj√∏r, og hvordan en skal bruke den. For √• gj√∏re dette skriver du et sp√∏rsm√•lstegn f√∏r navnet p√• funksjonen.\n\n# La oss pr√∏ve dette med 'mean()' funksjonen, som logisk nok finner\n# gjennomsnitt:\n?mean\n\nDersom du f√•r et svar som under her s√• tyder det p√• at du ikke har installert pakken funksjonen ligger i. Da kan du legge til et sp√∏rsm√•lstegn til og kj√∏re kode ??vif.\n\n?vif\n\nNo documentation for 'vif' in specified packages and libraries:\nyou could try '??vif'\n\n\nI hjelpefilen f√•r vi en del informasjon om funksjonen. Funksjoner hjelper oss √• hente ut informasjon fra data. Et eksempel p√• data kan v√¶re en tallrekke fra 1 til 10. Informasjonen vi √∏nsker √• hente ut kan for eksempel v√¶re gjennomsnittet eller standardavviket. Vi kan bruke funksjoner til √• f√• R til √• hente ut denne informasjonen for oss. Alle funksjoner har til felles at de tar noe data, f.eks. tall, og skaper et resultat. I tilegg har noen argumenter som gj√∏r at vi kan endre p√• hvordan funksjonen lager resultatet, hva vi f√•r opp i consol og liknende.\nLeser vi hjelpefilen til funksjonen mean() s√• ser vi at den √∏verst gir en beskrivelse, hvor det st√•r at den returnerer gjennomsnittet. Under der kommer argumentene den godtar; et argument (x) som definerer hvilke data vi vil hente ut informasjonen fra, et argument for √• trimme dataene, alts√• fjerne noe, og na.rm argumentet som forteller R hvordan de skal h√•ndtere missingverdier i beregningen. Under Value f√•r vi en beskrivelse av hva funksjonen ‚Äúproduserer‚Äù, f√∏r til slutt et eksempel av hvordan den brukes i bunn.\nHjelpefilene er en flott m√•te √• finne ut hva en funksjon gj√∏r, og hvordan vi kan bruke den. Samtidig kan den ofte v√¶re litt kronglete √• lese. Da hjelper det ofte √• se p√• eksemplene som alltid er i bunn av teksten. Ellers beskriver ogs√• Healy hvordan man kan lese hjelpefilene i Appendix. Skulle det fortsatt v√¶re vanskelig er det viktig √• huske at det finnes et stort milj√∏ rundt R, og ofte er det mange som har opplevd samme problem som deg! Litt googling, og et s√∏k p√• https://stackoverflow.com/ vil fort gi gode svar! Det er ogs√• mulig √• sp√∏rre i facebookgruppen R for statsvitenskap ved UiO.\nUnder er et eksempel p√• hjelpefil for funksjonen head():\n\n\n\nHjelpefileksempel"
  },
  {
    "objectID": "seminar/seminar1.html#syntax-feil",
    "href": "seminar/seminar1.html#syntax-feil",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Syntax-feil",
    "text": "Syntax-feil\nN√•r vi skriver kode vil vi fort gj√∏re en del feil. Det er helt vanlig og noe som er helt uung√•elig! Dere vil nok fort merke at ogs√• seminarleder kan gj√∏re en hel del feil n√•r vi skal vise dere eksempler i seminaret. En type feil kan likevel v√¶re grei √• merke seg med en gang ‚Äì mest fordi alle gj√∏r den n√•r de skriver kode. ‚ÄúSyntax-feil‚Äù er skrivefeil vi gj√∏r n√•r vi skriver kode. F.eks. kan det v√¶re √• skrive men() istedenfor mean(), glemme √• lukke en parantes s√•nn at vi skriver mean( og liknende. Noe av det fine med RStudio er at den markere s√•nne feil for oss!\n\n\n\nEksempler p√• feil kode og feilmeldinger\n\n\nBildet over viser eksempler p√• feilskrevet kode samt hvordan Rstudio markerer dette og hvilke feilmeldinger vi f√•r n√•r vi pr√∏ver √• kj√∏re koden. Dere kan se at R har markert tre av fire linjenummer med en r√∏d X. Dette er steder hvor RStudio mener vi har gjort feil. Hvis vi holder musepekeren over kryssene f√•r vi opp forslag til hva som kan v√¶re feilen. \"Unexpected token ')'\" betyr at RStudio mener det er en parantes der som ikke skulle v√¶rt der. I tilegg er det r√∏de streker under de delene av koden som RStudio mener er feil. Det som ofte gj√∏r at ting stopper opp i R, er slike enkle skrivefeil/syntax-feil som dette. Derfor er det veldig nyttig at RStudio viser det p√• denne m√•ten!"
  },
  {
    "objectID": "seminar/seminar1.html#objekter",
    "href": "seminar/seminar1.html#objekter",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Objekter",
    "text": "Objekter\nDet f√∏rste vi skal se p√• er objekter. Objekter er i alle ‚Äúting‚Äù i R som kan inneholde noe annet. Noen objekter laster vi inn ved hjelp av pakker, noen er bygd inn i R og andre kommer vi til √• lage selv. Dere kan tenke p√• for eksempel datasett, funksjoner og modellresultater som mulige objekter. Vi lager nye objekter ved √• bruke R sin assignment operator <-.\nVi skal i hovedsak forholde oss til to typer objekter; vektorer og funksjoner. Hva disse er nok lettere √• vise ved eksempel. La oss lage et objekt med informasjon om et tall. For √• gj√∏re dette m√• vi f√∏rst velge et objektnavn, s√• bruke <- (dette heter en ‚Äúassignment operator‚Äù), og s√• skrive hva objektet skal inneholde. Her lager vi en vektor som heter ‚ÄúTo‚Äù og som inneholder tallet 2.\n\nTo <- 2\n\n2 + To\n\n[1] 4\n\n\nSom dere ser kan vi n√• skrive 2 + To, kj√∏re koden og f√• ut resultatet fire. N√•r vi n√• skriver ‚ÄúTo‚Äù vet R at vi egentlig mener tallet 2 som er lagret i objektet. For s√• enkle ting som dette s√• er det nok enklere √• bare skrive 2, eller bruke en kalkulator for den saks skyld. Det fine med objekter er at de kan inneholde veldig mye informasjon!\nI f√∏rste omgang kan vi pr√∏ve √• lagre flere tall i et objekt. Det er flere m√•ter vi kan gj√∏re dette p√•, for eksempel s√• kan vi skrive 1:10 for √• f√• alle heltallene mellom 1 og 10, eller skrive c(1, 22, 5, 2, 1) for √• lage en tallrekke. I det siste skiller vi tallene med komma. Objektene kan du kalle akkurat hva du vil, men som vi skal se p√• senere er det noen retningslinjer som er lure √• f√∏lge:\n\nNavn b√∏r bare inneholde sm√• bokstaver, tall og _.\nIkke bruk et tall som f√∏rste tegn.\nIkke bruk √¶/√∏/√•.\nIkke bruk mellomrom.\nIkke bruk FALSE, TRUE, Inf, for, else, break, function eller andre funksjonsnavn\n\nLa oss n√• lage noen flere objekter:\n\nen_til_hundre <- 1:100\ntall <- c(1, 4, 56, 8, 4, 2, 4)\n\ntall\n\n[1]  1  4 56  8  4  2  4"
  },
  {
    "objectID": "seminar/seminar1.html#funksjoner",
    "href": "seminar/seminar1.html#funksjoner",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Funksjoner",
    "text": "Funksjoner\nN√• som vi har et script med flere elementer kan vi pr√∏ve √• kj√∏re noen funksjoner p√• dem. En fuksjon er kort sagt noe man gir en eller annen input til, for s√• √• f√• tilbake en output.1 La oss se om vi kan finne gjennomsnittet av disse vektorene:\n\nmean(en_til_hundre)\n\n[1] 50.5\n\nmean(tall)\n\n[1] 11.28571\n\n\nMed funksjonen mean() f√•r vi gjennomsnittet (output) for hele vektoren/objektet (input). Som oftest er det det vi √∏nsker, men om vi kun √∏nsket gjennomsnittet av noen utvalgte tall s√• er det ogs√• mulig ved hjelp av indeksering eller filtrering. Dette skal vi se mer p√• senere. Vi kommer til √• bruke en rekke funksjoner gjennom seminarrekka, og det kan fort virke litt overveldende mye √• huske. Men det er alltid lov √• s√∏ke opp hvilke funksjoner som gj√∏r hva i R ‚Äì denne boka er forh√•pentligvis et godt utgangspunkt for slike s√∏k."
  },
  {
    "objectID": "seminar/seminar1.html#indeksering",
    "href": "seminar/seminar1.html#indeksering",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Indeksering",
    "text": "Indeksering\nOm dere ser i environment s√• vil dere merke at etter navnet p√• vektoren tall s√• st√•r det f√∏rst ‚Äúnum‚Äù og deretter [1:7]. Den f√∏rste teksten sier at dette er et numerisk objekt. Klasser skal vi straks g√• inn p√•. Det neste viser lengden p√• vektoren v√•r. tall har sitt f√∏rste tall i plassen 12, og siste i 7. Alts√• er det 7 elementer. Om vi ser p√• en_til_hundre ser vi at det st√•r 1:100, og denne har alts√• 100 elementer.\nFor √• f√• tak i et spesifikt element kan vi bruke disse klammeparanteser. La oss si at vi vil ha element nr. 5 i vektoren tall:\n\ntall[5]\n\n[1] 4\n\n\nN√•r vi kj√∏rer denne ser vi at vi f√•r ut det femte tallet i tallrekka vi skreiv inn i stad. Dette kan vi ogs√• sjekke i environment for √• se at stemmer.\nP√• samme m√•te som vi definerte en rekke tall istad, kan vi ogs√• hente ut en rekke elementer.\n\ntall[3:6]\n\n[1] 56  8  4  2\n\ntall[c(3, 5, 3, 6)]\n\n[1] 56  4 56  2\n\n\nVi kan ogs√• finne gjennomsnittet av utvalgte tall:\n\nmean(tall[c(3, 5, 3, 6)])\n\n[1] 29.5\n\n\nEller bruke disse som et nytt objekt:\n\nny_vektor <- tall[c(3, 5, 3, 6)]"
  },
  {
    "objectID": "seminar/seminar1.html#klasser",
    "href": "seminar/seminar1.html#klasser",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Klasser",
    "text": "Klasser\nS√• langt har vi kun jobbet med tallverdier. Ofte har vi variabler som ikke er tall, men f.eks. tekst eller ordinalverdier. I R vil vi ogs√• se at visse funksjoner krever at dataene er i visse klasser. Hovedklassene vi kommer til √• bruke er; numeric, character, logical og factor. Numeric er tall (logisk nok). De fleste mattefunksjoner krever at dataene er numeric. For √• sjekke om noe er numeric kan vi bruke funksjonen is.numeric().\n\nis.numeric(en_til_hundre)\n\n[1] TRUE\n\n# Her ser vi at vi f√•r opp 'TRUE' som betyr at en_til_hundre er et\n# numerisk objekt\n\nVi kan ogs√• bruke funksjonen class() til √• hente ut informasjon om klassen:\n\nclass(en_til_hundre)\n\n[1] \"integer\"\n\n\nDere vil noen ganger se at det skilles mellom ‚Äúnumeric‚Äù og ‚Äúinteger‚Äù. Forskjellen er at integer kun kan inneholde heltall, mens numeric kan ha desimaler. Dette er sv√¶rt sjeldent interessant for v√•r del.\nN√•r vi vil skrive tekst bruker vi klassen ‚Äúcharacter‚Äù. En tekststring m√• alltid ha hermetegn (‚Äú‚Äú) rundt seg, men ellers definerer vi den som vanlig:\n\nTekst <- \"Hei, jeg elsker R! <3\"\n# Denne klassen kan inneholde tekst, men vil f.eks. ikke kunne brukes\n# til matte.\nmean(Tekst)\n\nWarning in mean.default(Tekst): argument is not numeric or logical: returning\nNA\n\n\n[1] NA\n\n\nHer ser dere at vi f√•r en feilmelding, som sier at argumentet ikke er numerisk eller logisk. Funksjonen gir oss derfor resultatet NA, som betyr missing, alts√• at det ikke eksisterer et resultat.\nVi kan ogs√• kreve at et objekt skal ha en viss klasse. Det gj√∏r vi med funksjonen as.\"klassenavn\" (bytt ut ‚Äúklassenavn‚Äù med for eksempel numeric eller character). Det kan f√∏re til noen uforventede resultater. La oss gj√∏re om objektet tall til character:\n\ntall_ch <- as.character(tall)\nmean(tall_ch)\n\nWarning in mean.default(tall_ch): argument is not numeric or logical: returning\nNA\n\n\n[1] NA\n\n\nGrunnen til at vi f√•r en feilmelding her er fordi vi ikke kan ta gjenomsnittet av tekst. Om dere ser i environment st√•r det ogs√• n√• at tall er chr (charater) og det ‚Äú‚Äù rundt alle tegnene.\nDen siste klassen vi kommer til √• bruke ofte (men det finnes flere) er ‚Äúfactor.‚Äù En faktor er en variabel som kan ha flere forh√•ndsdefinerte niv√•er og brukes ofte n√•r vi skal kj√∏re statistiske modeller. En lett m√•te √• forst√• faktorer p√• er √• tenke p√• dem som ordinale variabler, hvor vi kan vite rekkef√∏lgen p√• niv√•ene men ikke avstanden, som for eksempel utdanningsniv√•ene barneskole, ungdomskole, videreg√•ende skole.\nFor √• lage en faktor bruker vi funksjonen factor(). La oss f√∏rst lage en faktor med ulike utdanningsniv√•er:\n\n# Lager en faktorvariabel uten √• sette niv√•er\nskolenivaer <- factor(c(\"Barneskole\", \"Ungdomskole\", \"Videregaende\", \"Videregaende\",\n    \"Universitet\", \"Ungdomskole\", \"Universitet\"))\n\n# Printer alle verdiene\nskolenivaer\n\n[1] Barneskole   Ungdomskole  Videregaende Videregaende Universitet \n[6] Ungdomskole  Universitet \nLevels: Barneskole Ungdomskole Universitet Videregaende\n\n# Printer alle niv√•ene\nlevels(skolenivaer)\n\n[1] \"Barneskole\"   \"Ungdomskole\"  \"Universitet\"  \"Videregaende\"\n\n# Er det noe som skurrer her?\n\nI eksempelet her kan vi se at vi f√∏rst definerer de forskjellige verdiene som er i variabelen. Vi har ikke spesifisert hvilken rekkef√∏lge niv√•ene har. N√•r vi ikke gj√∏r det s√• baserer R rekkef√∏lgen p√• alfabetet. Derfor f√• vi rekkef√∏lgen ‚ÄúBarneskole‚Äù ‚ÄúUngdomskole‚Äù ‚ÄúUniversitet‚Äù ‚ÄúVideregaende‚Äù. For √• unng√• dette s√• kan vi spesifisere faktorniv√•ene:\n\n# Endrer faktorniv√•ene\nskolenivaer <- factor(skolenivaer, levels = c(\"Barneskole\", \"Ungdomskole\",\n    \"Videregaende\", \"Universitet\"))\nskolenivaer\n\n[1] Barneskole   Ungdomskole  Videregaende Videregaende Universitet \n[6] Ungdomskole  Universitet \nLevels: Barneskole Ungdomskole Videregaende Universitet\n\nlevels(skolenivaer)\n\n[1] \"Barneskole\"   \"Ungdomskole\"  \"Videregaende\" \"Universitet\" \n\n\nI toppen her nevnte vi at en vektor var et objekt som inneholdt elementer av samme klasse. S√• langt har vi ogs√• holdt oss til det gjennom √• kunne lage objekter med tekst eller tall. Hva skjer da om vi pr√∏ver √• blande? Vi kan lage et objekt som inneholder b√•de tekst og tall:\n\nteksttall <- c(1, 4, 0, 4, \"Bamse\", \"R\", \"R Seminarer er de BESTE seminarer\",\n    42, \"the answer\")\n\nclass(teksttall)\n\n[1] \"character\"\n\nmean(teksttall[1:4])\n\nWarning in mean.default(teksttall[1:4]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\nSom vi kan se er her klassen blitt character, ogs√• for tallene! Det er fordi at n√•r vi definerer en vektor som inneholder flere klasser, blir det sl√•tt sammen til den klassen som har minst informasjon. Dette kalles ‚Äúimplicit coercion‚Äù, og rekkef√∏lgen g√•r: logical -> integer -> numeric -> complex -> character."
  },
  {
    "objectID": "seminar/seminar1.html#dataframes",
    "href": "seminar/seminar1.html#dataframes",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Dataframes",
    "text": "Dataframes\nNoen ganger har vi lyst til √• sl√• sammen data som er av forskjellige typer. F.eks. kan det v√¶re at vi har data om alder, navn, fylke og vil ha dette som et objekt eller datasett. For √• gj√∏re dette bruker vi data.frames. En dataframe best√•r av flere kolonner, hvor hver kolonne er en vektor. Vektorene kan ha ulik klasse, og det kan for eksempel v√¶re en character vektor og en numerisk vektor. Vi kan tenke p√• disse kolonnene som variabler.\nVi kan tenke p√• hver rad i en dataframe som en observasjon. En observasjon kan for eksempel v√¶re en person, et land i et gitt √•r eller en by. N√•r vi skal kj√∏re analyser i senere seminarer s√• vil vi som regel laste inn datasett/dataframes som andre har laget, men vi kan ogs√• lage dem selv. I dette eksempelet skal vi se p√• navnestatistikk i Oslo hentet fra SSB.no. F√∏rst lager vi vektorer som vi gir passende navn og lagrer i environment:\n\nnavn <- c(\"Mohammed\", \"Jakob\", \"Olav\", \"Martin\", \"Maja\", \"Sofia\", \"Iben\",\n    \"Therese\")\n\nantall <- c(94, 76, 68, NA, 65, 64, 60, NA)\n\nper_tusen <- c(19, 16, 14, NA, 14, 14, 13, NA)\n\nkjonn <- c(\"Gutt\", \"Gutt\", \"Gutt\", \"Gutt\", \"Jente\", \"Jente\", \"Jente\", \"Jente\")\n\nby <- c(\"Oslo\")\n\nEn viktig regel for dataframes er at alle vektorene m√• ha lik lengde. I eksempelet med navnestatistikk i Oslo s√• fantes det ikke data for navnene Martin og Therese (det finnes sikkert, men ikke i tabellen vi s√• i). Om vi mangler data s√• m√• vi finne en m√•te √• ‚Äúfylle‚Äù disse tomme cellene p√•. N√•r vi setter verdien til NA s√• forteller vi R at vi mangler data om akkurat denne observasjonen p√• denne variabelen. Dette er n√∏dvendig for at R skal klare √• matche informasjonen i de ulike vektorene korrekt. For √• sjekke lengden p√• vektoren s√• kan vi se i environment eller bruke funksjonen length().\n\nlength(navn)\n\n[1] 8\n\nlength(by)\n\n[1] 1\n\n\nHer ser vi at alle vektorer har lengde 8 med unntak av by som bare har en. Du kan ogs√• kombinere vektorer med enkeltverdier som med ‚ÄúOslo‚Äù i eksempelet over. N√•r du gj√∏r det vil alle observasjonene f√• verdien ‚ÄúOslo‚Äù p√• variabelen ‚Äúby‚Äù. Dette kan vi se n√¶rmere p√• ved √• lage datasettet. Vi lager datasettet ved hjelp av funksjonen data.frame():\n\nnavnestat <- data.frame(navn, antall, per_tusen, kjonn, by)\n\nI environment vil dere n√• se at det dukker opp en ny rad under ‚ÄúData‚Äù som heter navnestat. N√•r det st√•r 8 obs (observasjoner) av 5 variabler betyr dette at vi har et datasett/dataframe med 8 rader og 5 kolonner. Klikker dere p√• objektet s√• vil dere se dette. Vi kan utforske datasettet n√¶rmere ved √• bruke View() (obs! stor V):\n\nView(navnestat)\n\nF√∏rste observasjonen her er rad 1. Det er navnet Mohammed. Det viktigste med en dataframe er at vi n√• kan kombinere ulik informasjon om samme observasjon p√• en gang. Det er flere m√•ter vi kan bruke dette p√•. La oss f√∏rst se p√• hvordan vi kan gj√∏re enkle analyser av en kolonne.\nTil n√• s√• har vi bare skrevet navnet p√• vektoren for √• hente ut informasjon. N√• som vi har det i en dataframe, m√• vi f√∏rst velge denne, og s√• kolonnen. Det er to m√•ter vi kan gj√∏re dette p√•:\n\n# Med klammeparanteser kan vi velge rad og kolonne. Rad kommer f√∏rst,\n# og s√• kolonnen: `datasett[rader, kolonner]`\nnavnestat[2, 1]\n\n[1] \"Jakob\"\n\n# Skriver vi en tom f√•r vi alle kollonene/radene\nnavnestat[, 2]\n\n[1] 94 76 68 NA 65 64 60 NA\n\nnavnestat[2, ]\n\n   navn antall per_tusen kjonn   by\n2 Jakob     76        16  Gutt Oslo\n\n\nDet blir det fort vanskelig √• huske tallet til plasseringen til en variabel. En mer vanlig m√•te √• hente ut kolonner p√• er med $:\n\n# Her skriver vi f√∏rst navnet p√• dataframen, og s√• variabelen:\nnavnestat$antall\n\n[1] 94 76 68 NA 65 64 60 NA\n\n# La oss pr√∏ve √• f√• ut gjennomsnittlet til antall\nmean(navnestat$antall)\n\n[1] NA\n\n\nHm. Her ser dere at vi fikk NA til svar istedet for det gjennomsnittet vi √∏nsket. NA betyr som sagt bare missing, alts√• at vi ikke har informasjon om noe. Som dere husker s√• mangler vi informasjon om navnene Martin og Therese. N√•r minst en av verdiene er NA vil flere funksjoner returnere NA fordi vi strengt tatt ikke kan vite gjennomsnittet om vi ikke vet alle verdiene. For √• f√• ut et resultat m√• vi derfor fortelle R at vi √∏nsker √• fjerne NA-verdiene, og heller f√• gjenomsnittet av de verdiene som er tilstede. Det gj√∏r vi ved √• legge til argumentet na.rm = TRUE i funksjonen:\n\nmean(navnestat$antall, na.rm = TRUE)\n\n[1] 71.16667\n\nmedian(navnestat$antall, na.rm = TRUE)\n\n[1] 66.5\n\n\nEn lettere m√•te √• f√• ut alle disse p√• er ved √• bruke summary() funksjonen. Da trenger vi heller ikke bruke na.rm, fordi den heller sier hvor mange NA det er i vektoren. summary() kan ogs√• brukes for √• hente ut informasjon om et helt datasett.\n\nsummary(navnestat$antall)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  60.00   64.25   66.50   71.17   74.00   94.00       2 \n\nsummary(navnestat)\n\n     navn               antall        per_tusen       kjonn          \n Length:8           Min.   :60.00   Min.   :13.0   Length:8          \n Class :character   1st Qu.:64.25   1st Qu.:14.0   Class :character  \n Mode  :character   Median :66.50   Median :14.0   Mode  :character  \n                    Mean   :71.17   Mean   :15.0                     \n                    3rd Qu.:74.00   3rd Qu.:15.5                     \n                    Max.   :94.00   Max.   :19.0                     \n                    NA's   :2       NA's   :2                        \n      by           \n Length:8          \n Class :character  \n Mode  :character"
  },
  {
    "objectID": "seminar/seminar1.html#ulike-typer-vektorer-i-r",
    "href": "seminar/seminar1.html#ulike-typer-vektorer-i-r",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Ulike typer vektorer i R",
    "text": "Ulike typer vektorer i R\nDet finnes flere ulike objekter i R. Til n√• har vi blitt introdusert for to av dem: datasett og vektorer. Hva slags objekt det er har noe √• si for hva du kan gj√∏re med det. I tillegg finnes det ulike typer, eller klasser som vi kaller det, av vektorer. I tabellen under finner dere en grov inndeling av ulike typer vektorer i R:\n\n\n\n\n\n\nAtomic vector\nList\n\n\n\n\nnumeric\nblanding\n\n\ninteger\n\n\n\ncharacter\n\n\n\nfactor\n\n\n\nlogical\n\n\n\n\nEn hyppig √•rsak til at en funksjon ikke fungerer, er at en vektor/variabel ikke er i det formatet vi forventet. Tabellen gir en oversikt over variabeltypene vi skal jobbe med. Atomic vector har kun verdier av en type, mens lister kan ha flere typer verdier, samt best√• av flere variabler.\nHvilket format tror du navn, antall og by har?\nDet kan vi sjekke med funksjonen class().\n\nclass(navnestat$navn)\n\n[1] \"character\"\n\nclass(navnestat$antall)\n\n[1] \"numeric\"\n\nclass(navnestat$by)\n\n[1] \"character\"\n\n\nSom dere ser er antall numeric, mens navn og by er character. Her er det hva objektet er lagret som som teller, ikke hvordan det ser ut i datasettet. Selv om noe ser ut som tall i datasettet s√• er det ikke sikkert det er registrert som tall av R. Heldigvis kan dette ofte l√∏ses ved hjelp av en funksjoner som as.numeric(), as.character() og as.factor().\n\n# Her lager vi en ny variabel antall2 der vi ber R lagre alder som\n# character\nnavnestat$antall2 <- as.character(navnestat$antall)\n\nOm vi ser p√• datasettet etter at vi har laget den nye variabelen s√• ser vi at alder og alder2 ser helt like ut. Begge fremst√•r som tall vi kan gj√∏re regneoperasjoner p√•, men bare en av dem er det. Pr√∏v gjerne selv √• kj√∏re funksjonen mean() som regner ut gjennomsnittet p√• alder2."
  },
  {
    "objectID": "seminar/seminar1.html#logiske-tester",
    "href": "seminar/seminar1.html#logiske-tester",
    "title": "Seminar 1 ‚Äì Velkommen!",
    "section": "Logiske tester",
    "text": "Logiske tester\nR kan evaluere logiske utsdagn og bed√∏mme om de er ¬¥TRUE¬¥ eller ¬¥FALSE¬¥.\n\n1 == 2  # tester om 1 er lik 2\n\n[1] FALSE\n\n2 == 2  # tester om 2 er lik 2\n\n[1] TRUE\n\n\"Statsvitenskap\" == \"statsvitenskap\"  # Logiske tester kan ogs√• brukes p√• tekst\n\n[1] FALSE\n\n\"statsvitenskap\" == \"statsvitenskap\"  # R er imidlertid sensitivt til store og sm√• bokstaver\n\n[1] TRUE\n\n1 <= 2  # Tester om 1 er mindre enn eller lik 2\n\n[1] TRUE\n\n1 >= 2  # Tester om 1 er st√∏rre enn eller lik 2\n\n[1] FALSE\n\n1 != 2  # Tester om 1 er ulik 2\n\n[1] TRUE\n\n1 == 2 | 1 == 1  # Tester om en av de to p√•standene 1 er lik 2 eller 1 er lik 1 er sanne\n\n[1] TRUE\n\n1 == 2 & 1 == 1  # Tester om begge de to p√•standene 1 er lik 2 og 1 er lik 1 er sanne\n\n[1] FALSE\n\n\nOversikt over logiske operatorer:\n\n\n\nOperator\nBetydning\n\n\n\n\n==\ner lik\n\n\n<\nmindre enn\n\n\n>\nst√∏rre enn\n\n\n<=\nmindre eller lik\n\n\n>=\nst√∏rre eller lik\n\n\n!=\nikke lik\n\n\n!x\nikke x\n\n\n|\neller\n\n\n&\nog\n\n\n\nVi kommer til √• bruke disse operatorene mye, spesielt n√•r vi gj√∏r endringer i datasett som √• lage nye variabler. Det er derfor viktig at dere forst√•r hvordan disse fungerer. Den beste m√•ten √• f√• denne forest√•else p√• er √• √∏ve."
  },
  {
    "objectID": "seminar/seminar2.html",
    "href": "seminar/seminar2.html",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "",
    "text": "P√• andre seminar skal vi se p√• det f√∏lgende:"
  },
  {
    "objectID": "seminar/seminar2.html#overskrifter-og-tekst",
    "href": "seminar/seminar2.html#overskrifter-og-tekst",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Overskrifter og tekst",
    "text": "Overskrifter og tekst\nHvordan man organiserer et R-script kommer an p√• hva man selv synes er mest oversiktlig, men det er viktig at man klarer √• holde oversikt over hva man har kodet og forst√•r hva man har gjort n√•r man kommer tilbake til et script.\nDet er lurt √• lage overskrifter for √• huske hva du tenker at koden din skal gj√∏re. Dersom du velger overskriftformatet ‚Äú# Overskrift ‚Äî-‚Äù s√• vil R automatisk gi deg muligheten til √• gjemme koden under overskriften. Om du trykker p√• ‚ÄúShow document outline‚Äù i menylinjen til h√∏yre over scriptet ditt kan du ogs√• f√• opp en innholdsfortegnelse basert p√• overskriftene dine.\n\n\n\nRyddig kode gj√∏r det enklere for deg selv og andre n√•r du st√•r fast. Tegneserie fra XKCD: https://xkcd.com/1513/\n\n\nDet kan ogs√• v√¶re lurt √• inkludere kommentarer i scriptet ditt som forklarer hva du gj√∏r. Tekst som ikke skal leses av R skriver man etter emneknagg (#). Vi glemmer fort s√• det er en god id√© √• tenke at du skal kunne se tilbake p√• dette scriptet om et √•r igjen og skj√∏nne hva du har gjort:\n\nTil sist s√• er det lurt √• ikke skrive for mange tegn f√∏r du bytter linje. The tidyverse style guide anbefaler at en begrenser antall tegn til 80 per linje. R teller for hvor mange tegn du har per linje til venstre nedenfor scriptet ditt. Tidyverse sin stilguide inneholder ogs√• flere tips til hvordan man kan skrive lettleselig kode."
  },
  {
    "objectID": "seminar/seminar2.html#laste-inn-ess",
    "href": "seminar/seminar2.html#laste-inn-ess",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Laste inn ESS",
    "text": "Laste inn ESS\nVi kan laste inn data vi skal bruke p√• seminar 2 ‚Äì ess.csv ‚Äì med f√∏lgende kode:\n\ness <- read.csv(\"../data/ess.csv\", encoding = \"UTF-8\")\n\nI denne boka ligger mappen ‚Äúdata‚Äù i en mappe som er et niv√• under der koden for seminar 2 ligger. Derfor starter read.csv() med .., som betyr ‚Äúg√• en mappe tilbake‚Äù. Deretter g√•r vi inn i ‚Äúdata‚Äù-mappen og s√• spesifiserer vi at vi vil lese filen ‚Äúess.csv‚Äù med read.csv(). Du m√• selv tilpasse filplasseringen i denne funksjone til hvor du jobber fra i R og hvor du har lagt filen selv. N√•r filen er lastet inn, skal den ligge i vinduet ‚ÄúEnvironment‚Äù √∏verst til h√∏yre i RStudio. Her er noen nyttige filbanekoder:\n\n\n\n\n\n\n\nKode\nBeskrivelse\n\n\n\n\n\"~/\"\nP√• Mac og Linux er dette ‚ÄúHome‚Äù, p√• Windows er det brukermappen ‚ÄúC:/Users/brukernavn‚Äù\n\n\n\"C:/\"\nFor Windowsbrukere; disken du jobber fra\n\n\n\"./\"\nMappen du er i n√•, kan vises med: getwd(\"./\")\n\n\n\"../\"\nEn mappe tilbake fra der du er n√•: getwd(\"../\")\n\n\n\"./data\"\nFra der jeg er n√•, g√• inn i mappen ‚Äúdata‚Äù\n\n\n\"../data\"\nFra der jeg er n√•, g√• tilbake en mappe og s√• inn i mappen ‚Äúdata‚Äù\n\n\n\"./seminar2/R\"\nFra der jeg er n√•, g√• inn i mappen ‚Äúseminar2‚Äù og s√• inn i mappen ‚ÄúR‚Äù\n\n\n\"../../R\"\nFra der jeg er n√•, g√• tilbake to mapper og s√• inn i mappen ‚ÄúR‚Äù\n\n\n\nDu kan ogs√• validere om du har gjort riktig ved √• kj√∏re:\n\ndim(ess)\n\n[1] 1406  572\n\n\nDet skal da komme opp samme output i din console ‚Äì [1] 1406 572 ‚Äì som betyr at det er 1406 enheter i datasettet og 572 variabler."
  },
  {
    "objectID": "seminar/seminar2.html#kategorisk",
    "href": "seminar/seminar2.html#kategorisk",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Kategorisk",
    "text": "Kategorisk\nN√•r variabler er kategoriske s√• kan egenskapen deles i to eller flere gjensidig utelukkende kategorier. I ESS datasettet v√•rt er variabelen ‚Äúvote‚Äù kategorisk; man har enten stemt, ikke stemt, eller s√• er man ikke berettiget til √• stemme. Dette kan vi se i utklippet fra kodeboken.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen vote\n\n\nVi kan sjekke hvilken klasse variabelen har ved hjelp av class()\n\nclass(ess_subset$vote)\n\n[1] \"integer\"\n\n\nHer f√•r vi opp klassene integer som betyr heltall, mens double betyr at variabelen n√• er lagret som en numerisk variabel. P√• variabler med kategorisk eller ordinalt m√•leniv√• kan vi bruke funksjonen table() til √• f√• oversikt over verdiene:\n\ntable(ess_subset$vote)\n\n\n   1    2    3 \n1156  124  125 \n\n\nSom vi ser her s√• fremst√•r variabelen som om den er kontinuerlig/numerisk med tallverdier, men vi har lest kodeboken og vet at den er kategorisk. Dersom vi vil endre klassen p√• variabelen til en faktor s√• det samsvarer bedre med m√•leniv√•et s√• kan vi bruke funksjonen as.factor() for √• opprette en ny variabel:\n\n# Lager en ny variabel i datasettet som heter vote_factor\ness_subset$vote_factor <- as.factor(ess_subset$vote)\n\nVi kan n√• se n√¶rmere p√• hvilke verdier den nye variabelen vote_factor tar ved hjelp av levels() og klassen ved hjelp av class():\n\n# Sjekker faktorniv√•ene:\nlevels(ess_subset$vote_factor)\n\n[1] \"1\" \"2\" \"3\"\n\n# Sjekker klasse:\nclass(ess_subset$vote_factor)\n\n[1] \"factor\"\n\n\nN√• samsvarer variabelens verdier (Yes, No, osv.) og klasse (factor) bedre med det faktiske m√•leniv√•et til variabelen (kategorisk).2 Vi skal jobbe mer med omkoding av variabler senere."
  },
  {
    "objectID": "seminar/seminar2.html#ordinalniv√•",
    "href": "seminar/seminar2.html#ordinalniv√•",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Ordinalniv√•",
    "text": "Ordinalniv√•\nN√•r variabler er p√• ordinalniv√• kan de deles i to eller flere gjensidig utelukkende kategorier som kan rangeres, men vi kan ikke si noe om avstanden mellom verdiene og en enhets √∏kning har ikke samme betydning. I ESS datasettet v√•r s√• er variabelen interest et eksempel p√• en variabel p√• ordinalniv√•; i utdraget fra kodeboken ser vi at man kan v√¶re ikke interessert, lite interessert, ganske interessert, eller veldig interessert i politikk.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen interest (opprinnelig navn polintr)\n\n\nVi kan sjekke klasse til denne variabelen ogs√•:\n\nclass(ess_subset$interest)\n\n[1] \"integer\"\n\n\nSom vi ser er ogs√• denne variabelen ogs√• registrert som integer. Dersom vi vil bruke denne variabelen som en kategorisk variabel s√• kan vi igjen bruke as.factor for √• f√• variabelens klasse til √• samsvare med m√•leniv√•et:\n\ness_subset$interest_factor <- as.factor(ess_subset$interest)\n\nVi sjekker faktorniv√•er og klasse igjen:\n\n# Sjekker faktorniv√•ene:\nlevels(ess_subset$interest_factor)\n\n[1] \"1\" \"2\" \"3\" \"4\"\n\n# Sjekker klasse:\nclass(ess_subset$interest_factor)\n\n[1] \"factor\"\n\n\nDette ser ogs√• fint ut. Som dere vet fra forelesning s√• er behandler man ofte variabler p√• ordinalniv√• som enten kategorisk eller kontinuerlig m√•leniv√•. Dersom vi ville beholdt denne som en kontinuerlig variabel s√• hadde vi ikke trengt √• omkode den ved hjelp av as.factor()."
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlig",
    "href": "seminar/seminar2.html#kontinuerlig",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Kontinuerlig",
    "text": "Kontinuerlig\nKontinuerlige variabler kan rangeres, har samme avstand mellom alle verdier og en enhets √∏kning betyr alltid det samme. Her er det alts√• snakk om variabler med faktiske tallverdier. I ESS datasettet v√•rt s√• er variabelen ‚Äúnews‚Äù kontinuerlig. Som vi kan se i utdraget fra kodeboken s√• m√•ler variabelen hvor mange minutter man bruker p√• nyheter hver dag. Det er et minutts avstand mellom hver verdi, og en √∏kning p√• en enhet vil alltid bety en √∏kning p√• et minutt.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen news (opprinnelig navn nwspol)\n\n\nVi kan sjekke klassen her ogs√•:\n\nclass(ess_subset$news)\n\n[1] \"integer\"\n\nis.numeric(ess_subset$news)\n\n[1] TRUE\n\n\nDenne variabelen er double og skal v√¶re det s√• her er alt i orden.\nVi vil oppfordre dere til √• v√¶re obs og alltid sjekke at klassen p√• en variabel dere skal bruke stemmer overens med m√•leniv√•et.3 I mange datasett f√•r kategoriske og ordinale variabler ofte tall istedenfor kategorinavn som verdier og lastes inn som klassen numeric. Dette gj√∏r at kategoriske variabler kan fremst√• som at de har et h√∏yere m√•leniv√• enn de faktisk har i R. Derfor er det alltid viktig √• ogs√• sjekke kodeboken for √• se hvilket m√•leniv√• variabelen faktisk har. Det kommer ikke til √• st√• ‚Äúdenne variabelen har kategorisk m√•leniv√•‚Äù s√• dere m√• gj√∏re en selvstendig vurdering basert p√• hvilke verdier variabelen har."
  },
  {
    "objectID": "seminar/seminar2.html#kategoriske-variabler",
    "href": "seminar/seminar2.html#kategoriske-variabler",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Kategoriske variabler",
    "text": "Kategoriske variabler\nR har ingen innebygd funksjon for √• finne modusverdien. Ved √• s√∏ke p√• internett s√• finner du fort mange ulike funksjoner du kan bruke, men for √• gj√∏re det enkelt bruker vi bare table(). Funksjonen table() gir oss en frekvenstabell, mens prop.table gj√∏r om frekvenstabellen til andeler. ESS datasettet mangler data for noen observasjoner. Ved √• ta med useNA = \"always\" i table() s√• f√•r vi ogs√• denne informasjonen i tabellen:4\n\ntable(ess_subset$vote, useNA = \"always\")\n\n\n   1    2    3 <NA> \n1156  124  125    1 \n\nprop.table(table(ess_subset$vote))\n\n\n         1          2          3 \n0.82277580 0.08825623 0.08896797 \n\nprop.table(table(ess_subset$vote, useNA = \"always\"))\n\n\n           1            2            3         <NA> \n0.8221906117 0.0881934566 0.0889046942 0.0007112376"
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlige-variabler",
    "href": "seminar/seminar2.html#kontinuerlige-variabler",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Kontinuerlige variabler",
    "text": "Kontinuerlige variabler\n\n# Finner minimumsverdi (det laveste antall minutter brukt\n# p√• nyheter)\nmin(ess_subset$news, na.rm = TRUE)  # na.rm = TRUE sier at missing skal droppes i beregningen\n\n[1] 0\n\n# Finner maksimumsveriden (den h√∏yeste antall minutter\n# brukt p√• nyheter)\nmax(ess_subset$news, na.rm = TRUE)\n\n[1] 1109\n\n# Finner gjennomsnittlig antall minutter\nmean(ess_subset$news, na.rm = TRUE)\n\n[1] 104.1006\n\n# Finner median\nmedian(ess_subset$news, na.rm = TRUE)\n\n[1] 60\n\n# Finner standardavviket\nsd(ess_subset$news, na.rm = TRUE)\n\n[1] 155.5571\n\n# Finner varians\nvar(ess_subset$news, na.rm = TRUE)\n\n[1] 24198.01\n\n# Finner kvantilverdiene\nquantile(ess_subset$news, na.rm = TRUE)\n\n  0%  25%  50%  75% 100% \n   0   30   60  120 1109 \n\n# Finner forskjellig deskriptiv statistikk for en variabel\nsummary(ess_subset$news)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    0.0    30.0    60.0   104.1   120.0  1109.0      34"
  },
  {
    "objectID": "seminar/seminar2.html#kategoriske-variabeler",
    "href": "seminar/seminar2.html#kategoriske-variabeler",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Kategoriske variabeler",
    "text": "Kategoriske variabeler\n\nS√∏ylediagram og kakediagram med en variabel\nHvordan kan vi visualisere hvordan fordelingen av politisk interesse er? Her kan vi bruke geom_bar til √• lage et s√∏ylediagram (bar chart). Et s√∏ylediagram viser antall observasjoner av hver verdi. Vi bruker her den variabelen vi lagde tidligere med ‚Äúriktig‚Äù m√•leniv√•.\n\nggplot(ess_subset, aes(x = interest_factor)) + geom_bar()\n\n\n\n\nDersom vi ikke √∏nsker √• gi missingverdiene (NA) en egen s√∏yle s√• kan vi bruke filter() til √• fjerne disse:\n\ness_subset %>%\n    filter(is.na(interest_factor) == FALSE) %>%\n    ggplot(., aes(x = interest_factor)) + geom_bar() + theme(axis.text.x = element_text(angle = 60,\n    hjust = 1))\n\n\n\n\nEt alternativ til s√∏ylediagram er kakediagram (pie chart):\n\ness_subset %>%\n    filter(is.na(interest_factor) == FALSE) %>%\n    ggplot(., aes(x = \"\", y = interest, fill = interest_factor)) +\n    geom_bar(stat = \"identity\", width = 1) + coord_polar(\"y\",\n    start = 0) + theme_void() + scale_fill_grey()\n\n\n\n\n\n\nS√∏ylediagram med to variabler\nHvor mange innenfor hvert niv√• av politisk interesse stemte? Vi kan bruke geom_bar() igjen, men vi sier at vi ogs√• vil se fordelingen av hvordan respondentene stemte innenfor hvert niv√• av politisk interesse med (aes(fill = vote)). S√• sier vi at vi vil at det skal v√¶re en s√∏yle for de ulike alternativene for vote med position = \"dodge\".\n\ness_subset %>%\n    filter(is.na(interest_factor) == FALSE & is.na(vote_factor) ==\n        FALSE) %>%\n    ggplot(., aes(x = interest_factor)) + geom_bar(aes(fill = vote_factor),\n    position = \"dodge\") + theme(axis.text.x = element_text(angle = 60,\n    hjust = 1))"
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlige-variabler-1",
    "href": "seminar/seminar2.html#kontinuerlige-variabler-1",
    "title": "Seminar 2 ‚Äì Laste og jobbe med data",
    "section": "Kontinuerlige variabler",
    "text": "Kontinuerlige variabler\n\nHistogram\nHvordan fordeler respondentenes alder og tiden de bruker p√• nyheter seg? Disse variablene er kontinuerlige, s√• vi kan bruke geom_histogram for √• lage et histogram. Her gj√∏r vi det med variabelen news.\n\nggplot(ess_subset, aes(x = news)) + geom_histogram(bins = 5) +\n    ggtitle(\"Histogram med fem s√∏yler (bins) og frekvens\")\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\nggplot(ess_subset, aes(x = news)) + geom_histogram(binwidth = 10) +\n    ggtitle(\"Histogram med s√∏ylebredde (binwidth) p√• 10 og frekvens\")\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\nEt histogram viser hvor mange enheter det er i hver kategori. Vi kan enten spesifisere hvor mange s√∏yler vi vil ha (bins) eller hvor stor hver s√∏yle skal v√¶re (bindwidth). Vi kan ogs√• velge √• plotte density fremfor count. Da f√•r vi histogrammer tilsvarende figur 6.5 i Kellsted og Whitten:\n\nggplot(ess_subset, aes(x = news, y = ..density..)) + geom_histogram(bins = 5) +\n    ggtitle(\"Histogram med fem s√∏yler (bins) og density\")\n\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\n‚Ñπ Please use `after_stat(density)` instead.\n\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\nggplot(ess_subset, aes(x = news, y = ..density..)) + geom_histogram(binwidth = 10) +\n    ggtitle(\"Histogram med s√∏ylebredde (binwidth) 10 og density\")\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\nBoksplott\nVi kan lage et boksplott med geom_boxplot. Et boksplott viser hvordan en kontinuerlig variabel er fordelt. Boksen representerer spennet til f√∏rste (25 % ) og tredje (75 %) kvartil, mens streken midt i boksen viser andre (50 %) kvartil (ogs√• kjent som median). For √• finne kvartilene s√• ordner vi observasjonene i stigende rekkef√∏lge og deler dem inn i fire deler med like mange observasjoner i hver. F√∏rste kvartil angir grensen mellom f√∏rste og andre fjerdedel. Det betyr at 25 % av observasjonene har en verdi som er lavere enn verdien til f√∏rste kvartil, mens 75 % har en verdi som er h√∏yere. Tilsvarende utgj√∏re tredje kvartil grensen mellom andre og tredje fjerdedel, og vi kan si at 75 % av observasjonene har en verdi som er lavere enn verdiene til tredje kvaritl, mens 25 % har en verdi som er h√∏yere.\nPrikkene i grafen angir uteliggere. Uteliggere er observasjoner som har enten veldig h√∏ye eller veldig lave verdier relativt til de andre observasjonene. I R beregnes disse utfra kvartilbredden. Kvartilbredden er differansen mellom tredje og f√∏rste kvartil. Alle observasjoner som er lavere enn f√∏rste kvartil minus 1,5 ganger kvartilbredden eller h√∏yere enn tredje kvartil pluss 1,5 ganger kvartilbredden regnes som uteliggere.\n\nggplot(ess_subset, aes(x = news, y = vote_factor)) + geom_boxplot() +\n    theme_minimal()\n\nWarning: Removed 34 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\nHvis dere vil utforske hvordan man kan tilpasse de ulike diagrammene vi har sett p√• og mange andre, kan denne siden v√¶re nyttig: https://www.r-graph-gallery.com/index.html"
  },
  {
    "objectID": "seminar/seminar3.html",
    "href": "seminar/seminar3.html",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "",
    "text": "P√• dette seminaret skal vi gjennom:"
  },
  {
    "objectID": "seminar/seminar3.html#matematisk-omkoding",
    "href": "seminar/seminar3.html#matematisk-omkoding",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Matematisk omkoding",
    "text": "Matematisk omkoding\nF√∏rst skal vi l√¶re √• kode om variablene ved √• bruke matematiske omkoding. For √• vise dette bruker vi variabelem year. Ved hjelp av summary() s√• finner vi ut at den laveste verdien p√• variabelen er √•ret 1952. Det er √•ret observasjonen ble gjort. Vi vil gj√∏re dette √•ret til √•r null, mens de andre verdiene p√• variablen skal bli hvor mange √•r etter √•r null ble observasjonen gjort.\n\n# Sjekker summary for opprinnelige variabel\nsummary(gapminder$year)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1952    1966    1980    1980    1993    2007 \n\n# spennet er 2007-1952, dvs. 55 √•r\n2007 - 1952\n\n[1] 55\n\n# Legger til ny variabel i datasettet\ngapminder$year_1952 <- gapminder$year - 1952\n\n# Sjekker summary for ny variabel\nsummary(gapminder$year_1952)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   13.75   27.50   27.50   41.25   55.00 \n\n\nS√• unders√∏ker vi om omkodingen er blitt gjort riktig ved √• bruke funksjonen table(). Ofte, men ikke alltid, n√•r man omkoder en variabel og krysstabulerer den nye variabelen med den gamle, vil frekvensene legge seg langs diagonalen i tabellen som her:\n\n# Lager en tabell med opprinnelig og ny variabel:\ntable(gapminder$year_1952, gapminder$year, useNA = \"always\")\n\n      \n       1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 <NA>\n  0     142    0    0    0    0    0    0    0    0    0    0    0    0\n  5       0  142    0    0    0    0    0    0    0    0    0    0    0\n  10      0    0  142    0    0    0    0    0    0    0    0    0    0\n  15      0    0    0  142    0    0    0    0    0    0    0    0    0\n  20      0    0    0    0  142    0    0    0    0    0    0    0    0\n  25      0    0    0    0    0  142    0    0    0    0    0    0    0\n  30      0    0    0    0    0    0  142    0    0    0    0    0    0\n  35      0    0    0    0    0    0    0  142    0    0    0    0    0\n  40      0    0    0    0    0    0    0    0  142    0    0    0    0\n  45      0    0    0    0    0    0    0    0    0  142    0    0    0\n  50      0    0    0    0    0    0    0    0    0    0  142    0    0\n  55      0    0    0    0    0    0    0    0    0    0    0  142    0\n  <NA>    0    0    0    0    0    0    0    0    0    0    0    0    0\n\n\nVi kan ogs√• endre retningen p√• verdienes ved matematisk omkoding. Da ganger vi variablene med (-1) og plusser p√• antall verdier variablene har. N√• blir 2007 √•r null.\n\n# Endrer retning p√• variabelen:\ngapminder$year_2007 <- (gapminder$year_1952 * -1) + 55\n\n# Alternativt:\ngapminder$year_2007 <- 55 - gapminder$year_1952\n\n# Sjekker at det ble riktig med table():\ntable(gapminder$year_1952, gapminder$year_2007, useNA = \"always\")\n\n      \n         0   5  10  15  20  25  30  35  40  45  50  55 <NA>\n  0      0   0   0   0   0   0   0   0   0   0   0 142    0\n  5      0   0   0   0   0   0   0   0   0   0 142   0    0\n  10     0   0   0   0   0   0   0   0   0 142   0   0    0\n  15     0   0   0   0   0   0   0   0 142   0   0   0    0\n  20     0   0   0   0   0   0   0 142   0   0   0   0    0\n  25     0   0   0   0   0   0 142   0   0   0   0   0    0\n  30     0   0   0   0   0 142   0   0   0   0   0   0    0\n  35     0   0   0   0 142   0   0   0   0   0   0   0    0\n  40     0   0   0 142   0   0   0   0   0   0   0   0    0\n  45     0   0 142   0   0   0   0   0   0   0   0   0    0\n  50     0 142   0   0   0   0   0   0   0   0   0   0    0\n  55   142   0   0   0   0   0   0   0   0   0   0   0    0\n  <NA>   0   0   0   0   0   0   0   0   0   0   0   0    0"
  },
  {
    "objectID": "seminar/seminar3.html#omkoding-med-ifelse",
    "href": "seminar/seminar3.html#omkoding-med-ifelse",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Omkoding med ifelse()",
    "text": "Omkoding med ifelse()\nDen funksjonen vi bruker mest til omkoding, er ifelse(). Funksjonen kan brukes p√• numeriske og kategoriske variabler. Syntaksen til denne funksjonen kan forklares som f√∏lger:\n\ndata$nyvar <- ifelse(test = data$variabel == \"some logical condition\",\n                     yes  = \"what to return if 'some condition' is TRUE\",\n                     no   = \"what to return if 'some condition' is FALSE\")\n\nifelse() kan for eksempel bruker til √• lage en ny variabel som tar verdien 1 om observasjonen har en verdi som er st√∏rre enn gjennomsnittet og null ellers. Gjennomsnittet finner du ved √• bruke funksjonen mean(). Under fyller vi inn betingelsen (condition), hvilken verdi ny variabel skal dersom betingelsen er oppfylt (yes) og hvilken verdi ny variabel skal ha dersom betingelsen ikke er oppfylt (no). Vanligvis vil vi ikke skrive test =, yes = og no =, men vi har tatt det med her for √• gj√∏re det lettere √• koble de to:\n\ngapminder$lifeExp_num <- ifelse(test = gapminder$lifeExp > mean(gapminder$lifeExp, na.rm = TRUE),\n                                yes = 1,\n                                no = 0)\n\nHer har vi laget en ny variabel ‚Äì gapminder$lifeExp_num ‚Äì som tar verdien 1 om land-√•r-enheten har over gjennomsnittlig verdi p√• variabelen gapminder$lifeExp og verdien 0 hvis land-√•r-enheten ikke har over gjennomsnittlig verdi p√• gapminder$lifeExp."
  },
  {
    "objectID": "seminar/seminar3.html#omkoding-med-case_match",
    "href": "seminar/seminar3.html#omkoding-med-case_match",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Omkoding med case_match()",
    "text": "Omkoding med case_match()\nDersom vi vil omkode en variabel med flere variabler s√• kan vi gj√∏re det med flere ifelse() n√∏stet i hverandre. Det kan imidlertid bli veldig mye kode. Et alternativ er √• kombinere mutate() og case_match(). mutate() er en funksjon i tidyverse vi bruker for √• lage nye variabler. case_match() er ogs√• en del av tidyverse og den brukes til √• endre verdier p√• variabler. Syntaksen til kombinasjonen av mutate() og case_match() er:\n\ndata %>% \n  mutate(nyvariabel = case_match(gammelvariabel, \n                                 gammel_verdi1 ~ ny_verdi1, \n                                 gammel_verdi2 ~ ny_verdi2))\n\nI dette eksempelet skal vi lage en ny variabel lifeExp_char der vi omkoder lifeExp_num til ‚Äúhigh‚Äù dersom den gamle variabelen er 1 og ‚Äúlow‚Äù dersom den er 0. Ettersom funksjonen vi skal bruker ligger i pakken tidyverse s√• m√• vi aller f√∏rst laste inn pakken med library()\n\nlibrary(tidyverse)\n\ngapminder <- gapminder %>% \n  mutate(lifeExp_char = case_match(lifeExp_num, \n                               1  ~ \"high\", \n                               0  ~ \"low\"))\n\nVi sjekker med en tabell at det ble riktig:\n\ntable(gapminder$lifeExp_char, gapminder$lifeExp_num)\n\n      \n         0   1\n  high   0 895\n  low  809   0"
  },
  {
    "objectID": "seminar/seminar3.html#steg-1-fortell-ggplot-hvor-vi-vil-hente-data-fra",
    "href": "seminar/seminar3.html#steg-1-fortell-ggplot-hvor-vi-vil-hente-data-fra",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Steg 1: Fortell ggplot() hvor vi vil hente data fra",
    "text": "Steg 1: Fortell ggplot() hvor vi vil hente data fra\nSteg 1 er √• fortelle ggplot hvor den skal hente data fra. Det gj√∏r vi ved √• spesifisere data = argumentet i funksjonen ggplot(). I v√•rt tilfelle heter datasettet ‚Äúgapminder‚Äù og vi skriver:\n\nggplot(data = gapminder)\n\n\n\n\nHva skjer n√•r vi kj√∏rer koden n√•? Vi f√•r et helt tomt plott. Mer info m√• til!"
  },
  {
    "objectID": "seminar/seminar3.html#steg-2-fortell-ggplot-hvilken-sammenheng-vi-vil-plotte",
    "href": "seminar/seminar3.html#steg-2-fortell-ggplot-hvilken-sammenheng-vi-vil-plotte",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Steg 2: Fortell ggplot hvilken sammenheng vi vil plotte",
    "text": "Steg 2: Fortell ggplot hvilken sammenheng vi vil plotte\nDet neste vi gj√∏r er √• fortelle ggplot hva vi vil m√•le p√• x- og y-aksen. N√• skal vi starte med et stolpediagram, der vi vil se hvor mange observasjoner det er i datasettet fordelt p√• de fem kontinentene. Da trenger vi bare √• gi ggplot beskjed om at vi vil ha continent p√• x-aksen. Y-aksen v√•r blir automatisk til antall (count). Senere i dette seminaret skal vi se p√• et eksempel hvor vi gir informasjon om begge aksene.\nInne i ggplot() hvor vi har fortalt hvilket datasett vi vil bruke, s√• legger vi til en mapping. aes() st√•r for aestethics, og det vi gj√∏r ved bruk av aes() er √• fortelle ggplot hvilke variabler vi vil visualisere. Vi forteller ggplot at vi vil at variabelen continent skal vises p√• x-aksen.\n\nggplot(data = gapminder, mapping = aes(x = continent))\n\n\n\n\nDet vi skriver i aes() kobler variabler til ting du ser i plottet. Det kan for eksempel v√¶re x- og y-verdier (x = variabelnavn, y = variabelnavn), farger (color = variabelnavn), former (shape = variabelnavn) eller st√∏rrelse (size = variabelnavn)."
  },
  {
    "objectID": "seminar/seminar3.html#steg-3-fortell-ggplot-hvordan-du-vil-illustrere-sammenhengen",
    "href": "seminar/seminar3.html#steg-3-fortell-ggplot-hvordan-du-vil-illustrere-sammenhengen",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Steg 3: Fortell ggplot hvordan du vil illustrere sammenhengen",
    "text": "Steg 3: Fortell ggplot hvordan du vil illustrere sammenhengen\nN√•r vi kj√∏rer koden, s√• ser vi at kontinentene er p√• plass, men vi f√•r likevel ikke noe s√¶rlig informasjon fra plottet. Hva mangler? Vi m√• skrive hva slags plott vi vil lage. Vi vil lage et stolpediagram, og velger geom_bar(). Hvis du pr√∏ver √• skrive inn geom_ vil du se at du f√•r en hel rekke forslag til ulike plott. Flere av disse skal vi komme tilbake til.\n\nggplot(gapminder, aes(x = continent)) + \n  geom_bar()\n\n\n\n\nDa har vi f√•tt opp et plott som viser observasjonene i datasettet fordelt p√• kontinenter. Vi kan dobbeltsjekke at dette ser riktig ut ved √• lage et summary av variabelen.\n\nsummary(gapminder$continent)\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n\n\nDet ser fint ut. Vi kan ogs√• legge inn andre typer av aestetics i mappingen. Her er det flere muligheter, som dere vil bli kjent med etter hvert. √ân av dem er √• bruke ulike farger for √• gi informasjon. Hvis vi vil at hvert kontinent skal f√• sin egen farge, s√• kan vi gj√∏re det slik:\n\nggplot(gapminder, aes(x = continent, fill = continent)) + \n  geom_bar()"
  },
  {
    "objectID": "seminar/seminar3.html#steg-4-legg-til-geom_-etter-behov-en-etter-en.",
    "href": "seminar/seminar3.html#steg-4-legg-til-geom_-etter-behov-en-etter-en.",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Steg 4: Legg til geom_ etter behov en etter en.",
    "text": "Steg 4: Legg til geom_ etter behov en etter en.\nVi kan legge til flere geom_-elementer i plottet v√•rt ved √• bruke +. Vi kan for eksempel legge til en linje som indikerer gjennomsnittlig antall observasjoner per land. Da legger vi f√∏rst til en variabel som angir antall observasjoner per land i datasettet. Dette gj√∏r vi ved hjelp av funksjonen add_count():\n\ngapminder <- gapminder %>% \n  add_count(continent)\n\nVi kan se i datasettet v√•rt at vi har f√•tt en ny variabel n. Denne angir antall observasjoner per kontinent i datasettet v√•rt. For √• legge til en linje som indikerer gjenomsnittlig antall observasjoner bruker vi geom_hline() (h for horisontal linje). I aes() gir vi ggplot informasjon om hvor denne linjen skal krysse y-aksen:\n\nggplot(data = gapminder, aes(x = continent, fill = continent)) + \n  geom_bar() +\n  geom_hline(aes(yintercept = mean(n)))"
  },
  {
    "objectID": "seminar/seminar3.html#steg-5-bruk-funksjoner-til-√•-justere-skala-etiketter-tittel-o.l..",
    "href": "seminar/seminar3.html#steg-5-bruk-funksjoner-til-√•-justere-skala-etiketter-tittel-o.l..",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Steg 5: Bruk funksjoner til √• justere skala, etiketter, tittel o.l..",
    "text": "Steg 5: Bruk funksjoner til √• justere skala, etiketter, tittel o.l..\nVi kan ogs√• endre teksten p√• x- og y-aksen, og gi plottet en tittel ved √• legge til labs(), fjerne boksen med informasjon om farger og navn p√• h√∏yre side ved hjelp av theme(legend.position = \"none\") og gj√∏re bakgrunnen litt penere med theme_bw():\n\nggplot(gapminder, aes(x = continent, fill = continent)) + \n  geom_bar() +\n  geom_hline(aes(yintercept = mean(n))) +\n  labs(x = \"\", \n       y = \"Antall land-√•r-observasjoner\", \n       title = \"Antall observasjoner per kontinent\",\n       caption = \"Gjennomsnittlig antall observasjoner er gitt ved den horisontale linjen\") +\n  theme_bw() +\n  theme(legend.position = \"none\") \n\n\n\n\nDa har vi g√•tt gjennom det helt grunnleggende i ggplot. Dette er en pakke med veldig mange ulike muligheter, og man blir bedre kjent med de for hver gang man bruker den. Vi anbefaler dere √• pr√∏ve dere fram, og sjekke ut noen av ressursene som vi linker til i bunnen av dokumentet. Kj√∏r gjerne deler av plottet for √• se hva de ulike linjene gj√∏r, google dere frem osv."
  },
  {
    "objectID": "seminar/seminar3.html#histogrammer",
    "href": "seminar/seminar3.html#histogrammer",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Histogrammer",
    "text": "Histogrammer\nN√•r vi unders√∏ker ulike plot kan vi skrive plot_le + i stedet for ggplot(data, aes(lifeExp)) + fordi sistnevne informasjon er lagret i f√∏rstnevnte objekt. Dette sparer oss for en del kode. For en kontinuerlig variabel s√• kan det v√¶re mer nyttig med et histogram, som lager stolper for intervaller:\n\nplot_le +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nHvis vi ikke sier noe annet, s√• kommer ggplot til √• velge hvor stort hvert intervall skal v√¶re. Vi kan sette hver stolpe til √• v√¶re ett √•r bred ved √• skrive inn binwidth = 1:\n\nplot_le +\n  geom_histogram(binwidth = 1)\n\n\n\n\nHvis vi vil se hvordan dette fordeler seg p√• hvert kontinent, s√• kan vi legge inn fill:\n\nplot_le +\n  geom_histogram(aes(fill = continent),\n                 binwidth = 1, \n                 alpha = 0.5) +\n  theme_bw()\n\n\n\n\nDette gir oss en viss oversikt over hvordan forventet levealder varierer mellom kontinentene, men hvis vi vil se n√¶remere p√• dette s√• kan et boxplot for forventet levealder per kontinent v√¶re et bedre alternativ."
  },
  {
    "objectID": "seminar/seminar3.html#boxplot",
    "href": "seminar/seminar3.html#boxplot",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Boxplot",
    "text": "Boxplot\nfor √• lage et boxplot s√• spesifiserer vi y-aksen ved hjelp av aes(y = continent) i geom_boxplot:\n\nplot_le + \n  geom_boxplot(aes(y = continent))\n\n\n\n\nHer er et eksempel p√• hvor mye finere plottet kan bli med litt flere kodelinjer:\n\nplot_le + \n  geom_boxplot(aes(y = continent)) +\n  theme_bw() +\n  labs(title = \"Boxplot for forventet levealder per kontinent\",\n       x = \"Forventet levealder\",\n       y = \"\") +\n  theme(legend.position = \"none\")"
  },
  {
    "objectID": "seminar/seminar3.html#density-plottettshetsplot",
    "href": "seminar/seminar3.html#density-plottettshetsplot",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Density plot/tettshetsplot",
    "text": "Density plot/tettshetsplot\nEn annen metode kan v√¶re √• bruke et density plot/tetthetsplott:\n\nplot_le + \n  geom_density()\n\n\n\n\nInne i parentesen til plottypen kan vi legge til spesifikasjoner om tykkelse p√• linja, farge osv.\n\nplot_le + \n  geom_density(linewidth = 1.5, fill = \"pink\", alpha = 0.3)\n\n\n\n\nHva skjer hvis vi endrer 1) alpha til 1 og 2) size til 0.5?\n\nplot_le + \n  geom_density(linewidth = 0.5, fill = \"pink\", alpha = 1)\n\n\n\n\nHvis du √∏nsker √• separere plottene, slik at de ulike kontinentene ikke ligger over hverandre, men f√•r hvert sitt plott, s√• kan du legge til en facet_wrap:\n\nplot_le + \n  geom_density(linewidth = 0.5, fill = \"pink\", alpha = 1) +\n  facet_wrap(vars(continent)) +\n  theme_bw()"
  },
  {
    "objectID": "seminar/seminar3.html#spredningsplot",
    "href": "seminar/seminar3.html#spredningsplot",
    "title": "Seminar 3 ‚Äì Omkoding, subsetting og visualisering",
    "section": "Spredningsplot",
    "text": "Spredningsplot\nMed et spredningsplot (scatterplot) kan vi vise sammenhengen mellom to kontinuerlige variabler. Her m√• vi gi ggplot informasjon om hvilken variabel som skal mappes p√• x-aksen og p√• y-aksen. For √• lage scatterplottet bruker vi geom_point.\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) + \n  geom_point()\n\n\n\n\nVi kan legge til en linje som viser trenden1 i observasjonene ved √• bruke geom_smooth:\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +\n  geom_point() + \n  geom_smooth()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nSkille kontinentene fra hverandre ved bruk av ulike farger:\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap, col = continent)) +\n  geom_point() + \n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nVi kan legge inn en facet_wrap() for at det skal se litt ryddigere ut, og samtidig gi geom_smooth() en farge som vises bedre.\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap, col = continent)) +\n  geom_point() + \n  geom_smooth(colour = \"black\") + \n  facet_wrap(~ continent) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nHer kan vi repetere hvordan vi legger til nye titler til x- og y-aksen, samt tittel for hele plottet:\n\nggplot(gapminder, \n       aes(x = lifeExp, y = gdpPercap, col = continent)) +\n  geom_point() + \n  geom_smooth(colour = \"black\") + \n  facet_wrap(vars(continent)) +\n  labs(x = \"Forventet levealder\", \n       y = \"GDP per capita\", \n       title = \"Et plot med Gapminderdata\") +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'"
  },
  {
    "objectID": "seminar/seminar6.html",
    "href": "seminar/seminar6.html",
    "title": "STV1020",
    "section": "",
    "text": "OBS! DETTE KAPITTELET ER IKKE FERDIG"
  },
  {
    "objectID": "seminar/seminar4.html",
    "href": "seminar/seminar4.html",
    "title": "Seminar 4 ‚Äì Missingverdier, statistikk og bivariate sammenhenger",
    "section": "",
    "text": "I l√∏pet av dette seminaret skal vi:"
  },
  {
    "objectID": "seminar/seminar4.html#pakker-og-funksjoner",
    "href": "seminar/seminar4.html#pakker-og-funksjoner",
    "title": "Seminar 4 ‚Äì Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Pakker og funksjoner",
    "text": "Pakker og funksjoner\nN√•r vi jobber i R s√• bruker vi mange funksjoner. Noen av disse, som for eksempel mean() og load() er en del av base R. Det betyr at vi ikke trenger √• installere og laste inn noen ekstra pakker for at de skal virker. Andre funksjoner som for eksempel %>%, read.dta() og ggplot() ligger i pakker. Da m√• vi installere og laste inn disse pakkene for √• kunne bruke funksjonen.\nInstallere pakker: Vi bruker install.packages(\"pakkenavn\") for √• installere pakker. Dette trenger vi bare √• gj√∏re √©n gang.\nLaste inn pakker: Vi bruker library(pakkenavn) for √• laste inn en pakke. Dette m√• vi gj√∏re hver gang vi √•pner Rstudio p√• nytt eller √•pner en ny sesjon. Dersom du f√•r opp en feilmelding som ‚ÄúError in library(pakkenavn) : there is no package called ‚Äòpakkenavn‚Äô‚Äù s√• indikerer det at du ikke har installert pakken. Da m√• du kj√∏re install.packages(\"pakkenavn\") f√∏r du fors√∏ker library(pakkenavn) igjen.\nF√∏rst installerer vi nye pakker og laster inn pakkene vi skal bruke i dagens seminar:\n\n# Installerer nye pakker\ninstall.packages(\"stargazer\")\ninstall.packages(\"gmodels\")\ninstall.packages(\"scales\")\n\n\n# Laster inn pakker \nlibrary(tidyverse)\nlibrary(stargazer)\nlibrary(gmodels)\nlibrary(scales)"
  },
  {
    "objectID": "seminar/seminar4.html#tabellanalyse",
    "href": "seminar/seminar4.html#tabellanalyse",
    "title": "Seminar 4 ‚Äì Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Tabellanalyse",
    "text": "Tabellanalyse\nDersom hypotesen v√•r best√•r av to kategoriske variabler s√• kan vi presentere og teste sammenhengen ved hjelp av en krysstabell. Da bruker vi funksjonen table(). I dette eksempelet skal vi bruke samme data som Kellsted og Whitten bruker i sitt eksempel. Hypotesen vi vil teste er alts√• om kj√∏nn (X) har en sammenheng med hvordan man stemmer (Y) i amerikanske presidentvalg.\nDet f√∏rste vi gj√∏r er √• laste inn datasettet ANES2016small. Dette er samme datasett som Kellstedt og Whitten bruker. Datasettet er i .Rdata-format s√• da bruker vi funksjonen load til √• laste inn data:\n\n# Bytt ut det som st√•r i hermetegn med filbanen og filnavnet p√• din maskin:\nload(\"../data/ANES2016small.RData\")\n\nVi skal omkode variablene s√• verdiene blir litt mer intuitive. Det gj√∏r vi ved hjelp av mutate() og recode. mutate() forteller R at vi vil opprette nye variabler. Vi skriver inn navnet p√• den nye variabelen, et likhetstegn og s√• hva den nye variabelen skal inneholde. Ved hjelp av recode() forteller vi R at den nye variabelen skal ta utgangspunkt i en gammel variabel, men ta andre verdier:\n\nANES2016small <- ANES2016small %>% \n  mutate(vote = case_match(V2Trump,\n                           1 ~ \"Trump\",\n                           0 ~ \"Clinton\"), \n         gender = case_match(female, \n                             0 ~ \"Male\", \n                             1 ~ \"Female\"))\n\n# Sjekker at omkodingen ble riktig:\ntable(ANES2016small$female, ANES2016small$gender, useNA = \"always\")\n\n      \n       Female Male <NA>\n  0         0 1987    0\n  1      2232    0    0\n  <NA>      0    0   52\n\n# Sjekker at omkodingen ble riktig:\ntable(ANES2016small$V2Trump, ANES2016small$vote, useNA = \"always\")\n\n      \n       Clinton Trump <NA>\n  0       1290     0    0\n  1          0  1178    0\n  <NA>       0     0 1803\n\n\nDet neste vi skal gj√∏re er √• lage en krysstabell med absolutte antall. Da bruker vi funksjonen table(). I dag skal vi lagre krysstabellen i et eget objekt for √• bruke den videre. N√•r vi lagrer krysstabellen som et objekt vil den ikke bli printet automatisk i console. For √• printe tabellen i console er det bare √• skrive inn objektnavnet og kj√∏re koden.\nN√•r vi lager krysstabeller s√• utgj√∏r den f√∏rste variabelen radene og den andre kolonnene. Kellstedt og Whitten anbefaler at avhengig variabel representeres ved radene og uavhengig variabel i kolonnene. Jeg kaller objektet krysstabell og fyller ut variablene i table:\n\nkrysstabell <- table(ANES2016small$vote, ANES2016small$gender)\n\nkrysstabell\n\n         \n          Female Male\n  Clinton    737  532\n  Trump      575  596\n\n\nDenne tabellen oppgir frekvensfordelingen i absolutte tall. Vi kan ogs√• finne relative tall, alts√• andeler ved hjelp av prop.table(). prop.table() krever et table-objekt og vi bruker derfor krysstabell. I tillegg spesifiserer vi margin = 2 for √• si at vi vil ha andeler per kolonne. Vi vil alts√• beregne hvor stor andel av henholdvis menn og kvinner som stempte p√• Trump eller Clinton.\n\nprop.table(krysstabell, margin = 2)\n\n         \n             Female      Male\n  Clinton 0.5617378 0.4716312\n  Trump   0.4382622 0.5283688\n\n\nDersom vi spesifiserer margin = 1 s√• f√•r vi andeler per rad. I dette tilfelle betyr det at du f√•r informasjon om hvor stor andel av de som stemte p√• henholdsvis Trump og Clinton som var kvinner og menn. Dersom du ikke tar med argumentet margin s√• f√•r du en tabell der andel er regnet ut fra alle cellene.\nKjikvadrattesten tester sammenhengen mellom to kategoriske variabler. Den sammenlikner krysstabellen vi har med en hypotetisk tabell fra et annet utvalg der det ikke er noen sammeheng mellom variablene. S√• tester den sannsynligheten for at tabellen v√•r er generert ved en tilfeldighet. Vi bruker funksjonen chisq.test():\n\nchisq.test(krysstabell)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  krysstabell\nX-squared = 19.371, df = 1, p-value = 1.076e-05\n\n\nX-squared, alts√• kjikvadratet er p√• 19.371 og p-verdien er godt under 0.05. Har vi st√∏tte for hypotesen v√•r?\nEn alternativ m√•te √• gj√∏re dette p√• er √• bruke funksjonen CrossTable() fra pakken gmodels som vi installerte og lastet inn tidligere i seminar. Da f√•r vi en tabell med betraktelig mer informasjon:\n\nCrossTable(ANES2016small$vote, ANES2016small$gender, chisq = T)\n\n\n \n   Cell Contents\n|-------------------------|\n|                       N |\n| Chi-square contribution |\n|           N / Row Total |\n|           N / Col Total |\n|         N / Table Total |\n|-------------------------|\n\n \nTotal Observations in Table:  2440 \n\n \n                   | ANES2016small$gender \nANES2016small$vote |    Female |      Male | Row Total | \n-------------------|-----------|-----------|-----------|\n           Clinton |       737 |       532 |      1269 | \n                   |     4.377 |     5.091 |           | \n                   |     0.581 |     0.419 |     0.520 | \n                   |     0.562 |     0.472 |           | \n                   |     0.302 |     0.218 |           | \n-------------------|-----------|-----------|-----------|\n             Trump |       575 |       596 |      1171 | \n                   |     4.744 |     5.518 |           | \n                   |     0.491 |     0.509 |     0.480 | \n                   |     0.438 |     0.528 |           | \n                   |     0.236 |     0.244 |           | \n-------------------|-----------|-----------|-----------|\n      Column Total |      1312 |      1128 |      2440 | \n                   |     0.538 |     0.462 |           | \n-------------------|-----------|-----------|-----------|\n\n \nStatistics for All Table Factors\n\n\nPearson's Chi-squared test \n------------------------------------------------------------\nChi^2 =  19.73002     d.f. =  1     p =  8.918944e-06 \n\nPearson's Chi-squared test with Yates' continuity correction \n------------------------------------------------------------\nChi^2 =  19.37066     d.f. =  1     p =  1.076483e-05 \n\n \n\n\nVi kan lage s√∏ylediagrammer for √• presentere sammenhengen grafisk. Igjen, det er alltid lurt, ogs√• for deg selv. Det er mer intuitivt √• tolke, og lettere √• se sammenhenger raskt. Vi kan for eksempel se p√• antall enheter i de forskjellige kombinasjonene av verdier p√• variablene vi er interessert i:\n\n# Absolutte tall:\nggplot(ANES2016small, aes(x = vote,\n                          fill = gender)) + \n  geom_bar(position = \"dodge\") +\n  labs(x = element_blank(),\n       y = \"Antall\") +\n  theme(legend.title = element_blank()) +\n  theme_bw()\n\n\n\n\nAlternativt kan vi se p√• andeler, heller en antall:\n\n# Andeler:\nggplot(ANES2016small, aes(x = vote,\n                          group = gender)) + \n  geom_bar(aes(y = after_stat(prop)),\n           position = \"dodge\") +\n  labs(x = element_blank(),\n       y = element_blank(),\n       title = \"Stemmegivning og kj√∏nn\") +\n  theme(legend.title = element_blank()) +\n  scale_y_continuous(labels = scales::percent) +\n  theme_bw() + \n  facet_wrap(~ gender)"
  },
  {
    "objectID": "seminar/seminar4.html#sammenligne-gjennomsnitt-med-t-test",
    "href": "seminar/seminar4.html#sammenligne-gjennomsnitt-med-t-test",
    "title": "Seminar 4 ‚Äì Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Sammenligne gjennomsnitt med t-test",
    "text": "Sammenligne gjennomsnitt med t-test\nN√•r den avhengige variabelen v√•r er kontinuerlig og den uavhengige er katerogisk s√• kan vi bruke en t-test til √• sjekke om gruppegjennomsnittene er singifikant forskjellige. F√∏r vi gj√∏r det kan vi unders√∏ke sammenhengen i et boxplot. N√• skal vi bruke ESS-datasettet vi lastet inn f√∏rst i seminaret igjen. I ESS-datasettet er kjonn registrert som en numerisk variabel. For √• fortelle R at dette er en kategorisk variabel s√• kan vi skrive as.factor(kjonn). Pr√∏v gjerne √• lage plottet uten as.factor() for √• se hva som skjer. Vi lager et boksplot:\n\nggplot(ess, aes(x = utdanning, fill = as.factor(kjonn))) +\n  geom_boxplot()\n\nFor √• gjennomf√∏re en tohalet t-test bruker vi funksjonen t.test():\n\nt.test(utdanning ~ as.factor(kjonn), data = ess, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.006425\nalternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0\n95 percent confidence interval:\n 0.1288003 0.7877442\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754 \n\n\nt.test() gir oss da endel informasjon. F√∏rst ser vi hvilke variabler vi har kj√∏rt testen p√• (utdanning og kj√∏nn). S√• vises en t-verdi (t ~ 2.73), frihetsgrader (df = 2658) og en p-verdi (p-value = 0.006425). Deretter listes den alternative hypotesen opp; denne er alltid at snittforskjellen mellom grupper ikke er 0. Videre f√•r vi ut nedre og √∏vre konfidensintervall (0.13, 0.79); dette er omr√•det der den faktiske forskjellen i snitt vil ligge 95% av tiden. Til slutt f√•r vi opp snittforskjellene p√• utdanningmellom gruppe 1 (menn) og gruppe 2 (kvinner). Legg merke til at differansen mellom disse snittene alltid faller midt mellom konfidensintervallet over:\n\n# Differanse mellom snittene\nround(11.74582 - 11.28754, digits = 2)\n\n[1] 0.46\n\n# Midtpunktet mellom nedre og √∏vre konfidensintervall \nround(sum(0.1288003, 0.7877442) / 2, digits = 2)\n\n[1] 0.46\n\n\nHva sier t-testen om forholdet mellom kj√∏nn og utdanning?\nT-tester kan ogs√• spesifiseres p√• flere m√•ter. Under f√∏lger kode for litt forskjellige spesifikasjoner:\n\n# Enhalet test\n# Tester om menn (verdi 1) har signifikant mindre utdanning enn kvinner:\nt.test(utdanning ~ as.factor(kjonn), \n       data = ess, \n       alternative = \"less\",\n       var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.9968\nalternative hypothesis: true difference in means between group 1 and group 2 is less than 0\n95 percent confidence interval:\n      -Inf 0.7347443\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754 \n\n# Enhalet test\n# Tester om menn (verdi 1) har signifikant mer utdanning enn kvinner:\nt.test(utdanning ~ as.factor(kjonn), \n       data = ess, \n       alternative = \"greater\",\n       var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.003213\nalternative hypothesis: true difference in means between group 1 and group 2 is greater than 0\n95 percent confidence interval:\n 0.1818002       Inf\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754 \n\n# Tohalet test\n# Tester om menn (verdi 1) har signifikant forskjellig utdanning fra kvinner:\nt.test(utdanning ~ as.factor(kjonn), \n       data = ess, \n       alternative = \"two.sided\",\n       var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.006425\nalternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0\n95 percent confidence interval:\n 0.1288003 0.7877442\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754"
  },
  {
    "objectID": "seminar/seminar4.html#korrelasjonskoeffisient",
    "href": "seminar/seminar4.html#korrelasjonskoeffisient",
    "title": "Seminar 4 ‚Äì Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Korrelasjonskoeffisient",
    "text": "Korrelasjonskoeffisient\nVi avslutter med bivariat analyse med to kontinuerlige variabler. Dette er en forsmak p√• bivariat regresjonsanalyse som vi skal se mer p√• neste gang. Hensikten med dette er √• beskrive korrelasjonen eller samvariasjonen mellom variablene. Vi kan beskrive denne sammenhengen med Pearsons r og teste om korrelasjonen er statistisk signifikant.\nI dette eksempelet skal vi gj√∏re det samme som Kellstedt og Whitten gj√∏r. Vi skal teste hypotesen om det er en positiv sammenheng mellom √∏konomisk vekst og stemmeandel til den sittende presidentens parti i amerikanske presidentvalg.\nTil dette skal vi igjen laste inn samme datasett som Kellstedt og Whitten bruker. Dette er ogs√• det datasettet vi skal bruke neste gang n√•r vi skal se p√• regresjon. Ogs√• dette datasettet er i .Rdata-format s√• vi bruker load() for √• laste det inn:\n\nload(\"../data/FairFPSR3.RData\")\n\nKellstedt og Whitten skriver om kovarians og korrelasjon. Kovarians kan vi finne ved √• bruke funksjonen cov(). I cov() m√• vi spesifisere variablene vi √∏nsker √• se p√• kovariansen til. I tillegg spesifiserer vi argumentet use = \"complete.obs\" for √• fortelle R at vi bare vil se p√• de observasjonene der vi har data for begge variablene:\n\ncov(x = FairFPSR3$growth,\n    y = FairFPSR3$inc_vote, \n    use = \"pairwise.complete.obs\")\n\n[1] 17.32894\n\n\nHva forteller denne kovariansen oss?\nVi kan ogs√• hente ut en kovariansmatrise for alle variablene i datasettet:\n\ncov(FairFPSR3,\n    use = \"pairwise.complete.obs\")\n\n           inc_vote        year inflation   goodnews    growth\ninc_vote  33.472524    8.547825 -1.676461   7.047141 17.328936\nyear       8.547825 1776.000000 15.308000 -31.882353 50.448687\ninflation -1.676461   15.308000  4.118468   1.214432 -1.720625\ngoodnews   7.047141  -31.882353  1.214432   8.114286  3.351746\ngrowth    17.328936   50.448687 -1.720625   3.351746 27.734552\n\n\nSom Kellstedt og Whitten skriver s√• kan kovarians fortelle oss noe om sammenhengens retning, men den forteller oss ingenting om hvor sikre vi kan v√¶re p√• at denne samvariasjonen skiller seg fra det vi ville f√•tt om det ikke fantes en sammenheng i populasjonen vi √∏nsker √• unders√∏ke. Til det bruker vi Pearson‚Äôs r.\nPearsons r beskriver styrken og retningen til korrelasjonen mellom to variabler. Den varierer fra -1 (negativ sammenheng) til 1 (positiv sammenheng). 0 indikerer ingen sammenheng. Pearson‚Äôs r finner vi ved hjelp av funksjonen cor(). Vi spesifiserer det samme som vi gjorde i cov; avhengig variabel (y =), uavhengig variabel (x =) og hva vi skal gj√∏re med missingverdier (use = \"pairwise.complete.obs):2\n\n# Korrelasjon mellom vekst og stemmeandel\ncor(x = FairFPSR3$growth,\n    y = FairFPSR3$inc_vote, \n    use = \"pairwise.complete.obs\")\n\n[1] 0.5687443\n\n\nHvordan kan vi tolke korrelasjonen?\n\n# tester om korrelasojnen er statistisk signifikant\ncor.test(FairFPSR3$inc_vote, \n         FairFPSR3$growth, \n         use = \"pairwise.complete.obs\")\n\n\n    Pearson's product-moment correlation\n\ndata:  FairFPSR3$inc_vote and FairFPSR3$growth\nt = 4.0319, df = 34, p-value = 0.0002955\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.2954061 0.7560163\nsample estimates:\n      cor \n0.5687443 \n\n\nHva er sannsynligheten for at denne sammenhengen skyldes tilfeldigheter med denne p-verdien?\nVi kan ogs√• sette opp en korrelasjonsmatrise for √• utforske alle de bivariate korrelasjonene i datasettet mellom de akutelle variablene.\n\ncor(FairFPSR3, use = \"pairwise.complete.obs\")\n\n             inc_vote        year  inflation   goodnews     growth\ninc_vote   1.00000000  0.03505822 -0.1414538  0.4236204  0.5687443\nyear       0.03505822  1.00000000  0.1840331 -0.2730679  0.2273096\ninflation -0.14145382  0.18403311  1.0000000  0.2100778 -0.1602891\ngoodnews   0.42362043 -0.27306785  0.2100778  1.0000000  0.2224497\ngrowth     0.56874434  0.22730961 -0.1602891  0.2224497  1.0000000\n\n\nTil slutt skal vi se p√• hvordan et spredningsdiagram kan brukes til √• unders√∏ke sammenhengen mellom to kontinuerlige variabler. Til det bruker vi ggplot. Husk at i ggplot s√• spesifiserer vi datasett vi √∏nsker √• hente informasjon fra med data = og hvilke variabler vi √∏nsker √• plotte i aes(x = variabelx, y = variabely). Etter dette forteller vi ggplot hvilket plot vi √∏nsker. For √• f√• et spredningsplot bruker vi geom_point():\n\nggplot(data = FairFPSR3, \n       aes(x = growth, y = inc_vote)) +\n  geom_point()\n\n\n\n\nVi kan ogs√• tilpasse plottet ved √• endre form p√• punktene (geom_point(shape = 1)), endre bakgrunn (theme_bw()) og legge til titler p√• aksene:\n\nggplot(FairFPSR3, aes(x = growth, y = inc_vote)) +\n  geom_point(shape = 1) +\n  theme_bw() +\n  labs(x = \"Percentage Change in Real DGP Per Capita\",\n       y = \"Incumbent Party Vote Percentage\")\n\n\n\n\nUnder overskriften Point p√• denne siden finner dere en oversikt ove rulike former dere kan velge p√• punktene.\nTil slutt s√• kan vi ogs√• legge til en prediksjonslinje ved hjelp av geom_smooth(). Ved √• spesifisere geom_smooth(method = lm) s√• forteller vi R at vi vil se prediksjonslinjen for en line√¶r sammenheng:\n\nggplot(FairFPSR3, aes(x = growth, y = inc_vote)) +\n  geom_point(shape = 1) +\n  theme_bw() +\n  labs(x = \"Percentage Change in Real DGP Per Capita\",\n       y = \"Incumbent Party Vote Percentage\") +\n  geom_smooth(method = \"lm\", formula = y ~ x, color = \"black\")\n\n\n\n\nDette er begynnelsen p√• en regresjonsanalyse, som er tema for neste seminar."
  },
  {
    "objectID": "seminar/seminar5.html",
    "href": "seminar/seminar5.html",
    "title": "Seminar 5 ‚Äì Bivariat regresjon",
    "section": "",
    "text": "I dag skal vi se p√• fem ting:\nDatasettet vi skal bruke er det samme som det som omtales i kapittel ni i The Fundamentals of Political Science Research. I likhet med kapittel ni s√• skal vi kj√∏re en regresjon der vi ser p√• effekten av √∏konomisk vekst (growth) p√• andel stemmer partiet til den sittende kandidaten f√•r (inc_vote). Det f√∏rste vi skal gj√∏re er √• laste inn pakker og laste inn datasettet:\nVi bruker load() for √• laste inn data fordi datasettet er i .Rdata-format."
  },
  {
    "objectID": "seminar/seminar5.html#unders√∏ker-data",
    "href": "seminar/seminar5.html#unders√∏ker-data",
    "title": "Seminar 5 ‚Äì Bivariat regresjon",
    "section": "Unders√∏ker data",
    "text": "Unders√∏ker data\nN√•r vi skal kj√∏re en regresjonsanalyse s√• er noe av det f√∏rste vi gj√∏r √• unders√∏ke datasettet:\n\n# Hent ut informasjon om variabelnavn, klasse m.m.\nstr(FairFPSR3)\n\ntibble [36 √ó 5] (S3: tbl_df/tbl/data.frame)\n $ inc_vote : num [1:36] 48.5 50.2 49.8 50.4 48.3 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ year     : num [1:36] 1876 1880 1884 1888 1892 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ inflation: num [1:36] NA 1.974 1.055 0.604 2.274 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ goodnews : num [1:36] NA 9 2 3 7 6 7 5 8 8 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ growth   : num [1:36] 5.11 3.88 1.59 -5.55 2.76 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n\n# Et alternativ til str()\nglimpse(FairFPSR3)\n\nRows: 36\nColumns: 5\n$ inc_vote  <dbl> 48.516, 50.220, 49.846, 50.414, 48.268, 47.760, 53.171, 60.0‚Ä¶\n$ year      <dbl> 1876, 1880, 1884, 1888, 1892, 1896, 1900, 1904, 1908, 1912, ‚Ä¶\n$ inflation <dbl> NA, 1.974, 1.055, 0.604, 2.274, 3.410, 2.548, 1.442, 1.879, ‚Ä¶\n$ goodnews  <dbl> NA, 9, 2, 3, 7, 6, 7, 5, 8, 8, 3, 0, 10, 7, 4, 9, 8, 0, 0, 7‚Ä¶\n$ growth    <dbl> 5.110, 3.879, 1.589, -5.553, 2.763, -10.024, -1.425, -2.421,‚Ä¶\n\n# Printer variabelnavnene\nnames(FairFPSR3)\n\n[1] \"inc_vote\"  \"year\"      \"inflation\" \"goodnews\"  \"growth\"   \n\n# Henter ut oppsummerende statistikk:\nsummary(FairFPSR3)\n\n    inc_vote          year        inflation        goodnews     \n Min.   :36.15   Min.   :1876   Min.   :0.000   Min.   : 0.000  \n 1st Qu.:48.84   1st Qu.:1911   1st Qu.:1.431   1st Qu.: 3.000  \n Median :51.46   Median :1946   Median :2.141   Median : 5.000  \n Mean   :51.93   Mean   :1946   Mean   :2.567   Mean   : 5.057  \n 3rd Qu.:54.80   3rd Qu.:1981   3rd Qu.:3.139   3rd Qu.: 7.000  \n Max.   :62.23   Max.   :2016   Max.   :7.795   Max.   :10.000  \n                                NA's   :1       NA's   :1       \n     growth        \n Min.   :-14.3500  \n 1st Qu.: -1.5155  \n Median :  2.1575  \n Mean   :  0.7635  \n 3rd Qu.:  3.9653  \n Max.   : 11.6820  \n                   \n\n\nDet er ogs√• lurt √• sjekke om mange observasjoner har manglende informasjon (missing) p√• variablene du er interessert i:\n\n# Sjekker hvor mange observasjoner som vi har informasjon p√• alle variablene om:\ntable(complete.cases(FairFPSR3))\n\n\nFALSE  TRUE \n    1    35 \n\n\nVi ser at 35 av observasjonene v√•re ikke har noen missingverdier. Vi kan ogs√• sjekke for enkeltvariabler:\n\n# Sjekker hvor mange observasjoner som har missing p√• variabelen inflation\ntable(is.na(FairFPSR3$inflation))\n\n\nFALSE  TRUE \n   35     1 \n\n\nVi ser at en observasjon har missing p√• variabelen inflation.\nLegg merke til at funksjonene complete.cases() og is.na() er logiske tester. Disse evaluerer hver observasjon og sjekker om vi har informasjon om alle variabler (complete.cases()) og om vi mangler informasjon p√• variabelen inflation. For √• illustrere dette s√• kan vi pr√∏ve √• legge til to nye variabler i datasettet basert p√• disse logiske testene:\n\nFairFPSR3 <- FairFPSR3 %>% \n  mutate(complete = complete.cases(.),\n         inf_na = is.na(inflation))\n\nBruk View() eller klikk p√• datasettet ditt for √• se hvordan de nye variablene ser ut. Hva betyr TRUE og FALSE i de to kolonnene?\nMer informasjon om missingverdier finner dere i dokumentet som beskriver seminar 4."
  },
  {
    "objectID": "seminar/seminar5.html#omkoding-av-variabler",
    "href": "seminar/seminar5.html#omkoding-av-variabler",
    "title": "Seminar 5 ‚Äì Bivariat regresjon",
    "section": "Omkoding av variabler",
    "text": "Omkoding av variabler\nEtter at vi har kartlagt datastrukturen og hvilke variabler vi har s√• m√• vi vurdere om noen av variablene m√• omkodes f√∏r vi kan gj√∏re analysen v√•r. For √• f√• samme resultater som i kapittel ni trenger vi ikke √• omkode noe, men for √• f√• noe √• sammenligne med skal vi lage en dikotom variabel.\nI tidyverse bruker man som regel mutate()sammen med andre funksjoner for √• opprette nye variabler. Koden over hvor vi opprettet variabler for de logiske testene complete.cases() og is.na() er eksempler p√• dette. N√• skal vi ogs√• kombinere mutate() med if.else for √• lage en dikotom variabel som tar verdien Growth om observasjonen er et √•r med positiv √∏konomisk vekst og No growth om observasjonen er et √•r uten √∏konomisk vekst:\n\n# Oppretter den nye variabelen og endrer referansekategori\nFairFPSR3 <- FairFPSR3 %>% \n  mutate(growth_dich = ifelse(growth > 0, \"Growth\", \"No growth\"),\n         growth_dich = factor(growth_dich, levels = c(\"No growth\", \"Growth\")))\n\n\nHvordan ifelse() fungerer er n√¶rmere beskrivet i seminar 3. Det neste vi gj√∏r er √• sjekke om omkodingen ble riktig:\n\n# Sjekker at det ser ok ut: \nclass(FairFPSR3$growth_dich)\n\n[1] \"factor\"\n\ntable(FairFPSR3$growth_dich, useNA = \"always\")\n\n\nNo growth    Growth      <NA> \n       11        25         0 \n\n\nN√•r du lager en faktor-variabel s√• tar R utgangspunkt i alfabetet n√•r referansekategorien bestemmes. I dette tilfellet ville referansekateogrien blitt ‚ÄúGrowth‚Äù, men vi bruker factor() til √• endre referansekategorien til ‚ÄúNo growth‚Äù.\nN√•r en omkoder numeriske variabler s√• kan det v√¶re nyttig √• lage et plott for √• sjekke at det ble riktig. Her bruker vi fill argumentet til √• gi ulik farge til observasjonene basert p√• om det var vekst eller ikke:\n\nggplot(data = FairFPSR3) +\n  geom_histogram(aes(x = growth, fill = growth_dich),\n               binwidth = 1)\n\n\n\n\nUt fra plottet kan vi se at alle observasjonene med verdien No growth hadde negativ vekstrate, mens alle observasjoner med verdien Growth hadde positiv vekstrate. Hva ville dere gjort med plottet f√∏r det evt kan brukes i en oppgave?"
  },
  {
    "objectID": "seminar/seminar5.html#litt-plotting-f√∏r-regresjon",
    "href": "seminar/seminar5.html#litt-plotting-f√∏r-regresjon",
    "title": "Seminar 5 ‚Äì Bivariat regresjon",
    "section": "Litt plotting f√∏r regresjon",
    "text": "Litt plotting f√∏r regresjon\nF√∏r du kj√∏rer en regresjon s√• kan det v√¶re lurt √• plotte den avhengige og den uavhengige variabelen din. I v√•rt tilfelle er dette variabelene inc_vote og growth. For √• f√• til dette bruker vi ggplot.\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\")"
  },
  {
    "objectID": "seminar/seminar5.html#regresjon-med-numerisk-uavhengig-variabel",
    "href": "seminar/seminar5.html#regresjon-med-numerisk-uavhengig-variabel",
    "title": "Seminar 5 ‚Äì Bivariat regresjon",
    "section": "Regresjon med numerisk uavhengig variabel",
    "text": "Regresjon med numerisk uavhengig variabel\nFor √• kj√∏re en line√¶r regresjon i R s√• bruker vi funksjonen lm(). lm() har f√∏lgende syntaks:\n\nlm(avhengig_variabel ~ uavhengig_variabel, data = mitt_datasett)\n# P√• mac f√•r du ~ med alt + k + space\n\nDersom datasettet ditt har manglende informasjon (missing/NA) s√• m√• du legge til et element som sier hvordan regresjonen skal forholde seg til dette. Ved √• legge til na.action = \"na.exclude\" i lm() s√• beholder R informasjon om hvilke observasjoner som mangler data slik at vi kan bruke fitted() som vi skal snakke mer om senere.\nI eksempelet fra kapittel ni i Kellsted og Whitten er vi interessert i effekten av den uavengige variabelen growth p√• den avhengige variabelen inc_vote. Under kj√∏rer vi modellen og lagrer den som model i Environment:\n\nmodel <- lm(inc_vote ~ growth, \n            data = FairFPSR3,\n            na.action = \"na.exclude\")\n\nDet finnes flere m√•ter √• unders√∏ke resultatene p√•. Vi skal se p√• hvordan vi kan gj√∏re dette ved hjelp av summary(), stargazer() og ggplot(). Vi skal f√∏rst se p√• summary().\n\nsummary(model)\n\n\nCall:\nlm(formula = inc_vote ~ growth, data = FairFPSR3, na.action = \"na.exclude\")\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-8.1384 -3.7445 -0.6354  2.8291 10.0700 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  51.4486     0.8133  63.256  < 2e-16 ***\ngrowth        0.6248     0.1550   4.032 0.000295 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.828 on 34 degrees of freedom\nMultiple R-squared:  0.3235,    Adjusted R-squared:  0.3036 \nF-statistic: 16.26 on 1 and 34 DF,  p-value: 0.0002955\n\n\nVed √• bruke summary f√•r vi informasjon om koeffisienten (Estimate), standardfeilen (Std. Error), t-verdien (t-value) og p-verdien (Pr(>|t|)). Av summary kan vi derfor lese at koeffisienten til growth er 0.6248 og p-verdien er 0.000295. P-verdien er lavere enn 0.01 og vi kan derfor si at koeffisienten er signifikant p√• 1 prosents niv√•.\nstargazer() er en nyttig funksjon som gir oss mye av den samme informasjonen som summary(), men i et litt mer lettlest format.\n\nstargazer(model, \n          type = \"text\")\n\n\n===============================================\n                        Dependent variable:    \n                    ---------------------------\n                             inc_vote          \n-----------------------------------------------\ngrowth                       0.625***          \n                              (0.155)          \n                                               \nConstant                     51.449***         \n                              (0.813)          \n                                               \n-----------------------------------------------\nObservations                    36             \nR2                             0.323           \nAdjusted R2                    0.304           \nResidual Std. Error       4.828 (df = 34)      \nF Statistic           16.256*** (df = 1; 34)   \n===============================================\nNote:               *p<0.1; **p<0.05; ***p<0.01\n\n\nVed hjelp av stargazer s√• kan vi ogs√• lagre tabeller lokalt p√• PC-en som vi kan bruke i word-dokumenter og liknende. Da endrer vi p√• type argumentet og legger til et out argument. out argumentet forteller i hvilken mappe du vil lagre filen samt hva filen skal hete. Da f√•r du en .htm-fil som ser omtrent ut som i eksempelet under. Den kan du h√∏yreklikke p√• og velge √•pne i word dersom du skal ha tabellen inn i en oppgave eller liknende:\n\nstargazer(model,  \n          type = \"html\",\n          out = \"model1_tab.htm\")\n\nInformasjonen vi f√•r ved hjelp av summary() og stargazer() er veldig nyttig.Vi f√•r vite koeffisientene, standardfeilene og informasjon vi kan bruke til √• evaluere modellen v√•r. I seminar skal vi bruke en del tid p√• √• tolke disse tabellene.\nEt alternativ til tabeller er √• plotte resultatene fra regresjonen. N√• skal vi lage figur 9.4 i kapittel ni ved hjelp av ggplot().\nF√∏rst lager vi et plott med de observerte verdiene (dette er det samme plottet som vi lagde tidligere):\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\")\n\n\n\n\nDet neste vi skal gj√∏re er √• legge til regresjonslinjen i plottet. Dette kan gj√∏res p√• to m√•ter.\n\nLegge til regresjonslinje med geom_smooth\nDen f√∏rste m√•ten er √• bruke geom_smooth(method = \"lm\") for √• plotte en regresjonslinje:\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\") +\n  geom_smooth(aes(x = growth, y = inc_vote),\n              method = \"lm\", color = \"goldenrod3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nI kapittel ni viser Kellstedt og Whitten at regresjonslinjen krysser utvalgets gjennomsnittsverdier p√• uavhengig og avhengig variabel. Det kan vi ogs√• vise ved √• legge til to linjer i koden v√•r:\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\") +\n  geom_smooth(aes(x = growth, y = inc_vote),\n              method = \"lm\", color = \"goldenrod3\") +\n  geom_hline(yintercept = mean(FairFPSR3$inc_vote), linetype = \"dashed\") +\n  geom_vline(xintercept = mean(FairFPSR3$growth), linetype = \"dashed\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nLegge til regresjonslinje med fitted() og geom_line()\nDen andre metoden er √• be R l√∏se regresjonslikningen for alle observasjonene v√•re og s√• legge til et nytt lag med predikerte verdier i plottet. Denne metoden g√•r vi ikke gjennom i detalj p√• seminar s√• det holder i massevis √• kunne den f√∏rste.\nR kan regne ut de predikerte verdiene for oss ved hjelp av funksjonen fitted() s√• vi slipper heldigvis √• gj√∏re det for h√•nd.\nHer bruker vi funksjonene fitted() og resid() til √• legge til predikerte verdier og residualer for de ulike variablene i datasettet v√•rt:\n\nFairFPSR3 <- FairFPSR3 %>% \n  mutate(fitted = fitted(model), \n         residuals = resid(model))\n\nN√• kan vi bruke denne informasjonen til √• legge til en regresjonslinje i plottet v√•rt. Prikkene angir de ulike observerte verdikominasjonene, mens den rette linjen gir oss den line√¶re sammenhengen fra modellen v√•r.\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  geom_line(aes(x = growth, y = fitted)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\")\n\n\n\n\nOgs√• her kan vi vise at regresjonslinjen krysser utvalgets gjennomsnittsverdier p√• uavhengig og avhengig variabel. Vi legger til de to linjene geom_hline() og geom_vline():\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\") +\n  geom_line(aes(x = growth, y = fitted)) +\n  geom_hline(yintercept = mean(FairFPSR3$inc_vote), linetype = \"dashed\") +\n  geom_vline(xintercept = mean(FairFPSR3$growth), linetype = \"dashed\")"
  },
  {
    "objectID": "seminar/seminar5.html#konfidensintervall",
    "href": "seminar/seminar5.html#konfidensintervall",
    "title": "Seminar 5 ‚Äì Bivariat regresjon",
    "section": "Konfidensintervall",
    "text": "Konfidensintervall\nI kapittel ni i Kellstedt og Whitten er det flere eksempler p√• hvordan vi kan sjekke om en modell er god eller ikke. Noe av det gikk vi gjennom n√•r vi s√• p√• resultatene av modellen. En ting som ikke kommer med n√•r vi bruker stargazer() og summary() er konfidensintervallene til en koeffisient. De kan vi enkelt hente ut ved hjelp av funksjonen confint():\n\nconfint(model)\n\n                 2.5 %     97.5 %\n(Intercept) 49.7957308 53.1015677\ngrowth       0.3098843  0.9397437"
  },
  {
    "objectID": "seminar/seminar5.html#regresjon-med-dikotom-uavhengig-variabel",
    "href": "seminar/seminar5.html#regresjon-med-dikotom-uavhengig-variabel",
    "title": "Seminar 5 ‚Äì Bivariat regresjon",
    "section": "Regresjon med dikotom uavhengig variabel",
    "text": "Regresjon med dikotom uavhengig variabel\nFor √• √∏ve oss p√• tolkning skal vi n√• kj√∏re en modell med inc_vote som avhengig variabel og den dikotome vekst-variabelen vi lagde tidligere som uavhengig variabel. At en variabel er dikotom betyr at den bare har to verdier. F√∏rst kj√∏rer vi modellen f√∏r vi unders√∏ker resultatene i stargazer:\n\n# Lagrer modellen\nmodel_dich <- lm(inc_vote ~ growth_dich, \n                 data = FairFPSR3,\n                 na.action = \"na.exclude\")\n\n# Unders√∏ker resultatene\nstargazer(model_dich, \n          type = \"text\")\n\n\n===============================================\n                        Dependent variable:    \n                    ---------------------------\n                             inc_vote          \n-----------------------------------------------\ngrowth_dichGrowth              2.859           \n                              (2.066)          \n                                               \nConstant                     49.940***         \n                              (1.722)          \n                                               \n-----------------------------------------------\nObservations                    36             \nR2                             0.053           \nAdjusted R2                    0.025           \nResidual Std. Error       5.711 (df = 34)      \nF Statistic             1.914 (df = 1; 34)     \n===============================================\nNote:               *p<0.1; **p<0.05; ***p<0.01"
  },
  {
    "objectID": "proveinfo.html",
    "href": "proveinfo.html",
    "title": "STV1020",
    "section": "",
    "text": "Nei.\n\n\n\nNei.\n\n\n\n[TBD! Vi jobber med l√∏sning p√• dette.]\n\n\n\n\n\n\n\n\n\n\n[TBD! Vi har ikke bestemt dette enda.]\n\n\n\nDu skal levere et R-script med koden din og kommentarer. Du skal ikke laste opp figurer og tabeller. Seminarleder kj√∏rer scriptet ditt og vil p√• den m√•ten se om koden for en figur eller tabell er riktig.\n\n\n\nJa, du st√•r fritt til √• bruke alle hjelpemidler. Det inkluderer seminarmateriellet som er tilgjengelig p√• github, notater du har tatt i seminar og google. Det kan v√¶re lurt √• gj√∏re seg kjent med beskrivelsene av de ulike seminarene i forkant av pr√∏ven s√• du vet hvor du skal sl√• opp.\n\n\n\nJa, dere har lov til √• samarbeide og diskutere oppgavene med medstudenter, men alle m√• levere sitt eget script med egne kommentarer.\n\n\n\nNei. P√• pr√∏ven er det spesifisert hvor mange poeng du m√• f√• for √• best√•.\n\n\n\nHvis du er syk s√• m√• du s√∏ke om utsatt obligatorisk aktivitet.\nDersom du f√•r godkjent utsatt obligatorisk aktivitet s√• vil du f√• en ny pr√∏vedato.\n\n\n\nHusk √• laste inn de n√∏dvendige pakkene ved hjelp av library(). Gj√∏r det f√∏rst i scriptet s√• er du ferdig med det. Om du ikke vet hvilken funksjon du skal bruke for √• l√∏se en oppgave s√• sl√• opp i materiale eller s√∏k p√• nett.\nOm en kodesnutt ikke vil kj√∏re s√•:\n\nlast inn n√∏dvendige pakker igjen.\nkj√∏r all koden f√∏r kodesnutten p√• ny.\npr√∏v √• forst√• feilmeldingen. F√•r du f.eks. en feilmelding som sier ‚Äúcould not find function‚Äù s√• kan dette tyde p√• at du kanskje har skrevet funksjonsnavnet feil eller at du m√• laste inn pakken funksjonen ligger i med library() f√∏rst. F√•r du en feilmelding om at ‚Äúobject x not found‚Äù s√• kan dette tyde p√• at du har en skrivefeil i navnet p√• f.eks. et datasett eller et modellnavn.\nom dette ikke virker s√• g√• videre og kom tilbake til oppgaven senere dersom du har tid. Da kan du s√∏ke p√• nett e.l. etter en l√∏sning."
  }
]
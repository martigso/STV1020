[
  {
    "objectID": "workbench.html",
    "href": "workbench.html",
    "title": "STV1020",
    "section": "",
    "text": "Åpne nettleseren din og gå til https://rstudio-workbench.uio.no/\nVelg Universitetet i Oslo/University of Oslo under tilknytning/affiliation.\n\n\n\nLogg inn med brukernavn og passord fra UiO.\n\n\n\nTrykk på “+ New Session”.\n\n\n\nVelg STV1020-varianten under “Image” og trykk “Start session”. Du kan også velge å gi sesjonen et eget navn under “Session Name”.\n\n\n\nDen nye sesjonen skal nå dukke opp under “Session”. Trykk på “RStudio Session”. Dersom du har gitt sesjonen et eget navn så må du trykke på den sesjonen med navnet du brukte.\n\n\n\nNå skal du få opp Rstudio i nettleseren din."
  },
  {
    "objectID": "rogrstudio.html",
    "href": "rogrstudio.html",
    "title": "STV1020",
    "section": "",
    "text": "R er et gratisprogram som er spesielt egnet for statistikk og dataanalyse. RStudio er en IDE (integrated development environment), et gratisprogram som gjør det lettere å bruke R. Derfor skal vi lære R med RStudio i seminarene.\nFørste gang du åpner RStudio er alt fremmed, du blir du møtt av en rekke vinduer, menyer og knapper. Dette dokumentet gir deg en kort forklaring av det aller mest grunnleggende i R og RStudio gjennom 10 bilder. Dersom du tar deg 5 minutter til å lese dokumentet, og forsøke koden, kommer det første seminaret til å gå som en lek. Dersom første seminar ikke gikk som en lek, og du er usikker på hva som foregår i RStudio, kan det også være nyttig å lese dette dokumentet.\n\n\nDu kan installere R og RStudio ved å følge denne guiden\n\n\n\nNå er du klar til å åpne RStudio (du trenger ikke åpne R!). Når du åpner RStudio, vil denne skjermen dukke opp:\n\nPå bildet ser du tre paneler. Til venstre er Console, øverst til høyre er Environment, og nederst til høyre er Files. Fra hvert av disse panelene er det mulig å trykke seg til andre paneler som Terminal, Plots, History og Help. I denne gjennomgangen forklarer jeg imidlertid bare de fire panelene du trenger for å skrive, kjøre, og lagre kode. Disse panelene er:\n\nScript Her skrives koden din\nConsole - Her produseres output fra koden din\nEnvironment - Her er en oversikt over data du kan kjøre kode på.\nFiles - Her vises filer i mappen du jobber fra, som for eksempel data og kode. Dersom du lagrer scriptet ditt i mappen du jobber fra, dukker det opp her.\n\n\n\n\nLa oss starte med Script. Første gang du åpner RStudio må du åpne dette panelet selv. Det gjør du ved å trykke på arket med grønn sirkel og hvitt plusstegn øverst i høyre hjørne. Jeg har merket dette arket på bildet under. Trykk deretter på “R Script”. Alternativt kan du bruke hurtigtasten ctrl/cmd + shift + N.\n\nNår du har åpnet et nytt R-script vil denne skjermen med fire paneler dukker opp:\n\nI R-scriptet, det øverste panelet til venstre, kan du nå skrive R-koder. La oss prøve å skrive to gyldige R-koder, \"Hello world!\" og 1+1. R-scriptet ditt skal se slik ut:\n\nDu har nå skrevet to linjer med R-kode!\n\n\n\nI forrige bilde merket jeg den nederste linjen i Console, som begynner med >. Den er tom, men når vi kjører koden vi har skrevet, vil RStudio evaluere/kjøre koden i Console. Dersom koden produserer output, vil denne også printes i Console. Vi kjører koden ved å merke koden i scriptet, og trykke på ctrl/cmd + enter (ctrl på pc, cmd på mac). La oss se på resultatet av å kjøre koden vi har skrevet i scriptet:\n\nPå linjen med > vises kode som R har kjørt. På linjen under kode som er kjørt, vises output fra koden. Koden \"Hello world!\"ble lest og evaluert som tekst - resultatet er tekst-outputen “Hello world!”. Koden 1+1 ble lest som et mattestykke, og RStudio produserte outputen 2, løsningen på mattestykket vi ba RStudio om å kjøre/evaluere for oss. RStudio kan tydeligvis både lese og regne.\n\n\n\nDet er ikke all kode som gir output i Console. Noen ganger skriver vi kode som gir input til RStudio i form av informasjon/data som vi ber RStudio huske på for oss. RStudio kan huske på informasjon, uten av vi trenger å lagre den på datamaskinen. Data som RStudio husker, vises i Environment. Vi kaller slike data for objekter. Jeg har merket Environment-panelet, øverst til høyre. Vi bruker som regel objekter, gjerne datasett i kodingen vi gjør.\nLa oss skrive en kode som gir RStudio informasjon å huske på. Til dette bruker vi funksjonen (mer presist: assignment operatoren) <-, som brukes til å oprette objekter. Objekter inneholder ulike samlinger av informasjon/data som RStudio husker på for oss. Vi kan selv velge navnet på objektene våre. Navnet kommer før <-, jeg velger å kalle objektet mitt velkommen. Etter pilen forteller vi hva objektet skal inneholde. Under har jeg brukt funksjonen c() for å fortelle RStudio at jeg ønsker å opprette en vektor (en ordnet liste av verdier) bestående av fire elementer, \"Velkommen\" , \"til\", \"R-seminar\" og \"!\". Når jeg bruker hermetegn, \" \", behandler R disse elementene som tekst.\n\nLa oss se hva som skjer når vi kjører koden (med ctrl + enter på pc og cmd + enter på mac).\n\nVi ser at objektet velkommen har dukket opp i Environment panelet øverst til høyre. Vi får også informasjon om hva objektet inneholder. Først kommer navnet på objektet, chr referer til at objektet består av tekst. Deretter referer [1:4] til at objektet består av fire elementer, som vises til slutt.\nLegg for øvrig merke til at når vi kjørte koden, ble den evaluert i Console, men vi fikk ikke output på en ny linje i Console. Dersom vi evaluerer objektet vi laget, velkommen, får vi imidlertid en egen linje med output, i dette tilfellet innholdet i objektet. Som oftest får vi output i Console, men noen typer kode, som opprettelse av objekter med <- gir output i andre paneler, som Environment\n\nVi har nå sett på 3 deler av arbeidsflyten i RStudio:\n\nFørst skriver vi kode i et script.\nDeretter kjører/evaluerer vi koden i Console med ctrl/cmd + enter.\nResultatet av at koden ble evaluert dukker som regel opp i Console. Når koden produserer objekter med informasjon som RStudio skal huske på, dukker imidlertid objektet opp i Environment.\n\n\n\n\nNår vi er ferdig med de 3 stegene over, vil vi som regel lagre arbeidet vårt, slik at vi ikke trenger å gjøre arbeidet på nytt senere. Dersom det går fort å kjøre gjennom R-scriptet, er scriptet alt vi trenger å lagre. Det er også mulig å lagre datasett, figurer, tabeller og bilder, men dette skal vi lære senere. For å forstå hvordan vi kan lagre ulike filer i RStudio, og hvor R leter etter filer (som datasett) som vi ber R finne, må vi kjenne til mappesystemet på datamaskinen vi jobber fra.\nEt eksempel på en mappe som finnes på de fleste pcer er Mine dokumenter eller Documents. RStudio velger en mappe av denne typen på datamaskinen som working directory. RStudio forventer at filnavn som refereres til ligger i working directory. RStudio vil også sette som default option at filer lagres i working directory.\nPanelet Files nederst til høyre viser filer i ditt nåværende working directory. På bildet under, ser du at mappen jeg har som working directory, data, er tom.\n\nHva skjer dersom jeg lagrer R-scriptet i denne mappen? La oss lagre og sjekke. Trykk på file øverst til venstre i RStudio, trykk deretter på save as. Du kan eventuelt bruke hurtigtastene ctrl/cmd + s. Da vil dette vinduet dukke opp:\n\nJeg velger filnavnet test. Vi trenger ikke å skrive hvilken filtype vi lagrer, RStudio gjør dette for oss. Trykk på lagre uten å skifte mappe du lagrer filen i bor fra default option. Du vil få følgende resultat:\n\nScriptet vårt, test.R dukket nå opp under Files. Dette betyr at RStudio har registrert at filen er i working directory. Filer som slutter med .R er lagret som R-script, vi har dermed lyktes med å lagre R-scriptet riktig.\n\n\n\nOfte ligger mapper inne i andre mapper, under en harddisk (for eksempel C:). Mappene vi må klikke oss gjennom for å komme fra harddisken til en bestemt mappe, f.eks. STV4020A, utgjør filstien til mappen STV4020A. Ved å spesifisere filstien til en mappe, kan du kan bytte working directory med funksjonen setwd(). Dersom vi skriver navnet på en fil som ligger i en annen mappe enn working directory, vil ikke R klare å finne denne, med mindre vi spesifiserer filstien. Vi kan lese filstien til nåværende working directory på toppen av Files-panelet. Fra bildet over, ser vi at mitt working directory er satt til C:/Users/erlenlan/OneDrive/STV4020A/data (Bruk / for å skille mellom mapper når du skriver filstier). Du kan også finne nåværende working directory ved å kjøre koden getwd(). Den beste og letteste måten å unngå frustrasjon pga. working directory er å opprette et prosjekt gjennom menyen i R-studio. Les mer her."
  },
  {
    "objectID": "oppgaver/oppgaver1.html",
    "href": "oppgaver/oppgaver1.html",
    "title": "Seminar 1 – Oppgaver",
    "section": "",
    "text": "Løsningsforslag\nDu kan trykke på knappen under for å se på løsningsforslag\n\n\nCode\n# Oppgave 1\nfolk <- data.frame(navn = c(\"Eric\", \"Eli\", \"Amalie\", \"Martin\"),\n                   alder = c(25, 17, 72, 55),\n                   favorittfilm = c(\"Finding Nemo\", \"Scream 2\", \"Gruffalo\", \"Folk og røvere i Kardemomme by\"),\n                   by = c(\"Bærum\", \"Dalen\", \"Senja\", \"Frøyland\"))\n\n# Oppgave 2\nsummary(folk$alder)\nsd(folk$alder)\n## Gj.snitt = 42.25\n## Median = 40\n## Std.av = 25.7\n\n\n# Oppgave 3\n# Brukker sykkelavstand via google maps\nfolk$avstand <- c(22.1, 219, 1710, 438)\n\n# Oppgave 4\nmax(folk$avstand) # 1710 er lengst\n\n## Alternativ 1\nfolk %>% arrange(avstand) # Amalie har lengst avstand\n\n## Alternativ 2\nfolk$navn[which.max(folk$avstand)]\n\n\n# Oppgave 5\n\nlibrary(tidyverse) # laster inn tidyverse for å få ggplot\n\nggplot(folk, aes(x = navn, y = alder)) +\n  geom_point() +\n  labs(x = \"Navn\", y = \"Alder\")"
  },
  {
    "objectID": "oppgaver/oppgaver3.html",
    "href": "oppgaver/oppgaver3.html",
    "title": "Seminar 3 – Oppgaver",
    "section": "",
    "text": "Løsningsforslag\n\n\nCode\nlibrary(tidyverse)\n\n#### Oppgave 1 ####\ndata(\"gapminder\", package = \"gapminder\")\n\n#### Oppgave 2 ####\ntable(gapminder$continent)\n\ngapminder <- gapminder %>% \n  mutate(cont_num = case_match(continent,\n                               \"Asia\" ~ 1,\n                               \"Americas\" ~ 2,\n                               \"Oceania\" ~ 3,\n                               \"Europe\" ~ 4,\n                               \"Africa\" ~ 5))\ntable(gapminder$cont_num, gapminder$continent)\n\n#### Oppgave 3 ####\ngapminder$lifeExp_k <- gapminder$lifeExp * 1000\n\ntable(gapminder$lifeExp == gapminder$lifeExp_k/1000)\n\n#### Oppgave 4 ####\ngapminder_subset <- gapminder %>% \n  select(country, year, lifeExp) %>% \n  filter(year == 1977)\n\n#### Oppgave 5 ####\neuro_highle <- gapminder %>% \n  filter(continent == \"Europe\" & lifeExp >= 75)\n\n#### Oppgave 6 ####\nggplot(gapminder, aes(x = as.factor(year))) +\n  geom_bar()\n\n# Ja,det er like mange observasjoner pr år\n\n#### Oppgave 7 ####\nggplot(gapminder, aes(x = gdpPercap)) +\n  geom_histogram()\n\n#### Oppgave 8 ####\nggplot(gapminder, aes(x = gdpPercap)) +\n  geom_density(linewidth = 2, color = \"red\")\n\n#### Oppgave 9 #### +\n#### Oppgave 10 #### +\n#### Oppgave 11 ####\n\nggplot(gapminder, aes(x = pop, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~ continent)\n\n#### Oppgave 12 ####\n#### Oppgave 13 ####\n\nggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +\n  geom_smooth()\n\n\n#### Oppgave 14 ####\n\n# Her har jeg bare lekt litt\nggplot(gapminder, aes(x = year, y = lifeExp, color = continent, fill = continent)) +\n  geom_smooth(alpha = .2) +\n  labs(x = \"År\", y = \"Forventet levealder\", color = \"\", fill = \"\",\n       title = \"Trend i forventet levealder på tvers av kontinent\") +\n  theme_classic() +\n  theme(legend.position = \"bottom\",\n        panel.grid.major.y = element_line(linetype = \"dashed\"))\nggsave(\"../bilder/oppgave3_14plot.png\")\n\n#### Ekstraoppgave ####\n\nafrica <- gapminder %>% \n  filter(continent == \"Africa\" & year == 1952) %>% \n  filter(lifeExp > mean(lifeExp)) # Siden denne kommer etter filteret over,\n                                  # vil den regne snitt bare på afrikanske land\n                                  # fra 1952. Rekkefølge er viktig."
  },
  {
    "objectID": "oppgaver/oppgaver6.html",
    "href": "oppgaver/oppgaver6.html",
    "title": "Seminar 6 – Oppgaver",
    "section": "",
    "text": "Kommer snart!"
  },
  {
    "objectID": "oppgaver/oppgaver5.html",
    "href": "oppgaver/oppgaver5.html",
    "title": "Seminar 5 – Oppgaver",
    "section": "",
    "text": "Kommer snart!"
  },
  {
    "objectID": "oppgaver/oppgaver2.html",
    "href": "oppgaver/oppgaver2.html",
    "title": "Seminar 2 – Oppgaver",
    "section": "",
    "text": "Løsningsforslag\n\n\nCode\n# Laster inn nødvendige pakker\nlibrary(tidyverse)\nlibrary(haven)\n\n# Oppgave 1\ness <- read_dta(\"../data/ESS9NO.dta\")\n\n# Oppgave 2\ness <- ess %>% \n  rename(poltil = trstplt,\n         kjonn = gndr,\n         aar_fodt = yrbrn)\n\n# Oppgave 3\ness$alder <- 2018 - ess$aar_fodt\nsummary(ess$alder)\n\n# Oppgave 4\ness_sub <- ess %>% \n  select(poltil, kjonn, aar_fodt, vote, alder)\n\nhead(ess_sub)\n\n# Oppgave 5\nclass(ess_sub$poltil)\nclass(ess_sub$kjonn)\n\n# Oppgave 6\ntable(ess_sub$poltil)\nlabels(ess_sub$poltil)\n\n# Oppgave 7\n\nggplot(ess_sub, aes(x = poltil)) +\n  geom_bar()\n\n# Oppgave 8\ness_sub$kjonn <- factor(ess_sub$kjonn)\ness_sub$vote <- factor(ess_sub$vote)\n\nggplot(ess_sub, aes(x = kjonn, fill = vote)) +\n  geom_bar(position = position_dodge())\n\n# Oppgave 9\nggplot(ess_sub, aes(x = alder, y = kjonn)) +\n  geom_boxplot()\n\n# evt.\n\nggplot(ess_sub, aes(x = alder, fill = kjonn)) +\n  geom_density(alpha = .3)"
  },
  {
    "objectID": "oppgaver/oppgaver4.html",
    "href": "oppgaver/oppgaver4.html",
    "title": "Seminar 4 – Oppgaver",
    "section": "",
    "text": "Du skal bruke datasettet wvs_us17.csv og lineær regresjon for å undersøke relasjonen mellom avhengig (AV) og uavhengig (UV) variabel. Datasettet er en survey gjennomført i USA i 2017 for World Value Survey. Individer svarer på surveyen. Tilsvarende surveyer er gjort for mange andre land og år (se World Value survey sine nettsider for mer informasjon), men i dag bruker vi et datasett som bare inneholder observasjonene fra USA i 2017.\nDatasettet inneholder følgende variabler:"
  },
  {
    "objectID": "oppgaver/oppgaver4.html#oppgaver",
    "href": "oppgaver/oppgaver4.html#oppgaver",
    "title": "Seminar 4 – Oppgaver",
    "section": "Oppgaver",
    "text": "Oppgaver\n\nLast inn datasettet wvs_us17.csv. Du kan finne det her. Oppgi antall enheter og variabler i datasettet.\nFinn navn på variablene i datasettet.\nOpprett en nytt datasett med kun variablene imp_democracy, age og income_group Sjekk at klassen til variablene er numeric.\nVis hvordan du fjerner enheter som mangler opplysninger fra datasettet. Oppgi antall enheter i datasettet etter at du har fjernet enhetene.\nLag et arealplot med age på x-aksen og lag ett panel pr verdi på imp_democracy (facet_wrap())\nKjør en bivariat korrelasjon mellom imp_democracy og age.\nTolk korrelasjonen og sjekk om den er signifikant\nLag et plott med observerte verdier av imp_democracy på y-aksen og observerte verdier av age på x-aksen.\nLag en bivariat regresjon med imp_democracy som avhengig variabel og age som uavhengig variabel.\nVis resultatene fra modellen og tolk koeffisienten for age substansielt."
  },
  {
    "objectID": "oppgaver/oppgaver4.html#løsningsforslag",
    "href": "oppgaver/oppgaver4.html#løsningsforslag",
    "title": "Seminar 4 – Oppgaver",
    "section": "Løsningsforslag",
    "text": "Løsningsforslag\n\n\nCode\n# Pakker \nlibrary(tidyverse)\n\n# Oppgave 1\nwvs <- read.csv(\"https://raw.githubusercontent.com/martigso/STV1020/gh-pages/data/wvs_us17.csv\")\n\n# Oppgave 2\nnames(wvs)\n\n# Oppgave 3\n\nwvs_sub <- wvs %>% \n  select(imp_democracy, age, income_group)\n\nglimpse(wvs_sub)\n# Alle er heltall (<int>)\n\n# Oppgave 4\nfoer <- nrow(wvs_sub)\n\nwvs_sub <- wvs_sub %>% drop_na()\n\netter <- nrow(wvs_sub)\n\nfoer - etter\n\n# 81 enheter ble fjernet\n\n\n# Oppgave 5\n\nggplot(wvs_sub, aes(x = age)) +\n  geom_density() +\n  facet_wrap(~ imp_democracy)\n\n# Det kan se ut som yngre gir lavere skåre på imp_democracy\n\n# Oppgave 6\n\ncor(wvs_sub$imp_democracy, wvs_sub$age)\n\n# Oppgave 7\n\ncor.test(wvs_sub$imp_democracy, wvs_sub$age)\n\n# Sammenhengen mellom de 2 variablene er relativt høy og positiv\n# dvs at man kan forvente at dess eldre man er, dess mer viktig\n# mener man demokrati er.\n\n# Oppgave 8\n\nggplot(wvs_sub, aes(x = age, y = imp_democracy)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(0, 10, 1))\n# Her ser vi tydelig at imp_democracy er kategorisk\n\n# Oppgave 9\n\ndem_reg <- lm(imp_democracy ~ age, data = wvs_sub)\n\n# Oppgave 10\n\nsummary(dem_reg)\n\n# Konstantledd: forventet skåre på imp_democracy når alder er 0, er 6.72\n# age: for hver enhets økning på alder (1 år), forventer vi at skåren til\n#      imp_democracy øker med 0.03. Altså vil man forvente at en person på\n#      20 år svarer ca 7.32 på imp_democracy (6.72 + (0.03 * 20)), mens en\n#      person på 70 år vil ha en forventet skåre på 8.82 (6.72 + (0.03 * 70))\n# Sammenhengen er også signifikant på mindre enn 0.001-nivå"
  },
  {
    "objectID": "laste_data.html",
    "href": "laste_data.html",
    "title": "STV1020",
    "section": "",
    "text": "Når du skal laste inn et datasett til RStudio, og det oppstår problemer, kan du sjekke tipsene under. Her er eksemplene fra en Mac, men de samme løsningene vil finnes også på Windows og Linux.\n\n\nPass på at du enten åpner prosjektfilen din eller setter working directory til en mappe du finner igjen. For eksempel kan du lage en mappe som heter “R-seminar” på skrivebordet, og så lage undermapper for hvert seminar. Dere kan sette working directory som vist under, eller bruke koden setwd(). Hvis dere vil dobbeltsjekke, bruk funksjonen getwd().\n\nDet aller viktigste er å finne en god måte å strukturere prosjektene sine på. Eksempelvis “R Best Practices”. Ta gjerne også en titt på RStudios/posit egen side for hvordan man bruker prosjekter.\n\n\n\nPass på at datasettfilen ligger i mappen du prøver å hente den fra. For eksempel er det lurt å ha datasett i en egen datamappe der prosjektfilen din er lagret. På bildet under ser dere hvordan det er gjort i dette eksempelet.\n\nDu kan også sjekke hvilke filer som ligger i mappen du jobber fra i R med funksjonen list.files()\n\n\n\nDobbeltsjekk koden du skriver i RStudio, sjekk for skrivefeil, parenteser og hermetegn, og at filnavnet er det samme som du har lagret filen som.\nBruk gjerne tab for å finne frem filen din for å unngå problemer med skrivefeil. Still markøren i hermetegnene i koden for å laste inn data og trykk på tab-knappen (hvilken knapp det er kan du google) for å liste opp mapper og filer i working directory/prosjektmappen din. Om datafilen er lagret i working directory/prosjektmappen så kommer den opp i en liste som vist på bildet under.\n\n\n\n\n\nHer er de ulike kodene for å laste inn filtyper. Der det står “navn” er navnet dere gir objektet, dette finner dere på selv. Der det står “file” skal dere sette inn filnavnet. Altså det filen heter i mappen dere lagret den i.\n\n\n\ninstall.packages(\"readxl\")\nlibrary(readxl)\n\nnavn <- read_excel(\"file\")\n\n\n\n\n\nnavn <- read.csv(\"file\")  \nnavn <- read.csv2(\"file\")\n\n\n\n\n\nload(\"file\")\n# Merk at her gir du ikke datasettet et eget navn\n\n\n\n\n\ninstall.packages(\"haven\")\nlibrary(haven)\n\nnavn <- read_dta(\"file\")\n\n\n\n\n\ninstall.packages(\"haven\")\nlibrary(haven)\n\nnavn <- read_sav(\"file\")\n\nVær obs på at variabler som egentlig er faktorer kan bli lest som numeriske ved bruk av haven. Derfor er det ekstra viktig å sjekke kodebok og/eller labels.\nHvis dere har fulgt stegene over, men likevel ikke får lastet inn datasettet:\n\nSjekk om pakkene du har installert er oppdatert.\n\nFor å undersøke om noen av pakkene trenger en oppdatering, kan dere trykke på ‘tools’ og ‘check for package updates’.\nEller kjøre funksjonen update.packages(ask = FALSE)\n\nHvis du har Mac, sjekk at maskinen din er oppdatert.\n\nEr du usikker på hvordan så se på Apple sine support-sider\n\nSjekk at du har riktig versjon av R og Rstudio for maskinen din\n\nEr du usikker så sjekk installasjonsveiledningen\n\n\nHvis dere har gått gjennom alle stegene, og likevel ikke får lastet inn datasettene så er neste steg å gå innom kodekafé for å få hjelp.\n\n\n\n\nFor å undersøke om tidyverse er installert kan dere kjøre koden under. Du skal få opp et plot nederst til høyre i RStudio når du kjører koden:\n\n# Install.packages er ikke nødvendig å kjøre om du allerede har installert pakken\ninstall.packages(\"tidyverse\") \nlibrary(tidyverse)\ndata <- data.frame(x = c(1,1,1,2,2,3,4,4,5))\nggplot(data = data, aes(x = x)) +\n  geom_bar()\n\nPlottet skal se omtrent slik ut:"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduksjon",
    "section": "",
    "text": "👋 Velkommen til R-seminarer i STV1020! 👋\nI denne lille notatboka1 finner du litt informasjon om praktisk ting og tang. Det kan være lurt å se over de forskjellige sidene i venstremargen:"
  },
  {
    "objectID": "index.html#om-r-seminarene",
    "href": "index.html#om-r-seminarene",
    "title": "Introduksjon",
    "section": "Om R-seminarene",
    "text": "Om R-seminarene\nBoka inneholder også fundamentet for det vi skal gå gjennom i seminarene. I STV1020 har vi 6 seminarer der vi går gjennom grunnleggende funksjoner og måter å jobbe med R på. Tema for seminarene er:\n\nGrunnleggende R – kalkulator, indeksering, objekter, osv\nData – laste inn, lage deskriptiv statistikk og visualisering\nDatamanipulering – omkoding, tabeller, visualisering\nBivariate sammenhenger – korrelasjon, krysstabulering og visualisering\nBivariat regresjon – OLS\nMultivariat regresjon – OLS\n\nDet er mye å sette seg inn i når man starter helt fra bunn, men å bruke litt innsats på R nå, kan gi gevinster senere. Mange ender opp med å skrive kvantitative oppgaver i andre kurs eller bacheloroppgave, mens andre kan få bruk for kunnskapen i jobbsammenheng. På kort sikt har vi sett at å jobbe godt med R i STV1020 også gjør læringen i resten av kurset noe mer lettfattelig.\nR-seminarene blir etterfulgt av en digital prøve som du må bestå for å kunne gå opp til eksamen i STV1020 (se emneside for STV1020). Dersom du ikke består på første forsøk så får du et nytt forsøk. Man kan enten bruke egen laptop (anbefalt) eller en stasjonær UiO-PC (alle maskiner på Eilert Sundt skal ha R og RStudio installert) når man skal bruke R. For de som har PCer som ikke kjører så godt, kan workbench være et godt alternativ."
  },
  {
    "objectID": "index.html#forventninger",
    "href": "index.html#forventninger",
    "title": "Introduksjon",
    "section": "Forventninger",
    "text": "Forventninger\nFør første seminar så forventer vi:\n\n💾 At du har lastet ned og installert R og Rstudio før første seminar. Følg gjerne installasjonsguiden på denne siden. 💻\n📈 At du har lest gjennom guide for innlasting av datasett 📉\n\nUnder seminarrekka forventer vi:\n\n👩‍🎓 At du møter opp på seminar. 👨‍🎓\n📚 At du jobber med å løse oppgaver mellom seminarene. 📚\n\nDette er viktig for at seminarene skal gå så smidig som mulig og for at dere skal få læringsutbytte av å delta. For noen kan R virke skummelt ved første øyekast, men erfaringsmessig så går dette veldig fint så lenge du legger ned litt innsats underveis 🎉 🥳 🎉"
  },
  {
    "objectID": "index.html#nyttige-lenker",
    "href": "index.html#nyttige-lenker",
    "title": "Introduksjon",
    "section": "Nyttige lenker",
    "text": "Nyttige lenker\n\nCoffee & Coding\nØve deg på R direkte relatert til STV1020 i denne tutorialen.\nBli med i facebookgruppen R for statsvitenskap ved UiO.\nDiscord server for STV\nR-workbench for UiO-brukere\nRStudio Keyboard Shortcuts for Windows, Linux and Mac hjelper deg å kode raskere.\nStack overflow er et forum hvor folk stiller spørsmål og får hjelp til ulike utfordringer med R. Om du lurer på noe så vil du som regel finne svar her.\nRstudio community forum er litt i samme gate som Stack overflow.\nUsing projects gir en introduksjon til hvordan dere kan bruke prosjekter i Rstudio.\nSe et forslag til mappestruktur.\nThe tidyverse style guide for R inneholder mange tips for å skrive forståelig og god kode.\nR for Data Science er en veldig god bok for dere som vil fordype dere videre.\nRStudio Cheatsheets oppsummerer pakker eller oppgaver i R som for eksempel ggplot2. Gevinsten i disse juksearkene er størst når en har litt forståelse for hva pakken gjør.\nOslo UseR! group og R-Ladies Oslo arrangerer jevnlig interessante foredrag og workshops om R."
  },
  {
    "objectID": "installasjon.html",
    "href": "installasjon.html",
    "title": "STV1020",
    "section": "",
    "text": "Du må installere R og Rstudio før første seminar. Dersom du allerede har installert R og Rstudio så er det fint om du oppdaterer til siste versjon før seminar. Om alle har samme versjon så vil seminarene gå mye smidigere.\nDersom du trenger hjelp eller har problemer med installasjon/oppdatering så kan du komme på ☕ kodekafé ☕.\nHar du R og Rstudio installert?\n\nJa - følg instruksjonene under “Hvordan oppdatere R og Rstudio”.\nNei - følg instruksjonene under “Hvordan installere R og Rstudio”.\n\n\n\n\n💻 Windows 💻\n\nÅpne en nettleser og gå til www.r-project.org.\nKlikk på “download R” lenken. Den er i første avsnitt under “Getting started”.\nVelg CRAN location. Her burde du gå for Norway. Klikk på lenken.\n\nKlikk på “Download R for Windows” på toppen av siden.\nKlikk på “install R for the first time”.\nKlikk på “Download R for Windows” og lagre filen på maskinen din. Når nedlastningen er ferdig så åpner du .exe-filen og følger installasjonsveiledningen.\nNå kan du laste ned Rstudio.\n\n🍎 Mac 🍎\n\nÅpne en nettleser og gå til www.r-project.org.\nKlikk på “download R” lenken. Den finner du i første avsnitt under “Getting started”.\nVelg CRAN location. Her burde du gå for Norway. Klikk på lenken.\nKlikk på “Download R for (Mac) OS X” på toppen av siden. Du må lese det som står på siden du kommer til nå nøye dersom du har Mac.\nVelg den R-versjonen som passer den operativsystemversjonen du har. Om du har en eldre MacBook så er det viktig at du klikker på riktig lenke. Er du usikker på hvilken macOS-versjon du har så kan du klikke på eplet i venstre hjørne og velge “about this mac”. Der skal det stå macOS etterfulgt av navnet på versjonen.\nKlikk på lenken som matcher din versjon og lagre filen på maskinen. Når nedlastningen er ferdig så åpner du filen og følger installasjonsveiledningen.\nNå kan du laste ned Rstudio.\n\n🐧 Linux (Ubuntu 20.04+) 🐧\n\nInstallere dependencies:\n\nsudo apt install dirmngr gnupg apt-transport-https ca-certificates software-properties-common\n\nLegge til CRAN i listen over repositories:\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9`\nsudo add-apt-repository 'deb https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/'\n\nInstallere R:\n\nsudo apt install r-base r-base-dev\n\nSjekk om det virker:\n\nR --version\n\n\n\n\n\n\nGå til www.rstudio.com.\nTrykk på “Download”.\nTrykk “Download” knappen under gratisversjonen av Rstudio Desktop.\nFinn den versjonen som er anbefalt for operativsystemet ditt. Klikk på lenken i kolonnen “Download” for å laste ned installasjonsfilen.\nKjør filen og følg installasjonsveiledning.\n\nNå er du klar for første R-seminar!\n\n\n\nSeminarene går smidigere om alle bruker samme versjon av R. Dersom du har R og Rstudio installert fra før så kan du følge denne oppskriften for å sjekke hvilken versjon du har og eventuelt oppdatere dersom nødvendig.\n\n\n\nÅpne Rstudio. Øverst i konsoll så vil du se “session info”. Den første linjen forteller deg hvilken R versjon du bruker. Alternativt så kan du kjøre koden R.version.string for å printe R versjonen.\nHar du R versjon 4.2.2 installert?\n\nNei - følg instruksjonene for å “Oppdatere R og Rstudio”\nJa - supert! Du er klar for første R-seminar!\n\n\n\n\n💻 Windows 💻\nFor å oppdatere R på en Windows maskin så kan du prøve å bruke pakken installr.\n\nInstaller og last inn installr: skriv inn og kjør kodene install.packages(\"installr\") og library(installr)\nSkriv updateR() og kjør koden. Dette vil starte oppdateringsveilederen til R.\nFor å oppdatere Rstudio så åpner du Rstudio, velger Help > Check for Updates. Dette vil sende deg til Rstudios nettside hvor du kan laste ned den nyeste versjonen.\n\nNå er du klar for første R-seminar!\n🍎 Mac 🍎\nPå Mac så laster du selv ned og installerer den nyeste versjonen av R. Når du restarter Rstudio så vil den oppdaterte versjonen av R automatisk bli tatt i bruk. NB! Her er det snakk om den nyeste versjonen av R som er kompatibel med din Mac.\n\nFølg installasjonsveiledningen for MAC.\nFor å oppdatere Rstudio så åpner du Rstudio, velger Help > Check for Updates. Dette vil sende deg til Rstudios nettside hvor du kan laste ned den nyeste versjonen.\n\n🐧 Linux (Ubuntu 20.04+) 🐧\nR oppdateres som alt annet på Ubuntu: 1. sudo apt update 2. sudo apt upgrade\nRstudio oppdateres ved å følge veiledningen for installasjon av Rstudio over.\nNå er du klar for første R-seminar!"
  },
  {
    "objectID": "seminar/seminar1.html",
    "href": "seminar/seminar1.html",
    "title": "Seminar 1 – Velkommen!",
    "section": "",
    "text": "Gjennom 6 seminarganger skal vi nå gå igjennom alt fra hva R og Rstudio er og hvordan det fungerer, til å kjøre våre helt egne regresjonsanalyser. Vi gleder oss!\nFør hvert seminar kommer vi til å legge ut lenke til fire ting på Canvas:\nI denne boken vil dere finne noe tekst, noen figurer og tabeller, og noe kode. Innholdet reflekterer det vi har planlagt å gå gjennom på seminarene. Eksempelkoden i boka blir markert i blokker som har en egen mørk bakgrunn som her:\nMens output av koden, der det er relevant, vil ha en lysegrå bakgrunn, som her:\nAlt som er skrevet i de mørke boksene kan dere kopiere inn i et R-script og kjøre for å se hva som skjer. Når det er en # (hash) foran en tekstlinje så betyr det at vi skriver en kommentar i scriptet. Når vi setter en # foran teksten så skjønner R at dette ikke er vanlig kode, men en kommentar. Resultatene av faktisk kode vil komme i et eget felt med grå bakgrunn under. Se for eksempel her:"
  },
  {
    "objectID": "seminar/seminar1.html#hjelpefiler",
    "href": "seminar/seminar1.html#hjelpefiler",
    "title": "Seminar 1 – Velkommen!",
    "section": "Hjelpefiler",
    "text": "Hjelpefiler\nOfte når vi bruker R er vi usikre på hvordan forskjellige funksjoner fungerer. Da kan det være nyttig å lese hjelpefilene som forteller hva en funksjon gjør, og hvordan en skal bruke den. For å gjøre dette skriver du et spørsmålstegn før navnet på funksjonen.\n\n# La oss prøve dette med 'mean()' funksjonen, som logisk nok finner\n# gjennomsnitt:\n?mean\n\nDersom du får et svar som under her så tyder det på at du ikke har installert pakken funksjonen ligger i. Da kan du legge til et spørsmålstegn til og kjøre kode ??vif.\n\n?vif\n\nNo documentation for 'vif' in specified packages and libraries:\nyou could try '??vif'\n\n\nI hjelpefilen får vi en del informasjon om funksjonen. Funksjoner hjelper oss å hente ut informasjon fra data. Et eksempel på data kan være en tallrekke fra 1 til 10. Informasjonen vi ønsker å hente ut kan for eksempel være gjennomsnittet eller standardavviket. Vi kan bruke funksjoner til å få R til å hente ut denne informasjonen for oss. Alle funksjoner har til felles at de tar noe data, f.eks. tall, og skaper et resultat. I tilegg har noen argumenter som gjør at vi kan endre på hvordan funksjonen lager resultatet, hva vi får opp i consol og liknende.\nLeser vi hjelpefilen til funksjonen mean() så ser vi at den øverst gir en beskrivelse, hvor det står at den returnerer gjennomsnittet. Under der kommer argumentene den godtar; et argument (x) som definerer hvilke data vi vil hente ut informasjonen fra, et argument for å trimme dataene, altså fjerne noe, og na.rm argumentet som forteller R hvordan de skal håndtere missingverdier i beregningen. Under Value får vi en beskrivelse av hva funksjonen “produserer”, før til slutt et eksempel av hvordan den brukes i bunn.\nHjelpefilene er en flott måte å finne ut hva en funksjon gjør, og hvordan vi kan bruke den. Samtidig kan den ofte være litt kronglete å lese. Da hjelper det ofte å se på eksemplene som alltid er i bunn av teksten. Ellers beskriver også Healy hvordan man kan lese hjelpefilene i Appendix. Skulle det fortsatt være vanskelig er det viktig å huske at det finnes et stort miljø rundt R, og ofte er det mange som har opplevd samme problem som deg! Litt googling, og et søk på https://stackoverflow.com/ vil fort gi gode svar! Det er også mulig å spørre i facebookgruppen R for statsvitenskap ved UiO.\nUnder er et eksempel på hjelpefil for funksjonen head():\n\n\n\nHjelpefileksempel"
  },
  {
    "objectID": "seminar/seminar1.html#syntax-feil",
    "href": "seminar/seminar1.html#syntax-feil",
    "title": "Seminar 1 – Velkommen!",
    "section": "Syntax-feil",
    "text": "Syntax-feil\nNår vi skriver kode vil vi fort gjøre en del feil. Det er helt vanlig og noe som er helt uungåelig! Dere vil nok fort merke at også seminarleder kan gjøre en hel del feil når vi skal vise dere eksempler i seminaret. En type feil kan likevel være grei å merke seg med en gang – mest fordi alle gjør den når de skriver kode. “Syntax-feil” er skrivefeil vi gjør når vi skriver kode. F.eks. kan det være å skrive men() istedenfor mean(), glemme å lukke en parantes sånn at vi skriver mean( og liknende. Noe av det fine med RStudio er at den markere sånne feil for oss!\n\n\n\nEksempler på feil kode og feilmeldinger\n\n\nBildet over viser eksempler på feilskrevet kode samt hvordan Rstudio markerer dette og hvilke feilmeldinger vi får når vi prøver å kjøre koden. Dere kan se at R har markert tre av fire linjenummer med en rød X. Dette er steder hvor RStudio mener vi har gjort feil. Hvis vi holder musepekeren over kryssene får vi opp forslag til hva som kan være feilen. \"Unexpected token ')'\" betyr at RStudio mener det er en parantes der som ikke skulle vært der. I tilegg er det røde streker under de delene av koden som RStudio mener er feil. Det som ofte gjør at ting stopper opp i R, er slike enkle skrivefeil/syntax-feil som dette. Derfor er det veldig nyttig at RStudio viser det på denne måten!"
  },
  {
    "objectID": "seminar/seminar1.html#objekter",
    "href": "seminar/seminar1.html#objekter",
    "title": "Seminar 1 – Velkommen!",
    "section": "Objekter",
    "text": "Objekter\nDet første vi skal se på er objekter. Objekter er i alle “ting” i R som kan inneholde noe annet. Noen objekter laster vi inn ved hjelp av pakker, noen er bygd inn i R og andre kommer vi til å lage selv. Dere kan tenke på for eksempel datasett, funksjoner og modellresultater som mulige objekter. Vi lager nye objekter ved å bruke R sin assignment operator <-.\nVi skal i hovedsak forholde oss til to typer objekter; vektorer og funksjoner. Hva disse er nok lettere å vise ved eksempel. La oss lage et objekt med informasjon om et tall. For å gjøre dette må vi først velge et objektnavn, så bruke <- (dette heter en “assignment operator”), og så skrive hva objektet skal inneholde. Her lager vi en vektor som heter “To” og som inneholder tallet 2.\n\nTo <- 2\n\n2 + To\n\n[1] 4\n\n\nSom dere ser kan vi nå skrive 2 + To, kjøre koden og få ut resultatet fire. Når vi nå skriver “To” vet R at vi egentlig mener tallet 2 som er lagret i objektet. For så enkle ting som dette så er det nok enklere å bare skrive 2, eller bruke en kalkulator for den saks skyld. Det fine med objekter er at de kan inneholde veldig mye informasjon!\nI første omgang kan vi prøve å lagre flere tall i et objekt. Det er flere måter vi kan gjøre dette på, for eksempel så kan vi skrive 1:10 for å få alle heltallene mellom 1 og 10, eller skrive c(1, 22, 5, 2, 1) for å lage en tallrekke. I det siste skiller vi tallene med komma. Objektene kan du kalle akkurat hva du vil, men som vi skal se på senere er det noen retningslinjer som er lure å følge:\n\nNavn bør bare inneholde små bokstaver, tall og _.\nIkke bruk et tall som første tegn.\nIkke bruk æ/ø/å.\nIkke bruk mellomrom.\nIkke bruk FALSE, TRUE, Inf, for, else, break, function eller andre funksjonsnavn\n\nLa oss nå lage noen flere objekter:\n\nen_til_hundre <- 1:100\ntall <- c(1, 4, 56, 8, 4, 2, 4)\n\ntall\n\n[1]  1  4 56  8  4  2  4"
  },
  {
    "objectID": "seminar/seminar1.html#funksjoner",
    "href": "seminar/seminar1.html#funksjoner",
    "title": "Seminar 1 – Velkommen!",
    "section": "Funksjoner",
    "text": "Funksjoner\nNå som vi har et script med flere elementer kan vi prøve å kjøre noen funksjoner på dem. En fuksjon er kort sagt noe man gir en eller annen input til, for så å få tilbake en output.1 La oss se om vi kan finne gjennomsnittet av disse vektorene:\n\nmean(en_til_hundre)\n\n[1] 50.5\n\nmean(tall)\n\n[1] 11.28571\n\n\nMed funksjonen mean() får vi gjennomsnittet (output) for hele vektoren/objektet (input). Som oftest er det det vi ønsker, men om vi kun ønsket gjennomsnittet av noen utvalgte tall så er det også mulig ved hjelp av indeksering eller filtrering. Dette skal vi se mer på senere. Vi kommer til å bruke en rekke funksjoner gjennom seminarrekka, og det kan fort virke litt overveldende mye å huske. Men det er alltid lov å søke opp hvilke funksjoner som gjør hva i R – denne boka er forhåpentligvis et godt utgangspunkt for slike søk."
  },
  {
    "objectID": "seminar/seminar1.html#indeksering",
    "href": "seminar/seminar1.html#indeksering",
    "title": "Seminar 1 – Velkommen!",
    "section": "Indeksering",
    "text": "Indeksering\nOm dere ser i environment så vil dere merke at etter navnet på vektoren tall så står det først “num” og deretter [1:7]. Den første teksten sier at dette er et numerisk objekt. Klasser skal vi straks gå inn på. Det neste viser lengden på vektoren vår. tall har sitt første tall i plassen 12, og siste i 7. Altså er det 7 elementer. Om vi ser på en_til_hundre ser vi at det står 1:100, og denne har altså 100 elementer.\nFor å få tak i et spesifikt element kan vi bruke disse klammeparanteser. La oss si at vi vil ha element nr. 5 i vektoren tall:\n\ntall[5]\n\n[1] 4\n\n\nNår vi kjører denne ser vi at vi får ut det femte tallet i tallrekka vi skreiv inn i stad. Dette kan vi også sjekke i environment for å se at stemmer.\nPå samme måte som vi definerte en rekke tall istad, kan vi også hente ut en rekke elementer.\n\ntall[3:6]\n\n[1] 56  8  4  2\n\ntall[c(3, 5, 3, 6)]\n\n[1] 56  4 56  2\n\n\nVi kan også finne gjennomsnittet av utvalgte tall:\n\nmean(tall[c(3, 5, 3, 6)])\n\n[1] 29.5\n\n\nEller bruke disse som et nytt objekt:\n\nny_vektor <- tall[c(3, 5, 3, 6)]"
  },
  {
    "objectID": "seminar/seminar1.html#klasser",
    "href": "seminar/seminar1.html#klasser",
    "title": "Seminar 1 – Velkommen!",
    "section": "Klasser",
    "text": "Klasser\nSå langt har vi kun jobbet med tallverdier. Ofte har vi variabler som ikke er tall, men f.eks. tekst eller ordinalverdier. I R vil vi også se at visse funksjoner krever at dataene er i visse klasser. Hovedklassene vi kommer til å bruke er; numeric, character, logical og factor. Numeric er tall (logisk nok). De fleste mattefunksjoner krever at dataene er numeric. For å sjekke om noe er numeric kan vi bruke funksjonen is.numeric().\n\nis.numeric(en_til_hundre)\n\n[1] TRUE\n\n# Her ser vi at vi får opp 'TRUE' som betyr at en_til_hundre er et\n# numerisk objekt\n\nVi kan også bruke funksjonen class() til å hente ut informasjon om klassen:\n\nclass(en_til_hundre)\n\n[1] \"integer\"\n\n\nDere vil noen ganger se at det skilles mellom “numeric” og “integer”. Forskjellen er at integer kun kan inneholde heltall, mens numeric kan ha desimaler. Dette er svært sjeldent interessant for vår del.\nNår vi vil skrive tekst bruker vi klassen “character”. En tekststring må alltid ha hermetegn (““) rundt seg, men ellers definerer vi den som vanlig:\n\nTekst <- \"Hei, jeg elsker R! <3\"\n# Denne klassen kan inneholde tekst, men vil f.eks. ikke kunne brukes\n# til matte.\nmean(Tekst)\n\nWarning in mean.default(Tekst): argument is not numeric or logical: returning\nNA\n\n\n[1] NA\n\n\nHer ser dere at vi får en feilmelding, som sier at argumentet ikke er numerisk eller logisk. Funksjonen gir oss derfor resultatet NA, som betyr missing, altså at det ikke eksisterer et resultat.\nVi kan også kreve at et objekt skal ha en viss klasse. Det gjør vi med funksjonen as.\"klassenavn\" (bytt ut “klassenavn” med for eksempel numeric eller character). Det kan føre til noen uforventede resultater. La oss gjøre om objektet tall til character:\n\ntall_ch <- as.character(tall)\nmean(tall_ch)\n\nWarning in mean.default(tall_ch): argument is not numeric or logical: returning\nNA\n\n\n[1] NA\n\n\nGrunnen til at vi får en feilmelding her er fordi vi ikke kan ta gjenomsnittet av tekst. Om dere ser i environment står det også nå at tall er chr (charater) og det “” rundt alle tegnene.\nDen siste klassen vi kommer til å bruke ofte (men det finnes flere) er “factor.” En faktor er en variabel som kan ha flere forhåndsdefinerte nivåer og brukes ofte når vi skal kjøre statistiske modeller. En lett måte å forstå faktorer på er å tenke på dem som ordinale variabler, hvor vi kan vite rekkefølgen på nivåene men ikke avstanden, som for eksempel utdanningsnivåene barneskole, ungdomskole, videregående skole.\nFor å lage en faktor bruker vi funksjonen factor(). La oss først lage en faktor med ulike utdanningsnivåer:\n\n# Lager en faktorvariabel uten å sette nivåer\nskolenivaer <- factor(c(\"Barneskole\", \"Ungdomskole\", \"Videregaende\", \"Videregaende\",\n    \"Universitet\", \"Ungdomskole\", \"Universitet\"))\n\n# Printer alle verdiene\nskolenivaer\n\n[1] Barneskole   Ungdomskole  Videregaende Videregaende Universitet \n[6] Ungdomskole  Universitet \nLevels: Barneskole Ungdomskole Universitet Videregaende\n\n# Printer alle nivåene\nlevels(skolenivaer)\n\n[1] \"Barneskole\"   \"Ungdomskole\"  \"Universitet\"  \"Videregaende\"\n\n# Er det noe som skurrer her?\n\nI eksempelet her kan vi se at vi først definerer de forskjellige verdiene som er i variabelen. Vi har ikke spesifisert hvilken rekkefølge nivåene har. Når vi ikke gjør det så baserer R rekkefølgen på alfabetet. Derfor få vi rekkefølgen “Barneskole” “Ungdomskole” “Universitet” “Videregaende”. For å unngå dette så kan vi spesifisere faktornivåene:\n\n# Endrer faktornivåene\nskolenivaer <- factor(skolenivaer, levels = c(\"Barneskole\", \"Ungdomskole\",\n    \"Videregaende\", \"Universitet\"))\nskolenivaer\n\n[1] Barneskole   Ungdomskole  Videregaende Videregaende Universitet \n[6] Ungdomskole  Universitet \nLevels: Barneskole Ungdomskole Videregaende Universitet\n\nlevels(skolenivaer)\n\n[1] \"Barneskole\"   \"Ungdomskole\"  \"Videregaende\" \"Universitet\" \n\n\nI toppen her nevnte vi at en vektor var et objekt som inneholdt elementer av samme klasse. Så langt har vi også holdt oss til det gjennom å kunne lage objekter med tekst eller tall. Hva skjer da om vi prøver å blande? Vi kan lage et objekt som inneholder både tekst og tall:\n\nteksttall <- c(1, 4, 0, 4, \"Bamse\", \"R\", \"R Seminarer er de BESTE seminarer\",\n    42, \"the answer\")\n\nclass(teksttall)\n\n[1] \"character\"\n\nmean(teksttall[1:4])\n\nWarning in mean.default(teksttall[1:4]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\nSom vi kan se er her klassen blitt character, også for tallene! Det er fordi at når vi definerer en vektor som inneholder flere klasser, blir det slått sammen til den klassen som har minst informasjon. Dette kalles “implicit coercion”, og rekkefølgen går: logical -> integer -> numeric -> complex -> character."
  },
  {
    "objectID": "seminar/seminar1.html#dataframes",
    "href": "seminar/seminar1.html#dataframes",
    "title": "Seminar 1 – Velkommen!",
    "section": "Dataframes",
    "text": "Dataframes\nNoen ganger har vi lyst til å slå sammen data som er av forskjellige typer. F.eks. kan det være at vi har data om alder, navn, fylke og vil ha dette som et objekt eller datasett. For å gjøre dette bruker vi data.frames. En dataframe består av flere kolonner, hvor hver kolonne er en vektor. Vektorene kan ha ulik klasse, og det kan for eksempel være en character vektor og en numerisk vektor. Vi kan tenke på disse kolonnene som variabler.\nVi kan tenke på hver rad i en dataframe som en observasjon. En observasjon kan for eksempel være en person, et land i et gitt år eller en by. Når vi skal kjøre analyser i senere seminarer så vil vi som regel laste inn datasett/dataframes som andre har laget, men vi kan også lage dem selv. I dette eksempelet skal vi se på navnestatistikk i Oslo hentet fra SSB.no. Først lager vi vektorer som vi gir passende navn og lagrer i environment:\n\nnavn <- c(\"Mohammed\", \"Jakob\", \"Olav\", \"Martin\", \"Maja\", \"Sofia\", \"Iben\",\n    \"Therese\")\n\nantall <- c(94, 76, 68, NA, 65, 64, 60, NA)\n\nper_tusen <- c(19, 16, 14, NA, 14, 14, 13, NA)\n\nkjonn <- c(\"Gutt\", \"Gutt\", \"Gutt\", \"Gutt\", \"Jente\", \"Jente\", \"Jente\", \"Jente\")\n\nby <- c(\"Oslo\")\n\nEn viktig regel for dataframes er at alle vektorene må ha lik lengde. I eksempelet med navnestatistikk i Oslo så fantes det ikke data for navnene Martin og Therese (det finnes sikkert, men ikke i tabellen vi så i). Om vi mangler data så må vi finne en måte å “fylle” disse tomme cellene på. Når vi setter verdien til NA så forteller vi R at vi mangler data om akkurat denne observasjonen på denne variabelen. Dette er nødvendig for at R skal klare å matche informasjonen i de ulike vektorene korrekt. For å sjekke lengden på vektoren så kan vi se i environment eller bruke funksjonen length().\n\nlength(navn)\n\n[1] 8\n\nlength(by)\n\n[1] 1\n\n\nHer ser vi at alle vektorer har lengde 8 med unntak av by som bare har en. Du kan også kombinere vektorer med enkeltverdier som med “Oslo” i eksempelet over. Når du gjør det vil alle observasjonene få verdien “Oslo” på variabelen “by”. Dette kan vi se nærmere på ved å lage datasettet. Vi lager datasettet ved hjelp av funksjonen data.frame():\n\nnavnestat <- data.frame(navn, antall, per_tusen, kjonn, by)\n\nI environment vil dere nå se at det dukker opp en ny rad under “Data” som heter navnestat. Når det står 8 obs (observasjoner) av 5 variabler betyr dette at vi har et datasett/dataframe med 8 rader og 5 kolonner. Klikker dere på objektet så vil dere se dette. Vi kan utforske datasettet nærmere ved å bruke View() (obs! stor V):\n\nView(navnestat)\n\nFørste observasjonen her er rad 1. Det er navnet Mohammed. Det viktigste med en dataframe er at vi nå kan kombinere ulik informasjon om samme observasjon på en gang. Det er flere måter vi kan bruke dette på. La oss først se på hvordan vi kan gjøre enkle analyser av en kolonne.\nTil nå så har vi bare skrevet navnet på vektoren for å hente ut informasjon. Nå som vi har det i en dataframe, må vi først velge denne, og så kolonnen. Det er to måter vi kan gjøre dette på:\n\n# Med klammeparanteser kan vi velge rad og kolonne. Rad kommer først,\n# og så kolonnen: `datasett[rader, kolonner]`\nnavnestat[2, 1]\n\n[1] \"Jakob\"\n\n# Skriver vi en tom får vi alle kollonene/radene\nnavnestat[, 2]\n\n[1] 94 76 68 NA 65 64 60 NA\n\nnavnestat[2, ]\n\n   navn antall per_tusen kjonn   by\n2 Jakob     76        16  Gutt Oslo\n\n\nDet blir det fort vanskelig å huske tallet til plasseringen til en variabel. En mer vanlig måte å hente ut kolonner på er med $:\n\n# Her skriver vi først navnet på dataframen, og så variabelen:\nnavnestat$antall\n\n[1] 94 76 68 NA 65 64 60 NA\n\n# La oss prøve å få ut gjennomsnittlet til antall\nmean(navnestat$antall)\n\n[1] NA\n\n\nHm. Her ser dere at vi fikk NA til svar istedet for det gjennomsnittet vi ønsket. NA betyr som sagt bare missing, altså at vi ikke har informasjon om noe. Som dere husker så mangler vi informasjon om navnene Martin og Therese. Når minst en av verdiene er NA vil flere funksjoner returnere NA fordi vi strengt tatt ikke kan vite gjennomsnittet om vi ikke vet alle verdiene. For å få ut et resultat må vi derfor fortelle R at vi ønsker å fjerne NA-verdiene, og heller få gjenomsnittet av de verdiene som er tilstede. Det gjør vi ved å legge til argumentet na.rm = TRUE i funksjonen:\n\nmean(navnestat$antall, na.rm = TRUE)\n\n[1] 71.16667\n\nmedian(navnestat$antall, na.rm = TRUE)\n\n[1] 66.5\n\n\nEn lettere måte å få ut alle disse på er ved å bruke summary() funksjonen. Da trenger vi heller ikke bruke na.rm, fordi den heller sier hvor mange NA det er i vektoren. summary() kan også brukes for å hente ut informasjon om et helt datasett.\n\nsummary(navnestat$antall)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  60.00   64.25   66.50   71.17   74.00   94.00       2 \n\nsummary(navnestat)\n\n     navn               antall        per_tusen       kjonn          \n Length:8           Min.   :60.00   Min.   :13.0   Length:8          \n Class :character   1st Qu.:64.25   1st Qu.:14.0   Class :character  \n Mode  :character   Median :66.50   Median :14.0   Mode  :character  \n                    Mean   :71.17   Mean   :15.0                     \n                    3rd Qu.:74.00   3rd Qu.:15.5                     \n                    Max.   :94.00   Max.   :19.0                     \n                    NA's   :2       NA's   :2                        \n      by           \n Length:8          \n Class :character  \n Mode  :character"
  },
  {
    "objectID": "seminar/seminar1.html#ulike-typer-vektorer-i-r",
    "href": "seminar/seminar1.html#ulike-typer-vektorer-i-r",
    "title": "Seminar 1 – Velkommen!",
    "section": "Ulike typer vektorer i R",
    "text": "Ulike typer vektorer i R\nDet finnes flere ulike objekter i R. Til nå har vi blitt introdusert for to av dem: datasett og vektorer. Hva slags objekt det er har noe å si for hva du kan gjøre med det. I tillegg finnes det ulike typer, eller klasser som vi kaller det, av vektorer. I tabellen under finner dere en grov inndeling av ulike typer vektorer i R:\n\n\n\n\n\n\nAtomic vector\nList\n\n\n\n\nnumeric\nblanding\n\n\ninteger\n\n\n\ncharacter\n\n\n\nfactor\n\n\n\nlogical\n\n\n\n\nEn hyppig årsak til at en funksjon ikke fungerer, er at en vektor/variabel ikke er i det formatet vi forventet. Tabellen gir en oversikt over variabeltypene vi skal jobbe med. Atomic vector har kun verdier av en type, mens lister kan ha flere typer verdier, samt bestå av flere variabler.\nHvilket format tror du navn, antall og by har?\nDet kan vi sjekke med funksjonen class().\n\nclass(navnestat$navn)\n\n[1] \"character\"\n\nclass(navnestat$antall)\n\n[1] \"numeric\"\n\nclass(navnestat$by)\n\n[1] \"character\"\n\n\nSom dere ser er antall numeric, mens navn og by er character. Her er det hva objektet er lagret som som teller, ikke hvordan det ser ut i datasettet. Selv om noe ser ut som tall i datasettet så er det ikke sikkert det er registrert som tall av R. Heldigvis kan dette ofte løses ved hjelp av en funksjoner som as.numeric(), as.character() og as.factor().\n\n# Her lager vi en ny variabel antall2 der vi ber R lagre alder som\n# character\nnavnestat$antall2 <- as.character(navnestat$antall)\n\nOm vi ser på datasettet etter at vi har laget den nye variabelen så ser vi at alder og alder2 ser helt like ut. Begge fremstår som tall vi kan gjøre regneoperasjoner på, men bare en av dem er det. Prøv gjerne selv å kjøre funksjonen mean() som regner ut gjennomsnittet på alder2."
  },
  {
    "objectID": "seminar/seminar1.html#logiske-tester",
    "href": "seminar/seminar1.html#logiske-tester",
    "title": "Seminar 1 – Velkommen!",
    "section": "Logiske tester",
    "text": "Logiske tester\nR kan evaluere logiske utsdagn og bedømme om de er ´TRUE´ eller ´FALSE´.\n\n1 == 2  # tester om 1 er lik 2\n\n[1] FALSE\n\n2 == 2  # tester om 2 er lik 2\n\n[1] TRUE\n\n\"Statsvitenskap\" == \"statsvitenskap\"  # Logiske tester kan også brukes på tekst\n\n[1] FALSE\n\n\"statsvitenskap\" == \"statsvitenskap\"  # R er imidlertid sensitivt til store og små bokstaver\n\n[1] TRUE\n\n1 <= 2  # Tester om 1 er mindre enn eller lik 2\n\n[1] TRUE\n\n1 >= 2  # Tester om 1 er større enn eller lik 2\n\n[1] FALSE\n\n1 != 2  # Tester om 1 er ulik 2\n\n[1] TRUE\n\n1 == 2 | 1 == 1  # Tester om en av de to påstandene 1 er lik 2 eller 1 er lik 1 er sanne\n\n[1] TRUE\n\n1 == 2 & 1 == 1  # Tester om begge de to påstandene 1 er lik 2 og 1 er lik 1 er sanne\n\n[1] FALSE\n\n\nOversikt over logiske operatorer:\n\n\n\nOperator\nBetydning\n\n\n\n\n==\ner lik\n\n\n<\nmindre enn\n\n\n>\nstørre enn\n\n\n<=\nmindre eller lik\n\n\n>=\nstørre eller lik\n\n\n!=\nikke lik\n\n\n!x\nikke x\n\n\n|\neller\n\n\n&\nog\n\n\n\nVi kommer til å bruke disse operatorene mye, spesielt når vi gjør endringer i datasett som å lage nye variabler. Det er derfor viktig at dere forstår hvordan disse fungerer. Den beste måten å få denne foreståelse på er å øve."
  },
  {
    "objectID": "seminar/seminar2.html",
    "href": "seminar/seminar2.html",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "",
    "text": "På andre seminar skal vi se på det følgende:"
  },
  {
    "objectID": "seminar/seminar2.html#overskrifter-og-tekst",
    "href": "seminar/seminar2.html#overskrifter-og-tekst",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Overskrifter og tekst",
    "text": "Overskrifter og tekst\nHvordan man organiserer et R-script kommer an på hva man selv synes er mest oversiktlig, men det er viktig at man klarer å holde oversikt over hva man har kodet og forstår hva man har gjort når man kommer tilbake til et script.\nDet er lurt å lage overskrifter for å huske hva du tenker at koden din skal gjøre. Dersom du velger overskriftformatet “# Overskrift —-” så vil R automatisk gi deg muligheten til å gjemme koden under overskriften. Om du trykker på “Show document outline” i menylinjen til høyre over scriptet ditt kan du også få opp en innholdsfortegnelse basert på overskriftene dine.\n\n\n\nRyddig kode gjør det enklere for deg selv og andre når du står fast. Tegneserie fra XKCD: https://xkcd.com/1513/\n\n\nDet kan også være lurt å inkludere kommentarer i scriptet ditt som forklarer hva du gjør. Tekst som ikke skal leses av R skriver man etter emneknagg (#). Vi glemmer fort så det er en god idé å tenke at du skal kunne se tilbake på dette scriptet om et år igjen og skjønne hva du har gjort:\n\nTil sist så er det lurt å ikke skrive for mange tegn før du bytter linje. The tidyverse style guide anbefaler at en begrenser antall tegn til 80 per linje. R teller for hvor mange tegn du har per linje til venstre nedenfor scriptet ditt. Tidyverse sin stilguide inneholder også flere tips til hvordan man kan skrive lettleselig kode."
  },
  {
    "objectID": "seminar/seminar2.html#laste-inn-ess",
    "href": "seminar/seminar2.html#laste-inn-ess",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Laste inn ESS",
    "text": "Laste inn ESS\nVi kan laste inn data vi skal bruke på seminar 2 – ess.csv – med følgende kode:\n\ness <- read.csv(\"../data/ess.csv\", encoding = \"UTF-8\")\n\nI denne boka ligger mappen “data” i en mappe som er et nivå under der koden for seminar 2 ligger. Derfor starter read.csv() med .., som betyr “gå en mappe tilbake”. Deretter går vi inn i “data”-mappen og så spesifiserer vi at vi vil lese filen “ess.csv” med read.csv(). Du må selv tilpasse filplasseringen i denne funksjone til hvor du jobber fra i R og hvor du har lagt filen selv. Når filen er lastet inn, skal den ligge i vinduet “Environment” øverst til høyre i RStudio. Her er noen nyttige filbanekoder:\n\n\n\n\n\n\n\nKode\nBeskrivelse\n\n\n\n\n\"~/\"\nPå Mac og Linux er dette “Home”, på Windows er det brukermappen “C:/Users/brukernavn”\n\n\n\"C:/\"\nFor Windowsbrukere; disken du jobber fra\n\n\n\"./\"\nMappen du er i nå, kan vises med: getwd(\"./\")\n\n\n\"../\"\nEn mappe tilbake fra der du er nå: getwd(\"../\")\n\n\n\"./data\"\nFra der jeg er nå, gå inn i mappen “data”\n\n\n\"../data\"\nFra der jeg er nå, gå tilbake en mappe og så inn i mappen “data”\n\n\n\"./seminar2/R\"\nFra der jeg er nå, gå inn i mappen “seminar2” og så inn i mappen “R”\n\n\n\"../../R\"\nFra der jeg er nå, gå tilbake to mapper og så inn i mappen “R”\n\n\n\nDu kan også validere om du har gjort riktig ved å kjøre:\n\ndim(ess)\n\n[1] 1406  572\n\n\nDet skal da komme opp samme output i din console – [1] 1406 572 – som betyr at det er 1406 enheter i datasettet og 572 variabler."
  },
  {
    "objectID": "seminar/seminar2.html#kategorisk",
    "href": "seminar/seminar2.html#kategorisk",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Kategorisk",
    "text": "Kategorisk\nNår variabler er kategoriske så kan egenskapen deles i to eller flere gjensidig utelukkende kategorier. I ESS datasettet vårt er variabelen “vote” kategorisk; man har enten stemt, ikke stemt, eller så er man ikke berettiget til å stemme. Dette kan vi se i utklippet fra kodeboken.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen vote\n\n\nVi kan sjekke hvilken klasse variabelen har ved hjelp av class()\n\nclass(ess_subset$vote)\n\n[1] \"integer\"\n\n\nHer får vi opp klassene integer som betyr heltall, mens double betyr at variabelen nå er lagret som en numerisk variabel. På variabler med kategorisk eller ordinalt målenivå kan vi bruke funksjonen table() til å få oversikt over verdiene:\n\ntable(ess_subset$vote)\n\n\n   1    2    3 \n1156  124  125 \n\n\nSom vi ser her så fremstår variabelen som om den er kontinuerlig/numerisk med tallverdier, men vi har lest kodeboken og vet at den er kategorisk. Dersom vi vil endre klassen på variabelen til en faktor så det samsvarer bedre med målenivået så kan vi bruke funksjonen as.factor() for å opprette en ny variabel:\n\n# Lager en ny variabel i datasettet som heter vote_factor\ness_subset$vote_factor <- as.factor(ess_subset$vote)\n\nVi kan nå se nærmere på hvilke verdier den nye variabelen vote_factor tar ved hjelp av levels() og klassen ved hjelp av class():\n\n# Sjekker faktornivåene:\nlevels(ess_subset$vote_factor)\n\n[1] \"1\" \"2\" \"3\"\n\n# Sjekker klasse:\nclass(ess_subset$vote_factor)\n\n[1] \"factor\"\n\n\nNå samsvarer variabelens verdier (Yes, No, osv.) og klasse (factor) bedre med det faktiske målenivået til variabelen (kategorisk).2 Vi skal jobbe mer med omkoding av variabler senere."
  },
  {
    "objectID": "seminar/seminar2.html#ordinalnivå",
    "href": "seminar/seminar2.html#ordinalnivå",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Ordinalnivå",
    "text": "Ordinalnivå\nNår variabler er på ordinalnivå kan de deles i to eller flere gjensidig utelukkende kategorier som kan rangeres, men vi kan ikke si noe om avstanden mellom verdiene og en enhets økning har ikke samme betydning. I ESS datasettet vår så er variabelen interest et eksempel på en variabel på ordinalnivå; i utdraget fra kodeboken ser vi at man kan være ikke interessert, lite interessert, ganske interessert, eller veldig interessert i politikk.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen interest (opprinnelig navn polintr)\n\n\nVi kan sjekke klasse til denne variabelen også:\n\nclass(ess_subset$interest)\n\n[1] \"integer\"\n\n\nSom vi ser er også denne variabelen også registrert som integer. Dersom vi vil bruke denne variabelen som en kategorisk variabel så kan vi igjen bruke as.factor for å få variabelens klasse til å samsvare med målenivået:\n\ness_subset$interest_factor <- as.factor(ess_subset$interest)\n\nVi sjekker faktornivåer og klasse igjen:\n\n# Sjekker faktornivåene:\nlevels(ess_subset$interest_factor)\n\n[1] \"1\" \"2\" \"3\" \"4\"\n\n# Sjekker klasse:\nclass(ess_subset$interest_factor)\n\n[1] \"factor\"\n\n\nDette ser også fint ut. Som dere vet fra forelesning så er behandler man ofte variabler på ordinalnivå som enten kategorisk eller kontinuerlig målenivå. Dersom vi ville beholdt denne som en kontinuerlig variabel så hadde vi ikke trengt å omkode den ved hjelp av as.factor()."
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlig",
    "href": "seminar/seminar2.html#kontinuerlig",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Kontinuerlig",
    "text": "Kontinuerlig\nKontinuerlige variabler kan rangeres, har samme avstand mellom alle verdier og en enhets økning betyr alltid det samme. Her er det altså snakk om variabler med faktiske tallverdier. I ESS datasettet vårt så er variabelen “news” kontinuerlig. Som vi kan se i utdraget fra kodeboken så måler variabelen hvor mange minutter man bruker på nyheter hver dag. Det er et minutts avstand mellom hver verdi, og en økning på en enhet vil alltid bety en økning på et minutt.\n\n\n\nUtdrag fra ESS sin kodebok for variabelen news (opprinnelig navn nwspol)\n\n\nVi kan sjekke klassen her også:\n\nclass(ess_subset$news)\n\n[1] \"integer\"\n\nis.numeric(ess_subset$news)\n\n[1] TRUE\n\n\nDenne variabelen er double og skal være det så her er alt i orden.\nVi vil oppfordre dere til å være obs og alltid sjekke at klassen på en variabel dere skal bruke stemmer overens med målenivået.3 I mange datasett får kategoriske og ordinale variabler ofte tall istedenfor kategorinavn som verdier og lastes inn som klassen numeric. Dette gjør at kategoriske variabler kan fremstå som at de har et høyere målenivå enn de faktisk har i R. Derfor er det alltid viktig å også sjekke kodeboken for å se hvilket målenivå variabelen faktisk har. Det kommer ikke til å stå “denne variabelen har kategorisk målenivå” så dere må gjøre en selvstendig vurdering basert på hvilke verdier variabelen har."
  },
  {
    "objectID": "seminar/seminar2.html#kategoriske-variabler",
    "href": "seminar/seminar2.html#kategoriske-variabler",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Kategoriske variabler",
    "text": "Kategoriske variabler\nR har ingen innebygd funksjon for å finne modusverdien. Ved å søke på internett så finner du fort mange ulike funksjoner du kan bruke, men for å gjøre det enkelt bruker vi bare table(). Funksjonen table() gir oss en frekvenstabell, mens prop.table gjør om frekvenstabellen til andeler. ESS datasettet mangler data for noen observasjoner. Ved å ta med useNA = \"always\" i table() så får vi også denne informasjonen i tabellen:4\n\ntable(ess_subset$vote, useNA = \"always\")\n\n\n   1    2    3 <NA> \n1156  124  125    1 \n\nprop.table(table(ess_subset$vote))\n\n\n         1          2          3 \n0.82277580 0.08825623 0.08896797 \n\nprop.table(table(ess_subset$vote, useNA = \"always\"))\n\n\n           1            2            3         <NA> \n0.8221906117 0.0881934566 0.0889046942 0.0007112376"
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlige-variabler",
    "href": "seminar/seminar2.html#kontinuerlige-variabler",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Kontinuerlige variabler",
    "text": "Kontinuerlige variabler\n\n# Finner minimumsverdi (det laveste antall minutter brukt\n# på nyheter)\nmin(ess_subset$news, na.rm = TRUE)  # na.rm = TRUE sier at missing skal droppes i beregningen\n\n[1] 0\n\n# Finner maksimumsveriden (den høyeste antall minutter\n# brukt på nyheter)\nmax(ess_subset$news, na.rm = TRUE)\n\n[1] 1109\n\n# Finner gjennomsnittlig antall minutter\nmean(ess_subset$news, na.rm = TRUE)\n\n[1] 104.1006\n\n# Finner median\nmedian(ess_subset$news, na.rm = TRUE)\n\n[1] 60\n\n# Finner standardavviket\nsd(ess_subset$news, na.rm = TRUE)\n\n[1] 155.5571\n\n# Finner varians\nvar(ess_subset$news, na.rm = TRUE)\n\n[1] 24198.01\n\n# Finner kvantilverdiene\nquantile(ess_subset$news, na.rm = TRUE)\n\n  0%  25%  50%  75% 100% \n   0   30   60  120 1109 \n\n# Finner forskjellig deskriptiv statistikk for en variabel\nsummary(ess_subset$news)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    0.0    30.0    60.0   104.1   120.0  1109.0      34"
  },
  {
    "objectID": "seminar/seminar2.html#kategoriske-variabeler",
    "href": "seminar/seminar2.html#kategoriske-variabeler",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Kategoriske variabeler",
    "text": "Kategoriske variabeler\n\nSøylediagram og kakediagram med en variabel\nHvordan kan vi visualisere hvordan fordelingen av politisk interesse er? Her kan vi bruke geom_bar til å lage et søylediagram (bar chart). Et søylediagram viser antall observasjoner av hver verdi. Vi bruker her den variabelen vi lagde tidligere med “riktig” målenivå.\n\nggplot(ess_subset, aes(x = interest_factor)) + geom_bar()\n\n\n\n\nDersom vi ikke ønsker å gi missingverdiene (NA) en egen søyle så kan vi bruke filter() til å fjerne disse:\n\ness_subset %>%\n    filter(is.na(interest_factor) == FALSE) %>%\n    ggplot(., aes(x = interest_factor)) + geom_bar() + theme(axis.text.x = element_text(angle = 60,\n    hjust = 1))\n\n\n\n\nEt alternativ til søylediagram er kakediagram (pie chart):\n\ness_subset %>%\n    filter(is.na(interest_factor) == FALSE) %>%\n    ggplot(., aes(x = \"\", y = interest, fill = interest_factor)) +\n    geom_bar(stat = \"identity\", width = 1) + coord_polar(\"y\",\n    start = 0) + theme_void() + scale_fill_grey()\n\n\n\n\n\n\nSøylediagram med to variabler\nHvor mange innenfor hvert nivå av politisk interesse stemte? Vi kan bruke geom_bar() igjen, men vi sier at vi også vil se fordelingen av hvordan respondentene stemte innenfor hvert nivå av politisk interesse med (aes(fill = vote)). Så sier vi at vi vil at det skal være en søyle for de ulike alternativene for vote med position = \"dodge\".\n\ness_subset %>%\n    filter(is.na(interest_factor) == FALSE & is.na(vote_factor) ==\n        FALSE) %>%\n    ggplot(., aes(x = interest_factor)) + geom_bar(aes(fill = vote_factor),\n    position = \"dodge\") + theme(axis.text.x = element_text(angle = 60,\n    hjust = 1))"
  },
  {
    "objectID": "seminar/seminar2.html#kontinuerlige-variabler-1",
    "href": "seminar/seminar2.html#kontinuerlige-variabler-1",
    "title": "Seminar 2 – Laste og jobbe med data",
    "section": "Kontinuerlige variabler",
    "text": "Kontinuerlige variabler\n\nHistogram\nHvordan fordeler respondentenes alder og tiden de bruker på nyheter seg? Disse variablene er kontinuerlige, så vi kan bruke geom_histogram for å lage et histogram. Her gjør vi det med variabelen news.\n\nggplot(ess_subset, aes(x = news)) + geom_histogram(bins = 5) +\n    ggtitle(\"Histogram med fem søyler (bins) og frekvens\")\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\nggplot(ess_subset, aes(x = news)) + geom_histogram(binwidth = 10) +\n    ggtitle(\"Histogram med søylebredde (binwidth) på 10 og frekvens\")\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\nEt histogram viser hvor mange enheter det er i hver kategori. Vi kan enten spesifisere hvor mange søyler vi vil ha (bins) eller hvor stor hver søyle skal være (bindwidth). Vi kan også velge å plotte density fremfor count. Da får vi histogrammer tilsvarende figur 6.5 i Kellsted og Whitten:\n\nggplot(ess_subset, aes(x = news, y = ..density..)) + geom_histogram(bins = 5) +\n    ggtitle(\"Histogram med fem søyler (bins) og density\")\n\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(density)` instead.\n\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\nggplot(ess_subset, aes(x = news, y = ..density..)) + geom_histogram(binwidth = 10) +\n    ggtitle(\"Histogram med søylebredde (binwidth) 10 og density\")\n\nWarning: Removed 34 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\nBoksplott\nVi kan lage et boksplott med geom_boxplot. Et boksplott viser hvordan en kontinuerlig variabel er fordelt. Boksen representerer spennet til første (25 % ) og tredje (75 %) kvartil, mens streken midt i boksen viser andre (50 %) kvartil (også kjent som median). For å finne kvartilene så ordner vi observasjonene i stigende rekkefølge og deler dem inn i fire deler med like mange observasjoner i hver. Første kvartil angir grensen mellom første og andre fjerdedel. Det betyr at 25 % av observasjonene har en verdi som er lavere enn verdien til første kvartil, mens 75 % har en verdi som er høyere. Tilsvarende utgjøre tredje kvartil grensen mellom andre og tredje fjerdedel, og vi kan si at 75 % av observasjonene har en verdi som er lavere enn verdiene til tredje kvaritl, mens 25 % har en verdi som er høyere.\nPrikkene i grafen angir uteliggere. Uteliggere er observasjoner som har enten veldig høye eller veldig lave verdier relativt til de andre observasjonene. I R beregnes disse utfra kvartilbredden. Kvartilbredden er differansen mellom tredje og første kvartil. Alle observasjoner som er lavere enn første kvartil minus 1,5 ganger kvartilbredden eller høyere enn tredje kvartil pluss 1,5 ganger kvartilbredden regnes som uteliggere.\n\nggplot(ess_subset, aes(x = news, y = vote_factor)) + geom_boxplot() +\n    theme_minimal()\n\nWarning: Removed 34 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\nHvis dere vil utforske hvordan man kan tilpasse de ulike diagrammene vi har sett på og mange andre, kan denne siden være nyttig: https://www.r-graph-gallery.com/index.html"
  },
  {
    "objectID": "seminar/seminar3.html",
    "href": "seminar/seminar3.html",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "",
    "text": "På dette seminaret skal vi gjennom:"
  },
  {
    "objectID": "seminar/seminar3.html#matematisk-omkoding",
    "href": "seminar/seminar3.html#matematisk-omkoding",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Matematisk omkoding",
    "text": "Matematisk omkoding\nFørst skal vi lære å kode om variablene ved å bruke matematiske omkoding. For å vise dette bruker vi variabelem year. Ved hjelp av summary() så finner vi ut at den laveste verdien på variabelen er året 1952. Det er året observasjonen ble gjort. Vi vil gjøre dette året til år null, mens de andre verdiene på variablen skal bli hvor mange år etter år null ble observasjonen gjort.\n\n# Sjekker summary for opprinnelige variabel\nsummary(gapminder$year)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1952    1966    1980    1980    1993    2007 \n\n# spennet er 2007-1952, dvs. 55 år\n2007 - 1952\n\n[1] 55\n\n# Legger til ny variabel i datasettet\ngapminder$year_1952 <- gapminder$year - 1952\n\n# Sjekker summary for ny variabel\nsummary(gapminder$year_1952)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   13.75   27.50   27.50   41.25   55.00 \n\n\nSå undersøker vi om omkodingen er blitt gjort riktig ved å bruke funksjonen table(). Ofte, men ikke alltid, når man omkoder en variabel og krysstabulerer den nye variabelen med den gamle, vil frekvensene legge seg langs diagonalen i tabellen som her:\n\n# Lager en tabell med opprinnelig og ny variabel:\ntable(gapminder$year_1952, gapminder$year, useNA = \"always\")\n\n      \n       1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 <NA>\n  0     142    0    0    0    0    0    0    0    0    0    0    0    0\n  5       0  142    0    0    0    0    0    0    0    0    0    0    0\n  10      0    0  142    0    0    0    0    0    0    0    0    0    0\n  15      0    0    0  142    0    0    0    0    0    0    0    0    0\n  20      0    0    0    0  142    0    0    0    0    0    0    0    0\n  25      0    0    0    0    0  142    0    0    0    0    0    0    0\n  30      0    0    0    0    0    0  142    0    0    0    0    0    0\n  35      0    0    0    0    0    0    0  142    0    0    0    0    0\n  40      0    0    0    0    0    0    0    0  142    0    0    0    0\n  45      0    0    0    0    0    0    0    0    0  142    0    0    0\n  50      0    0    0    0    0    0    0    0    0    0  142    0    0\n  55      0    0    0    0    0    0    0    0    0    0    0  142    0\n  <NA>    0    0    0    0    0    0    0    0    0    0    0    0    0\n\n\nVi kan også endre retningen på verdienes ved matematisk omkoding. Da ganger vi variablene med (-1) og plusser på antall verdier variablene har. Nå blir 2007 år null.\n\n# Endrer retning på variabelen:\ngapminder$year_2007 <- (gapminder$year_1952 * -1) + 55\n\n# Alternativt:\ngapminder$year_2007 <- 55 - gapminder$year_1952\n\n# Sjekker at det ble riktig med table():\ntable(gapminder$year_1952, gapminder$year_2007, useNA = \"always\")\n\n      \n         0   5  10  15  20  25  30  35  40  45  50  55 <NA>\n  0      0   0   0   0   0   0   0   0   0   0   0 142    0\n  5      0   0   0   0   0   0   0   0   0   0 142   0    0\n  10     0   0   0   0   0   0   0   0   0 142   0   0    0\n  15     0   0   0   0   0   0   0   0 142   0   0   0    0\n  20     0   0   0   0   0   0   0 142   0   0   0   0    0\n  25     0   0   0   0   0   0 142   0   0   0   0   0    0\n  30     0   0   0   0   0 142   0   0   0   0   0   0    0\n  35     0   0   0   0 142   0   0   0   0   0   0   0    0\n  40     0   0   0 142   0   0   0   0   0   0   0   0    0\n  45     0   0 142   0   0   0   0   0   0   0   0   0    0\n  50     0 142   0   0   0   0   0   0   0   0   0   0    0\n  55   142   0   0   0   0   0   0   0   0   0   0   0    0\n  <NA>   0   0   0   0   0   0   0   0   0   0   0   0    0"
  },
  {
    "objectID": "seminar/seminar3.html#omkoding-med-ifelse",
    "href": "seminar/seminar3.html#omkoding-med-ifelse",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Omkoding med ifelse()",
    "text": "Omkoding med ifelse()\nDen funksjonen vi bruker mest til omkoding, er ifelse(). Funksjonen kan brukes på numeriske og kategoriske variabler. Syntaksen til denne funksjonen kan forklares som følger:\n\ndata$nyvar <- ifelse(test = data$variabel == \"some logical condition\",\n                     yes  = \"what to return if 'some condition' is TRUE\",\n                     no   = \"what to return if 'some condition' is FALSE\")\n\nifelse() kan for eksempel bruker til å lage en ny variabel som tar verdien 1 om observasjonen har en verdi som er større enn gjennomsnittet og null ellers. Gjennomsnittet finner du ved å bruke funksjonen mean(). Under fyller vi inn betingelsen (condition), hvilken verdi ny variabel skal dersom betingelsen er oppfylt (yes) og hvilken verdi ny variabel skal ha dersom betingelsen ikke er oppfylt (no). Vanligvis vil vi ikke skrive test =, yes = og no =, men vi har tatt det med her for å gjøre det lettere å koble de to:\n\ngapminder$lifeExp_num <- ifelse(test = gapminder$lifeExp > mean(gapminder$lifeExp, na.rm = TRUE),\n                                yes = 1,\n                                no = 0)\n\nHer har vi laget en ny variabel – gapminder$lifeExp_num – som tar verdien 1 om land-år-enheten har over gjennomsnittlig verdi på variabelen gapminder$lifeExp og verdien 0 hvis land-år-enheten ikke har over gjennomsnittlig verdi på gapminder$lifeExp."
  },
  {
    "objectID": "seminar/seminar3.html#omkoding-med-case_match",
    "href": "seminar/seminar3.html#omkoding-med-case_match",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Omkoding med case_match()",
    "text": "Omkoding med case_match()\nDersom vi vil omkode en variabel med flere variabler så kan vi gjøre det med flere ifelse() nøstet i hverandre. Det kan imidlertid bli veldig mye kode. Et alternativ er å kombinere mutate() og case_match(). mutate() er en funksjon i tidyverse vi bruker for å lage nye variabler. case_match() er også en del av tidyverse og den brukes til å endre verdier på variabler. Syntaksen til kombinasjonen av mutate() og case_match() er:\n\ndata %>% \n  mutate(nyvariabel = case_match(gammelvariabel, \n                                 gammel_verdi1 ~ ny_verdi1, \n                                 gammel_verdi2 ~ ny_verdi2))\n\nI dette eksempelet skal vi lage en ny variabel lifeExp_char der vi omkoder lifeExp_num til “high” dersom den gamle variabelen er 1 og “low” dersom den er 0. Ettersom funksjonen vi skal bruker ligger i pakken tidyverse så må vi aller først laste inn pakken med library()\n\nlibrary(tidyverse)\n\ngapminder <- gapminder %>% \n  mutate(lifeExp_char = case_match(lifeExp_num, \n                               1  ~ \"high\", \n                               0  ~ \"low\"))\n\nVi sjekker med en tabell at det ble riktig:\n\ntable(gapminder$lifeExp_char, gapminder$lifeExp_num)\n\n      \n         0   1\n  high   0 895\n  low  809   0"
  },
  {
    "objectID": "seminar/seminar3.html#steg-1-fortell-ggplot-hvor-vi-vil-hente-data-fra",
    "href": "seminar/seminar3.html#steg-1-fortell-ggplot-hvor-vi-vil-hente-data-fra",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Steg 1: Fortell ggplot() hvor vi vil hente data fra",
    "text": "Steg 1: Fortell ggplot() hvor vi vil hente data fra\nSteg 1 er å fortelle ggplot hvor den skal hente data fra. Det gjør vi ved å spesifisere data = argumentet i funksjonen ggplot(). I vårt tilfelle heter datasettet “gapminder” og vi skriver:\n\nggplot(data = gapminder)\n\n\n\n\nHva skjer når vi kjører koden nå? Vi får et helt tomt plott. Mer info må til!"
  },
  {
    "objectID": "seminar/seminar3.html#steg-2-fortell-ggplot-hvilken-sammenheng-vi-vil-plotte",
    "href": "seminar/seminar3.html#steg-2-fortell-ggplot-hvilken-sammenheng-vi-vil-plotte",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Steg 2: Fortell ggplot hvilken sammenheng vi vil plotte",
    "text": "Steg 2: Fortell ggplot hvilken sammenheng vi vil plotte\nDet neste vi gjør er å fortelle ggplot hva vi vil måle på x- og y-aksen. Nå skal vi starte med et stolpediagram, der vi vil se hvor mange observasjoner det er i datasettet fordelt på de fem kontinentene. Da trenger vi bare å gi ggplot beskjed om at vi vil ha continent på x-aksen. Y-aksen vår blir automatisk til antall (count). Senere i dette seminaret skal vi se på et eksempel hvor vi gir informasjon om begge aksene.\nInne i ggplot() hvor vi har fortalt hvilket datasett vi vil bruke, så legger vi til en mapping. aes() står for aestethics, og det vi gjør ved bruk av aes() er å fortelle ggplot hvilke variabler vi vil visualisere. Vi forteller ggplot at vi vil at variabelen continent skal vises på x-aksen.\n\nggplot(data = gapminder, mapping = aes(x = continent))\n\n\n\n\nDet vi skriver i aes() kobler variabler til ting du ser i plottet. Det kan for eksempel være x- og y-verdier (x = variabelnavn, y = variabelnavn), farger (color = variabelnavn), former (shape = variabelnavn) eller størrelse (size = variabelnavn)."
  },
  {
    "objectID": "seminar/seminar3.html#steg-3-fortell-ggplot-hvordan-du-vil-illustrere-sammenhengen",
    "href": "seminar/seminar3.html#steg-3-fortell-ggplot-hvordan-du-vil-illustrere-sammenhengen",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Steg 3: Fortell ggplot hvordan du vil illustrere sammenhengen",
    "text": "Steg 3: Fortell ggplot hvordan du vil illustrere sammenhengen\nNår vi kjører koden, så ser vi at kontinentene er på plass, men vi får likevel ikke noe særlig informasjon fra plottet. Hva mangler? Vi må skrive hva slags plott vi vil lage. Vi vil lage et stolpediagram, og velger geom_bar(). Hvis du prøver å skrive inn geom_ vil du se at du får en hel rekke forslag til ulike plott. Flere av disse skal vi komme tilbake til.\n\nggplot(gapminder, aes(x = continent)) + \n  geom_bar()\n\n\n\n\nDa har vi fått opp et plott som viser observasjonene i datasettet fordelt på kontinenter. Vi kan dobbeltsjekke at dette ser riktig ut ved å lage et summary av variabelen.\n\nsummary(gapminder$continent)\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n\n\nDet ser fint ut. Vi kan også legge inn andre typer av aestetics i mappingen. Her er det flere muligheter, som dere vil bli kjent med etter hvert. Én av dem er å bruke ulike farger for å gi informasjon. Hvis vi vil at hvert kontinent skal få sin egen farge, så kan vi gjøre det slik:\n\nggplot(gapminder, aes(x = continent, fill = continent)) + \n  geom_bar()"
  },
  {
    "objectID": "seminar/seminar3.html#steg-4-legg-til-geom_-etter-behov-en-etter-en.",
    "href": "seminar/seminar3.html#steg-4-legg-til-geom_-etter-behov-en-etter-en.",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Steg 4: Legg til geom_ etter behov en etter en.",
    "text": "Steg 4: Legg til geom_ etter behov en etter en.\nVi kan legge til flere geom_-elementer i plottet vårt ved å bruke +. Vi kan for eksempel legge til en linje som indikerer gjennomsnittlig antall observasjoner per land. Da legger vi først til en variabel som angir antall observasjoner per land i datasettet. Dette gjør vi ved hjelp av funksjonen add_count():\n\ngapminder <- gapminder %>% \n  add_count(continent)\n\nVi kan se i datasettet vårt at vi har fått en ny variabel n. Denne angir antall observasjoner per kontinent i datasettet vårt. For å legge til en linje som indikerer gjenomsnittlig antall observasjoner bruker vi geom_hline() (h for horisontal linje). I aes() gir vi ggplot informasjon om hvor denne linjen skal krysse y-aksen:\n\nggplot(data = gapminder, aes(x = continent, fill = continent)) + \n  geom_bar() +\n  geom_hline(aes(yintercept = mean(n)))"
  },
  {
    "objectID": "seminar/seminar3.html#steg-5-bruk-funksjoner-til-å-justere-skala-etiketter-tittel-o.l..",
    "href": "seminar/seminar3.html#steg-5-bruk-funksjoner-til-å-justere-skala-etiketter-tittel-o.l..",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Steg 5: Bruk funksjoner til å justere skala, etiketter, tittel o.l..",
    "text": "Steg 5: Bruk funksjoner til å justere skala, etiketter, tittel o.l..\nVi kan også endre teksten på x- og y-aksen, og gi plottet en tittel ved å legge til labs(), fjerne boksen med informasjon om farger og navn på høyre side ved hjelp av theme(legend.position = \"none\") og gjøre bakgrunnen litt penere med theme_bw():\n\nggplot(gapminder, aes(x = continent, fill = continent)) + \n  geom_bar() +\n  geom_hline(aes(yintercept = mean(n))) +\n  labs(x = \"\", \n       y = \"Antall land-år-observasjoner\", \n       title = \"Antall observasjoner per kontinent\",\n       caption = \"Gjennomsnittlig antall observasjoner er gitt ved den horisontale linjen\") +\n  theme_bw() +\n  theme(legend.position = \"none\") \n\n\n\n\nDa har vi gått gjennom det helt grunnleggende i ggplot. Dette er en pakke med veldig mange ulike muligheter, og man blir bedre kjent med de for hver gang man bruker den. Vi anbefaler dere å prøve dere fram, og sjekke ut noen av ressursene som vi linker til i bunnen av dokumentet. Kjør gjerne deler av plottet for å se hva de ulike linjene gjør, google dere frem osv."
  },
  {
    "objectID": "seminar/seminar3.html#histogrammer",
    "href": "seminar/seminar3.html#histogrammer",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Histogrammer",
    "text": "Histogrammer\nNår vi undersøker ulike plot kan vi skrive plot_le + i stedet for ggplot(data, aes(lifeExp)) + fordi sistnevne informasjon er lagret i førstnevnte objekt. Dette sparer oss for en del kode. For en kontinuerlig variabel så kan det være mer nyttig med et histogram, som lager stolper for intervaller:\n\nplot_le +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nHvis vi ikke sier noe annet, så kommer ggplot til å velge hvor stort hvert intervall skal være. Vi kan sette hver stolpe til å være ett år bred ved å skrive inn binwidth = 1:\n\nplot_le +\n  geom_histogram(binwidth = 1)\n\n\n\n\nHvis vi vil se hvordan dette fordeler seg på hvert kontinent, så kan vi legge inn fill:\n\nplot_le +\n  geom_histogram(aes(fill = continent),\n                 binwidth = 1, \n                 alpha = 0.5) +\n  theme_bw()\n\n\n\n\nDette gir oss en viss oversikt over hvordan forventet levealder varierer mellom kontinentene, men hvis vi vil se næremere på dette så kan et boxplot for forventet levealder per kontinent være et bedre alternativ."
  },
  {
    "objectID": "seminar/seminar3.html#boxplot",
    "href": "seminar/seminar3.html#boxplot",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Boxplot",
    "text": "Boxplot\nfor å lage et boxplot så spesifiserer vi y-aksen ved hjelp av aes(y = continent) i geom_boxplot:\n\nplot_le + \n  geom_boxplot(aes(y = continent))\n\n\n\n\nHer er et eksempel på hvor mye finere plottet kan bli med litt flere kodelinjer:\n\nplot_le + \n  geom_boxplot(aes(y = continent)) +\n  theme_bw() +\n  labs(title = \"Boxplot for forventet levealder per kontinent\",\n       x = \"Forventet levealder\",\n       y = \"\") +\n  theme(legend.position = \"none\")"
  },
  {
    "objectID": "seminar/seminar3.html#density-plottettshetsplot",
    "href": "seminar/seminar3.html#density-plottettshetsplot",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Density plot/tettshetsplot",
    "text": "Density plot/tettshetsplot\nEn annen metode kan være å bruke et density plot/tetthetsplott:\n\nplot_le + \n  geom_density()\n\n\n\n\nInne i parentesen til plottypen kan vi legge til spesifikasjoner om tykkelse på linja, farge osv.\n\nplot_le + \n  geom_density(linewidth = 1.5, fill = \"pink\", alpha = 0.3)\n\n\n\n\nHva skjer hvis vi endrer 1) alpha til 1 og 2) size til 0.5?\n\nplot_le + \n  geom_density(linewidth = 0.5, fill = \"pink\", alpha = 1)\n\n\n\n\nHvis du ønsker å separere plottene, slik at de ulike kontinentene ikke ligger over hverandre, men får hvert sitt plott, så kan du legge til en facet_wrap:\n\nplot_le + \n  geom_density(linewidth = 0.5, fill = \"pink\", alpha = 1) +\n  facet_wrap(vars(continent)) +\n  theme_bw()"
  },
  {
    "objectID": "seminar/seminar3.html#spredningsplot",
    "href": "seminar/seminar3.html#spredningsplot",
    "title": "Seminar 3 – Omkoding, subsetting og visualisering",
    "section": "Spredningsplot",
    "text": "Spredningsplot\nMed et spredningsplot (scatterplot) kan vi vise sammenhengen mellom to kontinuerlige variabler. Her må vi gi ggplot informasjon om hvilken variabel som skal mappes på x-aksen og på y-aksen. For å lage scatterplottet bruker vi geom_point.\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) + \n  geom_point()\n\n\n\n\nVi kan legge til en linje som viser trenden1 i observasjonene ved å bruke geom_smooth:\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +\n  geom_point() + \n  geom_smooth()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nSkille kontinentene fra hverandre ved bruk av ulike farger:\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap, col = continent)) +\n  geom_point() + \n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nVi kan legge inn en facet_wrap() for at det skal se litt ryddigere ut, og samtidig gi geom_smooth() en farge som vises bedre.\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap, col = continent)) +\n  geom_point() + \n  geom_smooth(colour = \"black\") + \n  facet_wrap(~ continent) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nHer kan vi repetere hvordan vi legger til nye titler til x- og y-aksen, samt tittel for hele plottet:\n\nggplot(gapminder, \n       aes(x = lifeExp, y = gdpPercap, col = continent)) +\n  geom_point() + \n  geom_smooth(colour = \"black\") + \n  facet_wrap(vars(continent)) +\n  labs(x = \"Forventet levealder\", \n       y = \"GDP per capita\", \n       title = \"Et plot med Gapminderdata\") +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'"
  },
  {
    "objectID": "seminar/seminar6.html",
    "href": "seminar/seminar6.html",
    "title": "STV1020",
    "section": "",
    "text": "OBS! DETTE KAPITTELET ER IKKE FERDIG"
  },
  {
    "objectID": "seminar/seminar4.html",
    "href": "seminar/seminar4.html",
    "title": "Seminar 4 – Missingverdier, statistikk og bivariate sammenhenger",
    "section": "",
    "text": "I løpet av dette seminaret skal vi:"
  },
  {
    "objectID": "seminar/seminar4.html#pakker-og-funksjoner",
    "href": "seminar/seminar4.html#pakker-og-funksjoner",
    "title": "Seminar 4 – Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Pakker og funksjoner",
    "text": "Pakker og funksjoner\nNår vi jobber i R så bruker vi mange funksjoner. Noen av disse, som for eksempel mean() og load() er en del av base R. Det betyr at vi ikke trenger å installere og laste inn noen ekstra pakker for at de skal virker. Andre funksjoner som for eksempel %>%, read.dta() og ggplot() ligger i pakker. Da må vi installere og laste inn disse pakkene for å kunne bruke funksjonen.\nInstallere pakker: Vi bruker install.packages(\"pakkenavn\") for å installere pakker. Dette trenger vi bare å gjøre én gang.\nLaste inn pakker: Vi bruker library(pakkenavn) for å laste inn en pakke. Dette må vi gjøre hver gang vi åpner Rstudio på nytt eller åpner en ny sesjon. Dersom du får opp en feilmelding som “Error in library(pakkenavn) : there is no package called ‘pakkenavn’” så indikerer det at du ikke har installert pakken. Da må du kjøre install.packages(\"pakkenavn\") før du forsøker library(pakkenavn) igjen.\nFørst installerer vi nye pakker og laster inn pakkene vi skal bruke i dagens seminar:\n\n# Installerer nye pakker\ninstall.packages(\"stargazer\")\ninstall.packages(\"gmodels\")\ninstall.packages(\"scales\")\n\n\n# Laster inn pakker \nlibrary(tidyverse)\nlibrary(stargazer)\nlibrary(gmodels)\nlibrary(scales)"
  },
  {
    "objectID": "seminar/seminar4.html#tabellanalyse",
    "href": "seminar/seminar4.html#tabellanalyse",
    "title": "Seminar 4 – Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Tabellanalyse",
    "text": "Tabellanalyse\nDersom hypotesen vår består av to kategoriske variabler så kan vi presentere og teste sammenhengen ved hjelp av en krysstabell. Da bruker vi funksjonen table(). I dette eksempelet skal vi bruke samme data som Kellsted og Whitten bruker i sitt eksempel. Hypotesen vi vil teste er altså om kjønn (X) har en sammenheng med hvordan man stemmer (Y) i amerikanske presidentvalg.\nDet første vi gjør er å laste inn datasettet ANES2016small. Dette er samme datasett som Kellstedt og Whitten bruker. Datasettet er i .Rdata-format så da bruker vi funksjonen load til å laste inn data:\n\n# Bytt ut det som står i hermetegn med filbanen og filnavnet på din maskin:\nload(\"../data/ANES2016small.RData\")\n\nVi skal omkode variablene så verdiene blir litt mer intuitive. Det gjør vi ved hjelp av mutate() og recode. mutate() forteller R at vi vil opprette nye variabler. Vi skriver inn navnet på den nye variabelen, et likhetstegn og så hva den nye variabelen skal inneholde. Ved hjelp av recode() forteller vi R at den nye variabelen skal ta utgangspunkt i en gammel variabel, men ta andre verdier:\n\nANES2016small <- ANES2016small %>% \n  mutate(vote = case_match(V2Trump,\n                           1 ~ \"Trump\",\n                           0 ~ \"Clinton\"), \n         gender = case_match(female, \n                             0 ~ \"Male\", \n                             1 ~ \"Female\"))\n\n# Sjekker at omkodingen ble riktig:\ntable(ANES2016small$female, ANES2016small$gender, useNA = \"always\")\n\n      \n       Female Male <NA>\n  0         0 1987    0\n  1      2232    0    0\n  <NA>      0    0   52\n\n# Sjekker at omkodingen ble riktig:\ntable(ANES2016small$V2Trump, ANES2016small$vote, useNA = \"always\")\n\n      \n       Clinton Trump <NA>\n  0       1290     0    0\n  1          0  1178    0\n  <NA>       0     0 1803\n\n\nDet neste vi skal gjøre er å lage en krysstabell med absolutte antall. Da bruker vi funksjonen table(). I dag skal vi lagre krysstabellen i et eget objekt for å bruke den videre. Når vi lagrer krysstabellen som et objekt vil den ikke bli printet automatisk i console. For å printe tabellen i console er det bare å skrive inn objektnavnet og kjøre koden.\nNår vi lager krysstabeller så utgjør den første variabelen radene og den andre kolonnene. Kellstedt og Whitten anbefaler at avhengig variabel representeres ved radene og uavhengig variabel i kolonnene. Jeg kaller objektet krysstabell og fyller ut variablene i table:\n\nkrysstabell <- table(ANES2016small$vote, ANES2016small$gender)\n\nkrysstabell\n\n         \n          Female Male\n  Clinton    737  532\n  Trump      575  596\n\n\nDenne tabellen oppgir frekvensfordelingen i absolutte tall. Vi kan også finne relative tall, altså andeler ved hjelp av prop.table(). prop.table() krever et table-objekt og vi bruker derfor krysstabell. I tillegg spesifiserer vi margin = 2 for å si at vi vil ha andeler per kolonne. Vi vil altså beregne hvor stor andel av henholdvis menn og kvinner som stempte på Trump eller Clinton.\n\nprop.table(krysstabell, margin = 2)\n\n         \n             Female      Male\n  Clinton 0.5617378 0.4716312\n  Trump   0.4382622 0.5283688\n\n\nDersom vi spesifiserer margin = 1 så får vi andeler per rad. I dette tilfelle betyr det at du får informasjon om hvor stor andel av de som stemte på henholdsvis Trump og Clinton som var kvinner og menn. Dersom du ikke tar med argumentet margin så får du en tabell der andel er regnet ut fra alle cellene.\nKjikvadrattesten tester sammenhengen mellom to kategoriske variabler. Den sammenlikner krysstabellen vi har med en hypotetisk tabell fra et annet utvalg der det ikke er noen sammeheng mellom variablene. Så tester den sannsynligheten for at tabellen vår er generert ved en tilfeldighet. Vi bruker funksjonen chisq.test():\n\nchisq.test(krysstabell)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  krysstabell\nX-squared = 19.371, df = 1, p-value = 1.076e-05\n\n\nX-squared, altså kjikvadratet er på 19.371 og p-verdien er godt under 0.05. Har vi støtte for hypotesen vår?\nEn alternativ måte å gjøre dette på er å bruke funksjonen CrossTable() fra pakken gmodels som vi installerte og lastet inn tidligere i seminar. Da får vi en tabell med betraktelig mer informasjon:\n\nCrossTable(ANES2016small$vote, ANES2016small$gender, chisq = T)\n\n\n \n   Cell Contents\n|-------------------------|\n|                       N |\n| Chi-square contribution |\n|           N / Row Total |\n|           N / Col Total |\n|         N / Table Total |\n|-------------------------|\n\n \nTotal Observations in Table:  2440 \n\n \n                   | ANES2016small$gender \nANES2016small$vote |    Female |      Male | Row Total | \n-------------------|-----------|-----------|-----------|\n           Clinton |       737 |       532 |      1269 | \n                   |     4.377 |     5.091 |           | \n                   |     0.581 |     0.419 |     0.520 | \n                   |     0.562 |     0.472 |           | \n                   |     0.302 |     0.218 |           | \n-------------------|-----------|-----------|-----------|\n             Trump |       575 |       596 |      1171 | \n                   |     4.744 |     5.518 |           | \n                   |     0.491 |     0.509 |     0.480 | \n                   |     0.438 |     0.528 |           | \n                   |     0.236 |     0.244 |           | \n-------------------|-----------|-----------|-----------|\n      Column Total |      1312 |      1128 |      2440 | \n                   |     0.538 |     0.462 |           | \n-------------------|-----------|-----------|-----------|\n\n \nStatistics for All Table Factors\n\n\nPearson's Chi-squared test \n------------------------------------------------------------\nChi^2 =  19.73002     d.f. =  1     p =  8.918944e-06 \n\nPearson's Chi-squared test with Yates' continuity correction \n------------------------------------------------------------\nChi^2 =  19.37066     d.f. =  1     p =  1.076483e-05 \n\n \n\n\nVi kan lage søylediagrammer for å presentere sammenhengen grafisk. Igjen, det er alltid lurt, også for deg selv. Det er mer intuitivt å tolke, og lettere å se sammenhenger raskt. Vi kan for eksempel se på antall enheter i de forskjellige kombinasjonene av verdier på variablene vi er interessert i:\n\n# Absolutte tall:\nggplot(ANES2016small, aes(x = vote,\n                          fill = gender)) + \n  geom_bar(position = \"dodge\") +\n  labs(x = element_blank(),\n       y = \"Antall\") +\n  theme(legend.title = element_blank()) +\n  theme_bw()\n\n\n\n\nAlternativt kan vi se på andeler, heller en antall:\n\n# Andeler:\nggplot(ANES2016small, aes(x = vote,\n                          group = gender)) + \n  geom_bar(aes(y = after_stat(prop)),\n           position = \"dodge\") +\n  labs(x = element_blank(),\n       y = element_blank(),\n       title = \"Stemmegivning og kjønn\") +\n  theme(legend.title = element_blank()) +\n  scale_y_continuous(labels = scales::percent) +\n  theme_bw() + \n  facet_wrap(~ gender)"
  },
  {
    "objectID": "seminar/seminar4.html#sammenligne-gjennomsnitt-med-t-test",
    "href": "seminar/seminar4.html#sammenligne-gjennomsnitt-med-t-test",
    "title": "Seminar 4 – Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Sammenligne gjennomsnitt med t-test",
    "text": "Sammenligne gjennomsnitt med t-test\nNår den avhengige variabelen vår er kontinuerlig og den uavhengige er katerogisk så kan vi bruke en t-test til å sjekke om gruppegjennomsnittene er singifikant forskjellige. Før vi gjør det kan vi undersøke sammenhengen i et boxplot. Nå skal vi bruke ESS-datasettet vi lastet inn først i seminaret igjen. I ESS-datasettet er kjonn registrert som en numerisk variabel. For å fortelle R at dette er en kategorisk variabel så kan vi skrive as.factor(kjonn). Prøv gjerne å lage plottet uten as.factor() for å se hva som skjer. Vi lager et boksplot:\n\nggplot(ess, aes(x = utdanning, fill = as.factor(kjonn))) +\n  geom_boxplot()\n\nFor å gjennomføre en tohalet t-test bruker vi funksjonen t.test():\n\nt.test(utdanning ~ as.factor(kjonn), data = ess, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.006425\nalternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0\n95 percent confidence interval:\n 0.1288003 0.7877442\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754 \n\n\nt.test() gir oss da endel informasjon. Først ser vi hvilke variabler vi har kjørt testen på (utdanning og kjønn). Så vises en t-verdi (t ~ 2.73), frihetsgrader (df = 2658) og en p-verdi (p-value = 0.006425). Deretter listes den alternative hypotesen opp; denne er alltid at snittforskjellen mellom grupper ikke er 0. Videre får vi ut nedre og øvre konfidensintervall (0.13, 0.79); dette er området der den faktiske forskjellen i snitt vil ligge 95% av tiden. Til slutt får vi opp snittforskjellene på utdanningmellom gruppe 1 (menn) og gruppe 2 (kvinner). Legg merke til at differansen mellom disse snittene alltid faller midt mellom konfidensintervallet over:\n\n# Differanse mellom snittene\nround(11.74582 - 11.28754, digits = 2)\n\n[1] 0.46\n\n# Midtpunktet mellom nedre og øvre konfidensintervall \nround(sum(0.1288003, 0.7877442) / 2, digits = 2)\n\n[1] 0.46\n\n\nHva sier t-testen om forholdet mellom kjønn og utdanning?\nT-tester kan også spesifiseres på flere måter. Under følger kode for litt forskjellige spesifikasjoner:\n\n# Enhalet test\n# Tester om menn (verdi 1) har signifikant mindre utdanning enn kvinner:\nt.test(utdanning ~ as.factor(kjonn), \n       data = ess, \n       alternative = \"less\",\n       var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.9968\nalternative hypothesis: true difference in means between group 1 and group 2 is less than 0\n95 percent confidence interval:\n      -Inf 0.7347443\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754 \n\n# Enhalet test\n# Tester om menn (verdi 1) har signifikant mer utdanning enn kvinner:\nt.test(utdanning ~ as.factor(kjonn), \n       data = ess, \n       alternative = \"greater\",\n       var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.003213\nalternative hypothesis: true difference in means between group 1 and group 2 is greater than 0\n95 percent confidence interval:\n 0.1818002       Inf\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754 \n\n# Tohalet test\n# Tester om menn (verdi 1) har signifikant forskjellig utdanning fra kvinner:\nt.test(utdanning ~ as.factor(kjonn), \n       data = ess, \n       alternative = \"two.sided\",\n       var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  utdanning by as.factor(kjonn)\nt = 2.7274, df = 2658, p-value = 0.006425\nalternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0\n95 percent confidence interval:\n 0.1288003 0.7877442\nsample estimates:\nmean in group 1 mean in group 2 \n       11.74582        11.28754"
  },
  {
    "objectID": "seminar/seminar4.html#korrelasjonskoeffisient",
    "href": "seminar/seminar4.html#korrelasjonskoeffisient",
    "title": "Seminar 4 – Missingverdier, statistikk og bivariate sammenhenger",
    "section": "Korrelasjonskoeffisient",
    "text": "Korrelasjonskoeffisient\nVi avslutter med bivariat analyse med to kontinuerlige variabler. Dette er en forsmak på bivariat regresjonsanalyse som vi skal se mer på neste gang. Hensikten med dette er å beskrive korrelasjonen eller samvariasjonen mellom variablene. Vi kan beskrive denne sammenhengen med Pearsons r og teste om korrelasjonen er statistisk signifikant.\nI dette eksempelet skal vi gjøre det samme som Kellstedt og Whitten gjør. Vi skal teste hypotesen om det er en positiv sammenheng mellom økonomisk vekst og stemmeandel til den sittende presidentens parti i amerikanske presidentvalg.\nTil dette skal vi igjen laste inn samme datasett som Kellstedt og Whitten bruker. Dette er også det datasettet vi skal bruke neste gang når vi skal se på regresjon. Også dette datasettet er i .Rdata-format så vi bruker load() for å laste det inn:\n\nload(\"../data/FairFPSR3.RData\")\n\nKellstedt og Whitten skriver om kovarians og korrelasjon. Kovarians kan vi finne ved å bruke funksjonen cov(). I cov() må vi spesifisere variablene vi ønsker å se på kovariansen til. I tillegg spesifiserer vi argumentet use = \"complete.obs\" for å fortelle R at vi bare vil se på de observasjonene der vi har data for begge variablene:\n\ncov(x = FairFPSR3$growth,\n    y = FairFPSR3$inc_vote, \n    use = \"pairwise.complete.obs\")\n\n[1] 17.32894\n\n\nHva forteller denne kovariansen oss?\nVi kan også hente ut en kovariansmatrise for alle variablene i datasettet:\n\ncov(FairFPSR3,\n    use = \"pairwise.complete.obs\")\n\n           inc_vote        year inflation   goodnews    growth\ninc_vote  33.472524    8.547825 -1.676461   7.047141 17.328936\nyear       8.547825 1776.000000 15.308000 -31.882353 50.448687\ninflation -1.676461   15.308000  4.118468   1.214432 -1.720625\ngoodnews   7.047141  -31.882353  1.214432   8.114286  3.351746\ngrowth    17.328936   50.448687 -1.720625   3.351746 27.734552\n\n\nSom Kellstedt og Whitten skriver så kan kovarians fortelle oss noe om sammenhengens retning, men den forteller oss ingenting om hvor sikre vi kan være på at denne samvariasjonen skiller seg fra det vi ville fått om det ikke fantes en sammenheng i populasjonen vi ønsker å undersøke. Til det bruker vi Pearson’s r.\nPearsons r beskriver styrken og retningen til korrelasjonen mellom to variabler. Den varierer fra -1 (negativ sammenheng) til 1 (positiv sammenheng). 0 indikerer ingen sammenheng. Pearson’s r finner vi ved hjelp av funksjonen cor(). Vi spesifiserer det samme som vi gjorde i cov; avhengig variabel (y =), uavhengig variabel (x =) og hva vi skal gjøre med missingverdier (use = \"pairwise.complete.obs):2\n\n# Korrelasjon mellom vekst og stemmeandel\ncor(x = FairFPSR3$growth,\n    y = FairFPSR3$inc_vote, \n    use = \"pairwise.complete.obs\")\n\n[1] 0.5687443\n\n\nHvordan kan vi tolke korrelasjonen?\n\n# tester om korrelasojnen er statistisk signifikant\ncor.test(FairFPSR3$inc_vote, \n         FairFPSR3$growth, \n         use = \"pairwise.complete.obs\")\n\n\n    Pearson's product-moment correlation\n\ndata:  FairFPSR3$inc_vote and FairFPSR3$growth\nt = 4.0319, df = 34, p-value = 0.0002955\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.2954061 0.7560163\nsample estimates:\n      cor \n0.5687443 \n\n\nHva er sannsynligheten for at denne sammenhengen skyldes tilfeldigheter med denne p-verdien?\nVi kan også sette opp en korrelasjonsmatrise for å utforske alle de bivariate korrelasjonene i datasettet mellom de akutelle variablene.\n\ncor(FairFPSR3, use = \"pairwise.complete.obs\")\n\n             inc_vote        year  inflation   goodnews     growth\ninc_vote   1.00000000  0.03505822 -0.1414538  0.4236204  0.5687443\nyear       0.03505822  1.00000000  0.1840331 -0.2730679  0.2273096\ninflation -0.14145382  0.18403311  1.0000000  0.2100778 -0.1602891\ngoodnews   0.42362043 -0.27306785  0.2100778  1.0000000  0.2224497\ngrowth     0.56874434  0.22730961 -0.1602891  0.2224497  1.0000000\n\n\nTil slutt skal vi se på hvordan et spredningsdiagram kan brukes til å undersøke sammenhengen mellom to kontinuerlige variabler. Til det bruker vi ggplot. Husk at i ggplot så spesifiserer vi datasett vi ønsker å hente informasjon fra med data = og hvilke variabler vi ønsker å plotte i aes(x = variabelx, y = variabely). Etter dette forteller vi ggplot hvilket plot vi ønsker. For å få et spredningsplot bruker vi geom_point():\n\nggplot(data = FairFPSR3, \n       aes(x = growth, y = inc_vote)) +\n  geom_point()\n\n\n\n\nVi kan også tilpasse plottet ved å endre form på punktene (geom_point(shape = 1)), endre bakgrunn (theme_bw()) og legge til titler på aksene:\n\nggplot(FairFPSR3, aes(x = growth, y = inc_vote)) +\n  geom_point(shape = 1) +\n  theme_bw() +\n  labs(x = \"Percentage Change in Real DGP Per Capita\",\n       y = \"Incumbent Party Vote Percentage\")\n\n\n\n\nUnder overskriften Point på denne siden finner dere en oversikt ove rulike former dere kan velge på punktene.\nTil slutt så kan vi også legge til en prediksjonslinje ved hjelp av geom_smooth(). Ved å spesifisere geom_smooth(method = lm) så forteller vi R at vi vil se prediksjonslinjen for en lineær sammenheng:\n\nggplot(FairFPSR3, aes(x = growth, y = inc_vote)) +\n  geom_point(shape = 1) +\n  theme_bw() +\n  labs(x = \"Percentage Change in Real DGP Per Capita\",\n       y = \"Incumbent Party Vote Percentage\") +\n  geom_smooth(method = \"lm\", formula = y ~ x, color = \"black\")\n\n\n\n\nDette er begynnelsen på en regresjonsanalyse, som er tema for neste seminar."
  },
  {
    "objectID": "seminar/seminar5.html",
    "href": "seminar/seminar5.html",
    "title": "Seminar 5 – Bivariat regresjon",
    "section": "",
    "text": "I dag skal vi se på fem ting:\nDatasettet vi skal bruke er det samme som det som omtales i kapittel ni i The Fundamentals of Political Science Research. I likhet med kapittel ni så skal vi kjøre en regresjon der vi ser på effekten av økonomisk vekst (growth) på andel stemmer partiet til den sittende kandidaten får (inc_vote). Det første vi skal gjøre er å laste inn pakker og laste inn datasettet:\nVi bruker load() for å laste inn data fordi datasettet er i .Rdata-format."
  },
  {
    "objectID": "seminar/seminar5.html#undersøker-data",
    "href": "seminar/seminar5.html#undersøker-data",
    "title": "Seminar 5 – Bivariat regresjon",
    "section": "Undersøker data",
    "text": "Undersøker data\nNår vi skal kjøre en regresjonsanalyse så er noe av det første vi gjør å undersøke datasettet:\n\n# Hent ut informasjon om variabelnavn, klasse m.m.\nstr(FairFPSR3)\n\ntibble [36 × 5] (S3: tbl_df/tbl/data.frame)\n $ inc_vote : num [1:36] 48.5 50.2 49.8 50.4 48.3 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ year     : num [1:36] 1876 1880 1884 1888 1892 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ inflation: num [1:36] NA 1.974 1.055 0.604 2.274 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ goodnews : num [1:36] NA 9 2 3 7 6 7 5 8 8 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n $ growth   : num [1:36] 5.11 3.88 1.59 -5.55 2.76 ...\n  ..- attr(*, \"format.stata\")= chr \"%9.0g\"\n\n# Et alternativ til str()\nglimpse(FairFPSR3)\n\nRows: 36\nColumns: 5\n$ inc_vote  <dbl> 48.516, 50.220, 49.846, 50.414, 48.268, 47.760, 53.171, 60.0…\n$ year      <dbl> 1876, 1880, 1884, 1888, 1892, 1896, 1900, 1904, 1908, 1912, …\n$ inflation <dbl> NA, 1.974, 1.055, 0.604, 2.274, 3.410, 2.548, 1.442, 1.879, …\n$ goodnews  <dbl> NA, 9, 2, 3, 7, 6, 7, 5, 8, 8, 3, 0, 10, 7, 4, 9, 8, 0, 0, 7…\n$ growth    <dbl> 5.110, 3.879, 1.589, -5.553, 2.763, -10.024, -1.425, -2.421,…\n\n# Printer variabelnavnene\nnames(FairFPSR3)\n\n[1] \"inc_vote\"  \"year\"      \"inflation\" \"goodnews\"  \"growth\"   \n\n# Henter ut oppsummerende statistikk:\nsummary(FairFPSR3)\n\n    inc_vote          year        inflation        goodnews     \n Min.   :36.15   Min.   :1876   Min.   :0.000   Min.   : 0.000  \n 1st Qu.:48.84   1st Qu.:1911   1st Qu.:1.431   1st Qu.: 3.000  \n Median :51.46   Median :1946   Median :2.141   Median : 5.000  \n Mean   :51.93   Mean   :1946   Mean   :2.567   Mean   : 5.057  \n 3rd Qu.:54.80   3rd Qu.:1981   3rd Qu.:3.139   3rd Qu.: 7.000  \n Max.   :62.23   Max.   :2016   Max.   :7.795   Max.   :10.000  \n                                NA's   :1       NA's   :1       \n     growth        \n Min.   :-14.3500  \n 1st Qu.: -1.5155  \n Median :  2.1575  \n Mean   :  0.7635  \n 3rd Qu.:  3.9653  \n Max.   : 11.6820  \n                   \n\n\nDet er også lurt å sjekke om mange observasjoner har manglende informasjon (missing) på variablene du er interessert i:\n\n# Sjekker hvor mange observasjoner som vi har informasjon på alle variablene om:\ntable(complete.cases(FairFPSR3))\n\n\nFALSE  TRUE \n    1    35 \n\n\nVi ser at 35 av observasjonene våre ikke har noen missingverdier. Vi kan også sjekke for enkeltvariabler:\n\n# Sjekker hvor mange observasjoner som har missing på variabelen inflation\ntable(is.na(FairFPSR3$inflation))\n\n\nFALSE  TRUE \n   35     1 \n\n\nVi ser at en observasjon har missing på variabelen inflation.\nLegg merke til at funksjonene complete.cases() og is.na() er logiske tester. Disse evaluerer hver observasjon og sjekker om vi har informasjon om alle variabler (complete.cases()) og om vi mangler informasjon på variabelen inflation. For å illustrere dette så kan vi prøve å legge til to nye variabler i datasettet basert på disse logiske testene:\n\nFairFPSR3 <- FairFPSR3 %>% \n  mutate(complete = complete.cases(.),\n         inf_na = is.na(inflation))\n\nBruk View() eller klikk på datasettet ditt for å se hvordan de nye variablene ser ut. Hva betyr TRUE og FALSE i de to kolonnene?\nMer informasjon om missingverdier finner dere i dokumentet som beskriver seminar 4."
  },
  {
    "objectID": "seminar/seminar5.html#omkoding-av-variabler",
    "href": "seminar/seminar5.html#omkoding-av-variabler",
    "title": "Seminar 5 – Bivariat regresjon",
    "section": "Omkoding av variabler",
    "text": "Omkoding av variabler\nEtter at vi har kartlagt datastrukturen og hvilke variabler vi har så må vi vurdere om noen av variablene må omkodes før vi kan gjøre analysen vår. For å få samme resultater som i kapittel ni trenger vi ikke å omkode noe, men for å få noe å sammenligne med skal vi lage en dikotom variabel.\nI tidyverse bruker man som regel mutate()sammen med andre funksjoner for å opprette nye variabler. Koden over hvor vi opprettet variabler for de logiske testene complete.cases() og is.na() er eksempler på dette. Nå skal vi også kombinere mutate() med if.else for å lage en dikotom variabel som tar verdien Growth om observasjonen er et år med positiv økonomisk vekst og No growth om observasjonen er et år uten økonomisk vekst:\n\n# Oppretter den nye variabelen og endrer referansekategori\nFairFPSR3 <- FairFPSR3 %>% \n  mutate(growth_dich = ifelse(growth > 0, \"Growth\", \"No growth\"),\n         growth_dich = factor(growth_dich, levels = c(\"No growth\", \"Growth\")))\n\n\nHvordan ifelse() fungerer er nærmere beskrivet i seminar 3. Det neste vi gjør er å sjekke om omkodingen ble riktig:\n\n# Sjekker at det ser ok ut: \nclass(FairFPSR3$growth_dich)\n\n[1] \"factor\"\n\ntable(FairFPSR3$growth_dich, useNA = \"always\")\n\n\nNo growth    Growth      <NA> \n       11        25         0 \n\n\nNår du lager en faktor-variabel så tar R utgangspunkt i alfabetet når referansekategorien bestemmes. I dette tilfellet ville referansekateogrien blitt “Growth”, men vi bruker factor() til å endre referansekategorien til “No growth”.\nNår en omkoder numeriske variabler så kan det være nyttig å lage et plott for å sjekke at det ble riktig. Her bruker vi fill argumentet til å gi ulik farge til observasjonene basert på om det var vekst eller ikke:\n\nggplot(data = FairFPSR3) +\n  geom_histogram(aes(x = growth, fill = growth_dich),\n               binwidth = 1)\n\n\n\n\nUt fra plottet kan vi se at alle observasjonene med verdien No growth hadde negativ vekstrate, mens alle observasjoner med verdien Growth hadde positiv vekstrate. Hva ville dere gjort med plottet før det evt kan brukes i en oppgave?"
  },
  {
    "objectID": "seminar/seminar5.html#litt-plotting-før-regresjon",
    "href": "seminar/seminar5.html#litt-plotting-før-regresjon",
    "title": "Seminar 5 – Bivariat regresjon",
    "section": "Litt plotting før regresjon",
    "text": "Litt plotting før regresjon\nFør du kjører en regresjon så kan det være lurt å plotte den avhengige og den uavhengige variabelen din. I vårt tilfelle er dette variabelene inc_vote og growth. For å få til dette bruker vi ggplot.\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\")"
  },
  {
    "objectID": "seminar/seminar5.html#regresjon-med-numerisk-uavhengig-variabel",
    "href": "seminar/seminar5.html#regresjon-med-numerisk-uavhengig-variabel",
    "title": "Seminar 5 – Bivariat regresjon",
    "section": "Regresjon med numerisk uavhengig variabel",
    "text": "Regresjon med numerisk uavhengig variabel\nFor å kjøre en lineær regresjon i R så bruker vi funksjonen lm(). lm() har følgende syntaks:\n\nlm(avhengig_variabel ~ uavhengig_variabel, data = mitt_datasett)\n# På mac får du ~ med alt + k + space\n\nDersom datasettet ditt har manglende informasjon (missing/NA) så må du legge til et element som sier hvordan regresjonen skal forholde seg til dette. Ved å legge til na.action = \"na.exclude\" i lm() så beholder R informasjon om hvilke observasjoner som mangler data slik at vi kan bruke fitted() som vi skal snakke mer om senere.\nI eksempelet fra kapittel ni i Kellsted og Whitten er vi interessert i effekten av den uavengige variabelen growth på den avhengige variabelen inc_vote. Under kjører vi modellen og lagrer den som model i Environment:\n\nmodel <- lm(inc_vote ~ growth, \n            data = FairFPSR3,\n            na.action = \"na.exclude\")\n\nDet finnes flere måter å undersøke resultatene på. Vi skal se på hvordan vi kan gjøre dette ved hjelp av summary(), stargazer() og ggplot(). Vi skal først se på summary().\n\nsummary(model)\n\n\nCall:\nlm(formula = inc_vote ~ growth, data = FairFPSR3, na.action = \"na.exclude\")\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-8.1384 -3.7445 -0.6354  2.8291 10.0700 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  51.4486     0.8133  63.256  < 2e-16 ***\ngrowth        0.6248     0.1550   4.032 0.000295 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.828 on 34 degrees of freedom\nMultiple R-squared:  0.3235,    Adjusted R-squared:  0.3036 \nF-statistic: 16.26 on 1 and 34 DF,  p-value: 0.0002955\n\n\nVed å bruke summary får vi informasjon om koeffisienten (Estimate), standardfeilen (Std. Error), t-verdien (t-value) og p-verdien (Pr(>|t|)). Av summary kan vi derfor lese at koeffisienten til growth er 0.6248 og p-verdien er 0.000295. P-verdien er lavere enn 0.01 og vi kan derfor si at koeffisienten er signifikant på 1 prosents nivå.\nstargazer() er en nyttig funksjon som gir oss mye av den samme informasjonen som summary(), men i et litt mer lettlest format.\n\nstargazer(model, \n          type = \"text\")\n\n\n===============================================\n                        Dependent variable:    \n                    ---------------------------\n                             inc_vote          \n-----------------------------------------------\ngrowth                       0.625***          \n                              (0.155)          \n                                               \nConstant                     51.449***         \n                              (0.813)          \n                                               \n-----------------------------------------------\nObservations                    36             \nR2                             0.323           \nAdjusted R2                    0.304           \nResidual Std. Error       4.828 (df = 34)      \nF Statistic           16.256*** (df = 1; 34)   \n===============================================\nNote:               *p<0.1; **p<0.05; ***p<0.01\n\n\nVed hjelp av stargazer så kan vi også lagre tabeller lokalt på PC-en som vi kan bruke i word-dokumenter og liknende. Da endrer vi på type argumentet og legger til et out argument. out argumentet forteller i hvilken mappe du vil lagre filen samt hva filen skal hete. Da får du en .htm-fil som ser omtrent ut som i eksempelet under. Den kan du høyreklikke på og velge åpne i word dersom du skal ha tabellen inn i en oppgave eller liknende:\n\nstargazer(model,  \n          type = \"html\",\n          out = \"model1_tab.htm\")\n\nInformasjonen vi får ved hjelp av summary() og stargazer() er veldig nyttig.Vi får vite koeffisientene, standardfeilene og informasjon vi kan bruke til å evaluere modellen vår. I seminar skal vi bruke en del tid på å tolke disse tabellene.\nEt alternativ til tabeller er å plotte resultatene fra regresjonen. Nå skal vi lage figur 9.4 i kapittel ni ved hjelp av ggplot().\nFørst lager vi et plott med de observerte verdiene (dette er det samme plottet som vi lagde tidligere):\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\")\n\n\n\n\nDet neste vi skal gjøre er å legge til regresjonslinjen i plottet. Dette kan gjøres på to måter.\n\nLegge til regresjonslinje med geom_smooth\nDen første måten er å bruke geom_smooth(method = \"lm\") for å plotte en regresjonslinje:\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\") +\n  geom_smooth(aes(x = growth, y = inc_vote),\n              method = \"lm\", color = \"goldenrod3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nI kapittel ni viser Kellstedt og Whitten at regresjonslinjen krysser utvalgets gjennomsnittsverdier på uavhengig og avhengig variabel. Det kan vi også vise ved å legge til to linjer i koden vår:\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\") +\n  geom_smooth(aes(x = growth, y = inc_vote),\n              method = \"lm\", color = \"goldenrod3\") +\n  geom_hline(yintercept = mean(FairFPSR3$inc_vote), linetype = \"dashed\") +\n  geom_vline(xintercept = mean(FairFPSR3$growth), linetype = \"dashed\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nLegge til regresjonslinje med fitted() og geom_line()\nDen andre metoden er å be R løse regresjonslikningen for alle observasjonene våre og så legge til et nytt lag med predikerte verdier i plottet. Denne metoden går vi ikke gjennom i detalj på seminar så det holder i massevis å kunne den første.\nR kan regne ut de predikerte verdiene for oss ved hjelp av funksjonen fitted() så vi slipper heldigvis å gjøre det for hånd.\nHer bruker vi funksjonene fitted() og resid() til å legge til predikerte verdier og residualer for de ulike variablene i datasettet vårt:\n\nFairFPSR3 <- FairFPSR3 %>% \n  mutate(fitted = fitted(model), \n         residuals = resid(model))\n\nNå kan vi bruke denne informasjonen til å legge til en regresjonslinje i plottet vårt. Prikkene angir de ulike observerte verdikominasjonene, mens den rette linjen gir oss den lineære sammenhengen fra modellen vår.\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  geom_line(aes(x = growth, y = fitted)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\")\n\n\n\n\nOgså her kan vi vise at regresjonslinjen krysser utvalgets gjennomsnittsverdier på uavhengig og avhengig variabel. Vi legger til de to linjene geom_hline() og geom_vline():\n\nggplot(data = FairFPSR3) +\n  geom_point(aes(x = growth, y = inc_vote)) +\n  theme_bw() +\n  labs(y = \"Incumbent-Party Vote Percentage\",\n       x = \"Percentage change in Real GDP Per Capita\") +\n  geom_line(aes(x = growth, y = fitted)) +\n  geom_hline(yintercept = mean(FairFPSR3$inc_vote), linetype = \"dashed\") +\n  geom_vline(xintercept = mean(FairFPSR3$growth), linetype = \"dashed\")"
  },
  {
    "objectID": "seminar/seminar5.html#konfidensintervall",
    "href": "seminar/seminar5.html#konfidensintervall",
    "title": "Seminar 5 – Bivariat regresjon",
    "section": "Konfidensintervall",
    "text": "Konfidensintervall\nI kapittel ni i Kellstedt og Whitten er det flere eksempler på hvordan vi kan sjekke om en modell er god eller ikke. Noe av det gikk vi gjennom når vi så på resultatene av modellen. En ting som ikke kommer med når vi bruker stargazer() og summary() er konfidensintervallene til en koeffisient. De kan vi enkelt hente ut ved hjelp av funksjonen confint():\n\nconfint(model)\n\n                 2.5 %     97.5 %\n(Intercept) 49.7957308 53.1015677\ngrowth       0.3098843  0.9397437"
  },
  {
    "objectID": "seminar/seminar5.html#regresjon-med-dikotom-uavhengig-variabel",
    "href": "seminar/seminar5.html#regresjon-med-dikotom-uavhengig-variabel",
    "title": "Seminar 5 – Bivariat regresjon",
    "section": "Regresjon med dikotom uavhengig variabel",
    "text": "Regresjon med dikotom uavhengig variabel\nFor å øve oss på tolkning skal vi nå kjøre en modell med inc_vote som avhengig variabel og den dikotome vekst-variabelen vi lagde tidligere som uavhengig variabel. At en variabel er dikotom betyr at den bare har to verdier. Først kjører vi modellen før vi undersøker resultatene i stargazer:\n\n# Lagrer modellen\nmodel_dich <- lm(inc_vote ~ growth_dich, \n                 data = FairFPSR3,\n                 na.action = \"na.exclude\")\n\n# Undersøker resultatene\nstargazer(model_dich, \n          type = \"text\")\n\n\n===============================================\n                        Dependent variable:    \n                    ---------------------------\n                             inc_vote          \n-----------------------------------------------\ngrowth_dichGrowth              2.859           \n                              (2.066)          \n                                               \nConstant                     49.940***         \n                              (1.722)          \n                                               \n-----------------------------------------------\nObservations                    36             \nR2                             0.053           \nAdjusted R2                    0.025           \nResidual Std. Error       5.711 (df = 34)      \nF Statistic             1.914 (df = 1; 34)     \n===============================================\nNote:               *p<0.1; **p<0.05; ***p<0.01"
  },
  {
    "objectID": "proveinfo.html",
    "href": "proveinfo.html",
    "title": "STV1020",
    "section": "",
    "text": "Nei.\n\n\n\nNei.\n\n\n\n[TBD! Vi jobber med løsning på dette.]\n\n\n\n\n\n\n\n\n\n\n[TBD! Vi har ikke bestemt dette enda.]\n\n\n\nDu skal levere et R-script med koden din og kommentarer. Du skal ikke laste opp figurer og tabeller. Seminarleder kjører scriptet ditt og vil på den måten se om koden for en figur eller tabell er riktig.\n\n\n\nJa, du står fritt til å bruke alle hjelpemidler. Det inkluderer seminarmateriellet som er tilgjengelig på github, notater du har tatt i seminar og google. Det kan være lurt å gjøre seg kjent med beskrivelsene av de ulike seminarene i forkant av prøven så du vet hvor du skal slå opp.\n\n\n\nJa, dere har lov til å samarbeide og diskutere oppgavene med medstudenter, men alle må levere sitt eget script med egne kommentarer.\n\n\n\nNei. På prøven er det spesifisert hvor mange poeng du må få for å bestå.\n\n\n\nHvis du er syk så må du søke om utsatt obligatorisk aktivitet.\nDersom du får godkjent utsatt obligatorisk aktivitet så vil du få en ny prøvedato.\n\n\n\nHusk å laste inn de nødvendige pakkene ved hjelp av library(). Gjør det først i scriptet så er du ferdig med det. Om du ikke vet hvilken funksjon du skal bruke for å løse en oppgave så slå opp i materiale eller søk på nett.\nOm en kodesnutt ikke vil kjøre så:\n\nlast inn nødvendige pakker igjen.\nkjør all koden før kodesnutten på ny.\nprøv å forstå feilmeldingen. Får du f.eks. en feilmelding som sier “could not find function” så kan dette tyde på at du kanskje har skrevet funksjonsnavnet feil eller at du må laste inn pakken funksjonen ligger i med library() først. Får du en feilmelding om at “object x not found” så kan dette tyde på at du har en skrivefeil i navnet på f.eks. et datasett eller et modellnavn.\nom dette ikke virker så gå videre og kom tilbake til oppgaven senere dersom du har tid. Da kan du søke på nett e.l. etter en løsning."
  }
]